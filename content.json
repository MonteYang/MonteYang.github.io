{"meta":{"title":"MonteYang's Blog","subtitle":"朝着咸鱼的反方向努力","description":"❤MY","author":"Monte Yang","url":"http://monteyang.cn","root":"/"},"pages":[{"title":"[404]","date":"2020-02-18T09:24:57.728Z","updated":"2020-02-18T09:24:57.728Z","comments":true,"path":"404.html","permalink":"http://monteyang.cn/404.html","excerpt":"","text":""},{"title":"关于我&本站","date":"2019-12-16T07:34:13.000Z","updated":"2020-02-18T09:25:44.484Z","comments":true,"path":"about/index.html","permalink":"http://monteyang.cn/about/index.html","excerpt":"","text":"关于我 BUPT研二在读 兴趣：3D Deep learning, Python E-mail: 59786677@qq.com Github: https://github.com/MonteYang 关于本站 2019-12-16 : Github Pages + hexo 博客建站，主要用于记录博主技术积累、生活总结等 2020-02-18 : Github Pages + Coding Pages 双线部署，绑定域名"},{"title":"分类","date":"2019-12-16T03:01:48.000Z","updated":"2020-02-18T08:30:04.824Z","comments":false,"path":"categories/index.html","permalink":"http://monteyang.cn/categories/index.html","excerpt":"","text":""},{"title":"实用网站","date":"2020-02-11T16:50:41.003Z","updated":"2020-02-11T16:50:41.003Z","comments":false,"path":"bookmarks/index.html","permalink":"http://monteyang.cn/bookmarks/index.html","excerpt":"","text":"^_^ 中文版：Linux C/C++编程一站式学习 廖雪峰的Python教程 Python Cookbook 3rd Edition Documentation Deep Learning 动手学习深度学习 PyTorch中文文档 数据结构 数据结构和算法动态可视化 Graph Editor Book 计算机书籍控：计算机类书籍资源 Blog hexo 中文文档 Next主题使用文档 Font Awesome 图标"},{"title":"标签","date":"2019-12-16T04:04:27.000Z","updated":"2020-02-18T08:30:20.400Z","comments":false,"path":"tags/index.html","permalink":"http://monteyang.cn/tags/index.html","excerpt":"","text":""},{"title":"常用工具","date":"2020-02-11T08:33:30.000Z","updated":"2020-02-12T05:56:00.008Z","comments":false,"path":"tools/index.html","permalink":"http://monteyang.cn/tools/index.html","excerpt":"","text":"TODO…你来早啦… VSCode Terminator BaiduPSC-GO"}],"posts":[{"title":"Python-正则表达式","slug":"Python-正则表达式","date":"2020-02-12T07:51:08.000Z","updated":"2020-02-18T09:14:42.092Z","comments":true,"path":"Python-正则表达式.html","link":"","permalink":"http://monteyang.cn/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","excerpt":"关于Python中正则表达式的总结","text":"关于Python中正则表达式的总结 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），用于字符串的匹配和提取等操作。 正则表达式的匹配模式在任意编程语言中都是通用的。 常用的正则表达式：https://c.runoob.com/front-end/854 最常用的正则表达式 正则表达式 功能 . 匹配任意字符,除换行符\\n * 将上一个字符重复0次或多次 + 将上一个字符重复1次或多次 ? 将上一个字符重复0次或1次 \\s 匹配空白字符 \\d 匹配任意数字 匹配字符串首尾在正则表达式的首部添加^，意味着待匹配的字符串从首部就要和正则式匹配。类似的，正则式尾部添加$，表示待匹配的字符串从尾部需和正则式匹配。 ^：匹配字符串的起始 $：匹配字符串的末尾 分组利用分组, 可以提取字符串中你想要的内容。 123456789&gt;&gt;&gt; m = re.match(r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$', '010-12345') # 匹配电话号码, 用括号`()`括起来的正则表达式表示一个分组&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; m.group(0) # 用group函数可以提取匹配的部分'010-12345'&gt;&gt;&gt; m.group(1) # group(1)表示第一个分组'010'&gt;&gt;&gt; m.group(2) # group(2)表示第一个分组'12345' 用括号()括起来的正则表达式表示一个分组 想判断字符串中具有一致规律的多个子串时, 可以采用分组： 例如，正则表达式 &lt;(\\w*)&gt;.*&lt;(/\\1)&gt; 可以匹配 &lt;h1&gt;fadsfas&lt;\\h1&gt;，不能匹配 &lt;h1&gt;fadsfas&lt;\\h2&gt;。 当分组个数过多时，可以给分组起别名，在同一个正则表达式中重复引用该分组。 分组起别名：(?P&lt;name&gt;___) 其中___填写分组内的正则式 引用别名为name的分组：(?P=name) re 模块 re.match()： 从头开始匹配，可以利用分组获得我们想要的子串。用法见上文。 re.search()： 无需从头开始匹配，只返回匹配的第一个子串。 re.findall()： 找到字符串中所有匹配的元素，直接返回一个包含这些元素的list。 re.sub()： 批量替换。 re.split()：分割字符串。","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"Python-多任务的实现","slug":"Python-多任务的实现：进程、线程、协程","date":"2020-02-12T04:48:21.000Z","updated":"2020-02-18T09:16:51.444Z","comments":true,"path":"Python-多任务的实现：进程、线程、协程.html","link":"","permalink":"http://monteyang.cn/Python-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.html","excerpt":"关于 Python 中多任务的实现方式：进程、线程、协程","text":"关于 Python 中多任务的实现方式：进程、线程、协程 多任务的实现方式 多进程 多线程 多进程+多线程 协程（Python中） 多进程ProcessPython中，使用multiprocessing模块实现多进程。其中Process是一个进程类，可实例化一个进程对象。 123456789101112131415161718192021222324252627from multiprocessing import Processimport os# 子进程的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) # 打印当前进程 pid # 实例化一个进程，注意传入的参数为一个元组，当只有一个参数时，写成(arg,) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() # join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 print('Child process end.')'''执行结果如下：Parent process 928.Child process will start.Run child process test (929)...Process end.''' 进程池当启动大量子进程时，为了防止系统资源占用过高，需采用进程池的方式，循环利用进程实现多任务。 123456789101112131415161718192021222324252627282930313233343536373839from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) # 创建进程池，参数为进程池中允许存在进程的最多个数 for i in range(5): p.apply_async(long_time_task, args=(i,)) # 注意 apply_async：异步非阻塞 print('Waiting for all subprocesses done...') p.close() p.join() print('All subprocesses done.')'''执行结果如下：Parent process 669.Waiting for all subprocesses done...Run task 0 (671)...Run task 1 (672)...Run task 2 (673)...Run task 3 (674)...Task 2 runs 0.14 seconds.Run task 4 (673)...Task 1 runs 0.27 seconds.Task 3 runs 0.86 seconds.Task 0 runs 1.41 seconds.Task 4 runs 1.91 seconds.All subprocesses done.''' join()方法会等待所有子进程执行完毕，再执行下面的代码。 调用join()之前必须先调用close()。 调用close()之后就不能继续在进程池中添加新的Process。 由于创建进程池对象时传进的参数为4，因此task 0，1，2，3立刻执行，task 4等待前面某个task完成后才执行，最多同时执行4个进程。 Pool的默认大小是CPU的核数。 多线程线程是操作系统直接支持的执行单元。 Python中，由于存在GIL锁：Global Interpreter Lock，任何线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，因此多线程在Python中只能交替执行，并不能加快效率。 ThreadingThreading模块可实现Python中的多线程。 1234567891011121314151617181920212223242526272829303132import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name)'''执行结果如下：thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended.''' 由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程。名字仅仅用来显示，没有其他意义。 Lock多线程中，所有变量都由所有线程共享，因此多个线程同时对一个变量进行修改，容易造成混乱。 Python中threading模块的Lock类，可以给线程中的部分代码加锁，加锁部分运行时，其中的变量不会被其他线程更改。 12345678910111213import threadinglock = threading.Lock()def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() 协程利用了程序中的延时时间，实际上还是单线程，但是不断的切换所执行的代码块。` Python中可以使用 gevent 模块实现协程。 12345678910111213141516import timeimport geventfrom gevent import monkey# 打个补丁：将程序中的延时代码，换为gevent中的monkey.patch_all()def continue_work(name): for i in range(5): print(name, i) time.sleep(0.5)gevent.joinall([ gevent.spawn(continue_work, 'work_1') # (函数名, 传入函数的参数) gevent.spawn(continue_work, 'work_2')]) 进程、线程、协程对比 进程是资源分配的单位，线程是操作系统调度的单位 进程切换时，需要创建一份资源，效率较低 线程切换需要的资源少，但效率一般 协程切换任务效率高，利用了线程延时等待的时间（因此，在实际处理时率先考虑使用协程实现多任务） 多线程和多进程有可能是并行的，但协程一定是并发的 参考 廖雪峰的官方网站：https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"论文阅读-Bag of Tricks for Image Classification with Convolutional Neural Networks","slug":"论文阅读-Bag of Tricks for Image Classification with Convolutional Neural Networks","date":"2020-02-11T07:45:42.000Z","updated":"2020-02-18T09:08:43.320Z","comments":true,"path":"论文阅读-Bag of Tricks for Image Classification with Convolutional Neural Networks.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Bag%20of%20Tricks%20for%20Image%20Classification%20with%20Convolutional%20Neural%20Networks.html","excerpt":"《Bag of Tricks for Image Classification with Convolutional Neural Networks》论文阅读","text":"《Bag of Tricks for Image Classification with Convolutional Neural Networks》论文阅读 文章目录: Abstract 1. Introduction 文章结构 2. Training Procedures (基准的训练过程) 2.1 Baseline Training Procedure 2.2 Experiment Results 3. Efficient Training (训练效率) 3.1 Large-batch training (针对Batch和learning rate) 1. Linear scaling learning rate (lr的初始化随batch size 线性增加) 2. Learning rate warmup (训练期间,lr逐渐增加到初始值) 3. Zero $\\gamma$ (针对residual block中的BN层初始化) 4. No bias decay 3.2. Low-precision training (GPU低精度) 4. Model Tweaks (模型调整) 4.1 介绍ResNet网络结构 4.2 ResNet的调整 5. 训练改进 5.1. cos学习率衰减 (Cosine Learning Rate Decay) 5.2. 标签平滑 (Label Smoothing) 5.3 知识蒸馏 (Knowledge Distillation) 5.4 混合训练 (Mixup Training) 6. 迁移学习 语义分割 Abstract本文整理了CNN的一些tricks. 1. Introduction 网络结构发展: AlexNet, VGG, NiN, Inception, ResNet, DenseNet, NASNet. 提升训练效果的技巧: 损失函数 数据预处理 优化方法 次要的 tricks: 修改卷积层的 stride 调整 learning rate 这些 tricks 不仅可以用在分类任务,也可以应用于目标检测和语义分割任务中. 文章结构 Section 2: 设置一个训练的 baseline Section 3: 讨论几种 tricks Section 4: review 三种 ResNet 网络结构,提出一种新的网络结构 Section 5: 额外的训练改进 Section 6: 迁移学习 2. Training Procedures (基准的训练过程)2.1 Baseline Training Procedure Randomly sample an image and decode it into 32-bit floating point raw pixel values in [0; 255]. Randomly crop a rectangular region whose aspect ratio is randomly sampled in [3/4, 4/3] and area randomly sampled in [8%; 100%], then resize the cropped region into a 224-by-224 square image. Flip horizontally with 0.5 probability. Scale hue, saturation, and brightness with coefficients uniformly drawn from [0.6, 1.4]. Add PCA noise with a coefficient sampled from a normal distribution N(0, 0.1) Normalize RGB channels by subtracting 123.68, 116.779, 103.939 and dividing by 58.393, 57.12, 57.375, respectively. 未做额外的随机数据增强处理 初始化 网络权重W初始化: Xavier algorithm In particular, we set the parameter to random values uniformly drawn from [−a; a], where a = p6=(din + dout). Here din and dout are the input and output channel sizes, respectively. Bias 初始化: All biases are initialized to 0. BN 层初始化: For batch normalization layers, γ vectors are initialized to 1 and β vectors to 0. 优化 Nesterov Accelerated Gradient (NAG) descent Each model is trained for 120 epochs on 8 Nvidia V100 GPUs with a total batch size of 256. The learning rate is initialized to 0.1 and divided by 10 at the 30th, 60th, and 90th epochs. 2.2 Experiment Results 论文的 baseline 与 reference 之间的对比 3. Efficient Training (训练效率)3.1 Large-batch training (针对Batch和learning rate) 增大 batch size, 导致 使训练过程变慢 对于非凸问题, 收敛速率降低 换言之, 对于相同的epoch, 选择大的batch size所得到验证集准确率低于小的batch size所得到的验证集准确率 1. Linear scaling learning rate (lr的初始化随batch size 线性增加) 当 batch size 增加时, 使 learning rate 的初始值相应增加 a large batch size reduces the noise in the gradient, so we may increase the learning rate to make a larger progress along the opposite of the gradient direction.(大的 batch size 降低了梯度的噪声, 所以我们需要增大 learning rate, 以更大的步长朝着梯度的反方向前进). 例子 if we follow He et al. [9] to choose 0.1 as the initial learning rate for batch size 256, then when changing to a larger batch size b, we will increase the initial learning rate to 0.1 × b/256. 2. Learning rate warmup (训练期间,lr逐渐增加到初始值) lr 由 0 初始化, 线性增长到 initial value. 在训练初期,所有参数都是随机初始化,所以此时离最终的结果还很远.此时,用一个很大的lr会导致数值不稳定.因此,在warmup策略中,采用线性增长的lr,初期时lr值很小,随着数值稳定时,采用大的lr. lr 从 0 线性增长到初始化值 Goyal et al. [7] proposes a gradual warmup strategy that increases the learning rate from 0 to the initial learning rate linearly. In other words, assume we will use the first m batches (e.g. 5 data epochs) to warm up, and the initial learning rate is η, then at batch i, 1 ≤ i ≤ m, we will set the learning rate to be iη=m 3. Zero $\\gamma$ (针对residual block中的BN层初始化) 将residual block的最后一层(BN)中的 gamma 值以 0 初始化. ResNet网络由多个residual block组成, 每个block有几个卷积层. 注意每个 block 的最后一层都是 BN 层. 给定 input x, 假定 block(x)是这个block的输出,则这个 residual block 的输出是 x + block(x) . 在 zero gamma 策略中, 我们将所有 BN 层的 gamma 以 0 初始化. 这就导致了所有 residual block 的输出直接返回了输入, 即 return = x + block(x) = x + 0 = x , 使得 residual block 在初期很容易进行训练. 4. No bias decay 不对任何层的 bias 使用正则化 decay. weight decay 一般应用于所有的 learnable param 包括 weights 和 bias. 不对任何层的 bias 使用正则化 Conv层 FC层 BN层 以上所述针对于 batch size 小于 2K 的情况.TODO 分层自适应学习率,针对大规模batch情况.Note that LARS [4] offers layer-wise adaptive learning rate and is reported to be effective for extremely large batch sizes (beyond 16K). 3.2. Low-precision training (GPU低精度)GPU切换成FP16模式: 只适用于好的GPU如V100, 暂时不用考虑. 4. Model Tweaks (模型调整)4.1 介绍ResNet网络结构略 4.2 ResNet的调整 ResNet-BTODO ?? ResNet-C - 将输入第一个conv层的7x7改成3x3such as SENet [12], PSPNet [31], DeepLabV3 [1], and ShuffleNetV2 [21] ResNet-D - 在shortcut路径上,添加一个AvgPool层 5. 训练改进5.1. cos学习率衰减 (Cosine Learning Rate Decay)学习率的调整在训练过程中至关重要. step decay - 每隔30 epochs,降低0.1 cosine decay 根据当前的batch数来调整学习率 Assume the total number of batches is T (the warmup stage is ignored), then at batch t, the learning rate $lr$ is computed as: $lr=\\frac{1}{2}(1+cos(\\frac{t\\pi}{T}))$ 曲线形状为cos曲线0~$\\pi$的部分 学习率开始时下降的缓慢 中间类似线性下降 最后下降的缓慢 5.2. 标签平滑 (Label Smoothing)5.3 知识蒸馏 (Knowledge Distillation)5.4 混合训练 (Mixup Training) 6. 迁移学习语义分割 trick work? cos学习率下降 yes 标签平滑 no 蒸馏 no 因为[标签平滑\\知识蒸馏\\混合]模糊了像素级别的信息,可能会降低整体的准确率. TODO: 了解网络结构 SE-ResNeXt-50, SE代表什么? 与ResNet的联系? TODO: 用于处理大规模batch情况: LARS [4] offers layer-wise adaptive learning rate","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"笔记","permalink":"http://monteyang.cn/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"LeetCode-41-50题","slug":"LeetCode-41-50题","date":"2020-02-11T05:24:11.000Z","updated":"2020-02-18T09:21:35.808Z","comments":true,"path":"LeetCode-41-50题.html","link":"","permalink":"http://monteyang.cn/LeetCode-41-50%E9%A2%98.html","excerpt":"leetcode 41~50 题","text":"leetcode 41~50 题 41. 缺失的第一个正数给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 12345678910111213class Solution: def firstMissingPositive(self, nums: List[int]) -&gt; int: _nums = [-1] * len(nums) for n in nums: if n &lt;= 0 or n &gt; len(nums): continue else: _nums[n-1] = n for i, num in enumerate(_nums): if num != i+1: return i+1 return len(nums)+1 42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 1234567891011121314151617class Solution: def trap(self, height: List[int]) -&gt; int: water_sum = 0 left_max_height = 0 # 遍历从 idx=1 到 idx=leng(height)-2 for i in range(1, len(height) - 1): # 求左边最高的墙高 left_max_height = height[i - 1] \\ if height[i - 1] &gt; left_max_height else left_max_height # 求右边最高的墙高 right_max_height = 0 right_max_height = max(height[i+1:]) # 当前列可容纳的水量 water = max(min(left_max_height, right_max_height) - height[i], 0) water_sum += water return water_sum 43. 字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = &quot;2&quot;, num2 = &quot;3&quot; 输出: &quot;6&quot; 示例 2: 输入: num1 = &quot;123&quot;, num2 = &quot;456&quot; 输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 12345678910111213141516171819202122232425class Solution: def __init__(self): self._dict = &#123;&#125; for i in range(10): self._dict.update(&#123;str(i): i&#125;) def multiply(self, num1: str, num2: str) -&gt; str: # 使num1为长度较小的 if len(num1) &gt; len(num2): num1, num2 = num2, num1 num2 = self.str2int(num2) # 将num1的每一位与num2相乘 res = 0 for i in range(1, len(num1)+1): res += self._dict[num1[-i]] * num2 * (10**(i-1)) return str(res) def str2int(self, num): \"\"\"将str类型转化为int类型\"\"\" ret = 0 for i in range(1, len(num)+1): ret += self._dict[num[-i]] * (10**(i-1)) return ret 44. TODO12 45. TODO12 46. TODO12 47. TODO12 48. TODO12 49. TODO12 50. TODO12","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/tags/LeetCode/"}]},{"title":"Reinforcement Learning-马尔可夫决策过程","slug":"Reinforcement-Learning-马尔科夫决策过程","date":"2020-02-09T15:15:16.000Z","updated":"2020-02-18T09:08:26.696Z","comments":true,"path":"Reinforcement-Learning-马尔科夫决策过程.html","link":"","permalink":"http://monteyang.cn/Reinforcement-Learning-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.html","excerpt":"马尔科夫性 - 马尔可夫过程 - 马尔可夫奖励过程 - 马尔可夫决策过程","text":"马尔科夫性 - 马尔可夫过程 - 马尔可夫奖励过程 - 马尔可夫决策过程 概述马尔可夫决策过程（Markov Decision Processes, MDPs）是对强化学习问题的数学描述。 要求环境是全观测的。 马尔可夫性 “只要知道现在，将来和过去是条件独立的，可以抛去过去所有的信息。” 定义：如果在t时刻的状态$S_t$满足下式，则这个状态被称为马尔科夫状态，即该状态满足马尔科夫性 P[S_{t+1}|S_{t}] = P[S_{t+1}|S_1, ..., S_t]注： 状态$S_t$包含了所有历史相关信息，即之前的信息都可以在该状态上体现出来 所以要求环境是全观测的，(如果是部分观测的话，状态信息有缺失)。 是否满足马尔可夫性与状态的定义息息相关 例子： 下棋 俄罗斯方块 有了马尔可夫状态之后： 定义状态转移矩阵 忽略时间的影响 状态转移矩阵状态转移概率指从一个马尔可夫状态 s 跳转到后继状态 (successorstate) s′ 的概率。 \\mathcal{P} _ {ss^{'}} = \\mathbb{P} [S_{t+1} = s^{'} | S_t = s]若状态是离散的（有限个）：所有的状态组成行，所有后继状态组成列，得到状态转移矩阵 \\mathcal{P} = \\begin{bmatrix} \\mathcal{P} _ {11} & ... & \\mathcal{P} _ {1n} \\\\ ... & ... & ... \\\\ \\mathcal{P} _ {n1} & ... & \\mathcal{P} _ {nn} \\\\ \\end{bmatrix} $n$为状态个数 每行元素相加为1 若状态是连续的，即无限个状态，适合用本节最上式的函数形式表示。 此时，$\\int_{s’}\\mathcal{P}(s’|s)=1$ 马尔可夫过程定义一个马尔可夫过程 (Markov process, MP) 是一个无记忆的随机过程，即一些马尔可夫状态的序列。 马尔可夫过程可由一个二元组来定义 $$ $S$：代表状态集合 $\\mathcal{P}$：代表状态转移矩阵 通常假设$\\mathcal{P}$是存在且稳定的当$\\mathcal{P}$不稳定时，采用在线学习、快速学习等方法 马尔可夫过程的例子 马尔可夫过程中的终止状态有2种： 时间终止 状态终止 片段（Episode）定义： 强化学习中，从初始状态 $S_1$ 到终止状态 $S_T$ 的序列过程。 S_1, S_2, ..., S_T 马尔可夫奖励过程定义在马尔可夫过程的基础上，在转移关系中赋予不同的奖励值，即得到马尔可夫奖励过程。 马尔可夫奖励 (Markov Reward Process, MRP) 过程由一个四元组组成 $⟨S, \\mathcal{P}, \\mathcal{R}, γ⟩$ S：状态集合 $\\mathcal{P}$：状态转移矩阵 $\\mathcal{R}$：奖励函数， $\\mathcal{R}(s)$ 描述了在状态 s 的奖励，$\\mathcal{R}(s) = E [\\mathcal{R}_{t+1}|S_t = s]$ $γ$：衰减因子 回报值 奖励值：对一个状态的评价 回报值：对一个片段的评价 回报值（return $G_t$）是从时间t处开始的累积衰减奖励 G_t = R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + ...MRPs中的值函数 为什么要值函数？回报值是一个片段的结果，存在很大的样本偏差回报值的角标是 t，值函数关注的是状态 s 一个 MRP 的值函数如下定义 v(s) = \\mathbb{E}[G_t|S_t = s]这里的值函数针对的是状态 s，所以称为状态值函数，又称 V 函数 MRPs中的贝尔曼方程（重点）\\begin{aligned}v(s)&=\\mathbb{E}[G_t|S_t=s] \\\\ &=\\mathbb{E}[ R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + .. S_t=s] \\\\ &=\\mathbb{E}[ R_{t+1} + \\gamma G_{t+1} | S_t=s ] \\\\ &=\\mathbb{E}[ R_{t+1} + \\gamma v(S_{t+1}) | S_t=s ]\\end{aligned}当前状态的值函数包括两部分： 第一项：瞬时奖励 $R_{t+1}$ 第二项：后继状态 $S_{t+1}$ 的值函数乘衰减系数 如果已知转移矩阵 $P$，那么 \\begin{aligned} v(s) &= \\mathbb{E} [R_{t+1} + γv(S_{t+1}) | S_t = s] \\\\ &= \\mathbb{E} [Rt+1jSt = s] + γ \\mathbb{E}[v(S_{t+1})|S_t = s] \\\\&= \\mathcal{R}(s) + γ ∑\\mathcal{P}_{ss^′}v(s^′)\\end{aligned}矩阵-向量形式为： v = \\mathcal{R} + \\gamma \\mathcal{P} v 本质上是一个线性方程，可以直接解： 直接求解只适用于小型MRPs： 计算复杂度$O(n^3)$ 要求已知 $\\mathcal{P}$ 马尔可夫决策过程在 MRP 中引入决策即得到了马尔可夫决策过程（Markov Decision Processes, MDPs） 定义一个马尔可夫决策过程 (MDPs) 由一个五元组构成 $⟨S, \\mathcal{A}, \\mathcal{P}, \\mathcal{R}, γ⟩$ $\\mathcal{A}$ ： 动作的集合 $\\mathcal{P}$ ： 状态转移矩阵， \\mathcal{P}_{ss^{'}}^{a} = \\mathbb{P}[ S_{t+1}=s' | S_t=s, A_{t}=a] $\\mathcal{R}(s,a)$：奖励函数， 表示在状态s做动作a的奖励。$\\mathcal{R}(s) = E [\\mathcal{R}_{t+1}|S_t = s]$ 策略在 MDPs 中，一个策略 (Policy)π 是在给定状态下的动作的概率分布 \\pi(a | s) = \\mathbb{P}[ A_t = a | S_t = s ] 策略是时间稳定的，只与s有关，与时间t无关 是RL问题的终极目标 如果分布是 one-hot 的，那么为确定性策略，否则为随机策略 MDPs与MRPs之间的关系如果MDP问题给定策略$\\pi$，则会退化成MRP问题。 MDPs中的值函数 状态值函数（V函数） 定义：从状态s开始，使用策略$\\pi$得到的期望回报值 v_{\\pi}(s) = \\mathbb{E}_\\pi[G_t|S_t = s] 状态动作值函数（Q函数） 定义：MDPs 中的状态动作值函数是从状态 s 开始，执行动作 a， 然后使用策略 π 得到的期望回报值 动作a不一定来自于策略 $\\pi$，实际上是做完动作 a之后，才遵循策略 $\\pi$ 进行动作选择 q_{\\pi}(s, a) = \\mathbb{E}_\\pi[ G_t | S_t = s, A_t = a ] 贝尔曼期望方程和 MRP 相似， MDPs 中的值函数也能分解成瞬时奖励和后继状态的值函数两部分 v_ \\pi(s)=\\mathbb{E}_ \\pi [ R_{t+1} + \\gamma v_ \\pi(S_{t+1}) | S_t=s ]q_ \\pi(s,a)=\\mathbb{E}_ \\pi [ R_{t+1} + \\gamma q_ \\pi(S_{t+1}, A_{t+1}) | S_t=s, A_t=a]","categories":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://monteyang.cn/categories/Reinforcement-Learning/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://monteyang.cn/tags/Reinforcement-Learning/"}]},{"title":"论文阅读-PointNet","slug":"论文阅读-PointNet","date":"2020-01-09T06:56:01.000Z","updated":"2020-02-12T08:59:25.720Z","comments":true,"path":"论文阅读-PointNet.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html","excerpt":"PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation 关键词: point cloud, deep learning 源码: √","text":"PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation 关键词: point cloud, deep learning 源码: √ Note1. Plroblem 直接对点云进行学习 =&gt; 实现分类/分割 针对点云的深度学习算法需满足的特性: 无序性: 所有点无次序 点与点之间的关系: 点与neighbor之间存在局部的结构关系 变换下的不变性: 旋转/平移等不改变点云模型的整体类别和局部分割类别 2. Method 提取点云的全局/局部特征 全局特征: 表示形状类别的特征 局部特征: 每个点的特征 T-Net: 将所有点对齐到一个规范空间中 用对称函数 MaxPooling: 解决点云的无序性 对于Segmentation: 局部特征 + 全局特征 (Aggregation) Network Structure 输入的点数为 n global feature 维度1024不是对应点数,而是模型整体的特征 3. Experiment3.1 Dataset 3D分类: ModelNet40 3D部件分割: ShapeNet的子集(16类) 3D场景分割: I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,M. Fischer, and S. Savarese. 3d semantic parsing of large-scale indoor spaces. 3.2 Implemention 数据预处理 在Mesh的表面均匀采样1024个点 3.3 Metric 3D 分类: accuracy 3D 分割: mIoU 4. Disadvantages未充分挖掘局部结构特征","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"论文阅读/笔记","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}]},{"title":"论文阅读-VoxNet","slug":"论文阅读-VoxNet","date":"2020-01-09T06:38:39.000Z","updated":"2020-02-12T08:59:25.720Z","comments":true,"path":"论文阅读-VoxNet.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html","excerpt":"VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition 关键词: voxel, 3D deep learning 会议: IROS 源码: official √ 我的复现: by PyTorch","text":"VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition 关键词: voxel, 3D deep learning 会议: IROS 源码: official √ 我的复现: by PyTorch Note1. Plroblem针对Voxel的3d物体识别/分类 2. Method将在视频领域取得一定效果的3D CNN用于Voxel的特征提取 Network Structure 3. Experiment3.1 Dataset3种数据集: LiDAR data - Sydney Urban Objects CAD data - ModelNet RGBD data - NYUv2 3.2 ImplementionTODO: 4. Advantages 表现性能超过了之前的 ShapeNet 参数比 ShapeNet 少一些 ShapeNet is a relatively large architecture, with over 12.4 million parameters, while VoxNet has less than 1 million. 5. Disadvantages 计算性能受Voxel的分辨率限制: 当Voxel分辨率过高时,内存占用过高","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"论文阅读/笔记","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"Voxel","slug":"Voxel","permalink":"http://monteyang.cn/tags/Voxel/"}]},{"title":"论文阅读-Ciss-Net","slug":"论文阅读-Ciss-Net","date":"2020-01-09T06:28:22.000Z","updated":"2020-02-12T08:59:25.720Z","comments":true,"path":"论文阅读-Ciss-Net.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html","excerpt":"Context-Reinforced Semantic Segmentation 关键词: reinforcement learning, image segmentation, context 会议: CVPR 2019 源码: √","text":"Context-Reinforced Semantic Segmentation 关键词: reinforcement learning, image segmentation, context 会议: CVPR 2019 源码: √ Note1. Plroblem Context(上下文信息)在语义分割中至关重要, 挖掘图像中上下文信息 2. Method 使用分割后的图片 p-maps 作为上下文信息的来源 该项工作提出Context-Net -&gt; 更好的挖掘上下文信息 将上下文信息的学习过程定义为马尔科夫决策问题(MDP), 使用强化学习方法进行优化 Network Structure Environment: p-map Agent: Context Net State: $\\{Y_I\\}$ Action: $\\{B_I\\}$ 3. Experiment3.1 Dataset ADE20K Cityscapes Pascal Context 3.2 ImplementionTODO 3.3 Metric3.4 Ablation Study3.5 Result","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"论文阅读/笔记","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://monteyang.cn/tags/Reinforcement-Learning/"},{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"image segmentation","slug":"image-segmentation","permalink":"http://monteyang.cn/tags/image-segmentation/"}]},{"title":"论文阅读-MeshNet","slug":"论文阅读-MeshNet","date":"2020-01-09T03:18:28.000Z","updated":"2020-02-12T11:19:25.664Z","comments":true,"path":"论文阅读-MeshNet.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html","excerpt":"MeshNet: Mesh Neural Network for 3D Shape Representation 关键词: Mesh, 3D shape classification/retrieval 会议: AAAI 2018 源码: √","text":"MeshNet: Mesh Neural Network for 3D Shape Representation 关键词: Mesh, 3D shape classification/retrieval 会议: AAAI 2018 源码: √ 相关文章 PoinNet KC-Net Related Work: Mesh Feature Extraction Deep Learning Methods for 3D Shape Representation voxel-based view-based point-based fusion method Note1. Problem 直接对 Mesh 进行形状表示的学习 应用于 3D shape classification/retrieval 2. Method 将一个face视作一个单元 face的特征分为: 空间特征 结构特征 针对空间特征和结构特征分别提出: Spatial Descriptor 面的中心点作为输入 采用与point cloud类似的处理方法 Structural Descriptor face rotate convolution face kernel correlation 整合空间特征和结构特征: 提出 Mesh Convolution Network Structure 3. Experiment3.1 DatasetModelNet40 for 3D classification/retrieval 40类别 3.2 Implemention Mesh模型需先简化至不多于1024个面(以面为单位,类似PointNet中以点为单位) 由于Mesh的面数不恒定, 随机选取填满1024个面 for batch training 数据增强: 所有点按高斯分布进行随机平移: N(0, 0.01) for Classification: global features 后添加 MLP(512, 256, 40): 40表示40个类别 MLP的最后两层添加dropout层: drop概率为0.5 for Retrieval: global features 直接计算 L2 距离 训练时的超参数: SGD optimizer initial learning rate 0.01 momentum 0.9 weight decay 0.0005 batch size 64. 3.3 Metric Classification: Accuracy Retrieval: mAP 3.4 Ablation StudyTODO: 3.5 Result&lt;!— ### 4. Advantages 将point的方法应用于Mesh的特征提取(空间提取, KC) 5. Disadvantages 空间特征提取 不仅考虑面的中心点, 可以加入中心点周围的三个点的信息, 可能会有所提升. 当前面和周围三个面可能会有相似的特征.可否进行替换 —&gt;","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"笔记","slug":"论文阅读/笔记","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"Mesh","slug":"Mesh","permalink":"http://monteyang.cn/tags/Mesh/"}]},{"title":"Paper Reading Plan","slug":"论文阅读计划","date":"2020-01-09T03:02:40.000Z","updated":"2020-02-12T09:05:18.336Z","comments":true,"path":"论文阅读计划.html","link":"","permalink":"http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html","excerpt":"","text":"Neural Network [x] AlexNet [x] VGGNet [x] ResNet [x] InceptionNet [ ] DenseNet [ ] SENet Mesh [x] MeshNet [ ] MeshCNN Voxel [ ] 3D ShapeNet [ ] VoxNet [ ] OctNet [ ] FPNN [ ] O-CNN Point Cloud [X] PointNet [x] PointNet++ [x] KC-Net [ ] PointSIFT [ ] Point-Voxel [ ] PointGrid SDF [ ] DeepSDF Reinfocement Learning [ ] DDPG [ ] MADDPG CNN-basic [x] Tricks-of-CNN Image Segmentation [ ] FCN [ ] U-Net [ ] SegNet [ ] DeepLab系列 [ ] Fully Convolutional DenseNet [ ] E-Net [ ] Link-Net [ ] Mask R-CNN [ ] PSPNet [ ] RefineNet [ ] HR-Net [ ] Ciss-Net","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"计划","slug":"论文阅读/计划","permalink":"http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"论文阅读","slug":"论文阅读","permalink":"http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"paper reading plan","slug":"paper-reading-plan","permalink":"http://monteyang.cn/tags/paper-reading-plan/"}]},{"title":"LeetCode-31-40题","slug":"LeetCode-31-40题","date":"2020-01-08T02:56:02.000Z","updated":"2020-02-18T08:44:38.544Z","comments":true,"path":"LeetCode-31-40题.html","link":"","permalink":"http://monteyang.cn/LeetCode-31-40%E9%A2%98.html","excerpt":"leetcode 31~40 题","text":"leetcode 31~40 题 31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 思路:字典序算法 从右往左, 找出第一个小于右邻的数 list[x]; 从右往左, 找出第一个比 list[x] 大的数 list[y]; 交换 list[x] 和 list[y]; 将 list[x] 后面的序列从小到大排序. 123456789101112131415161718192021222324class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" if len(nums) == 1: return # 1 x = -1 for i in range(len(nums)-2, -1, -1): if nums[i] &lt; nums[i+1]: x = i break # 如果不存在下一个更大的字典序(即当前序列为最大的字典序), 则将序列转为最小字典序 if x == -1: nums.sort() return # 2 for i in range(len(nums)-1, -1, -1): if nums[i] &gt; nums[x]: y = i break # 3, 4 nums[x], nums[y] = nums[y], nums[x] nums[x+1:] = sorted(nums[x+1:]) 32. 最长有效括号给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: &quot;(()&quot; 输出: 2 解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 输入: &quot;)()())&quot; 输出: 4 解释: 最长有效括号子串为 &quot;()()&quot; 思路: 用栈实现括号匹配 用数组保存一个有效括号的索引值 对所有索引值进行排序 找出连续索引长度中的最长长度 123456789101112131415161718192021222324252627282930313233343536class Solution: def longestValidParentheses(self, s: str) -&gt; int: # ()()()(()()()(())) # 特殊情况 if not s: return 0 stack = [] idxs = [] for i in range(len(s)): # 如果栈为空时 if stack == []: if s[i] == ')': continue else: stack.append(i) # 如果栈非空时 else: if s[i] == ')': idxs.append(i) idxs.append(stack.pop()) else: stack.append(i) idxs.sort() if not idxs: return 0 max_length = 0 length = 1 for j in range(0, len(idxs)-1): if idxs[j+1] - idxs[j] == 1: length += 1 else: if max_length &lt; length: max_length = length length = 1 return max(length, max_length) 33. 搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 12345678910111213141516171819202122232425262728293031323334class Solution: def search(self, nums: List[int], target: int) -&gt; int: # nums = [4,5,6,7,0,1,2] if not nums: return -1 # 找出最小值的索引 min_idx = self.search_min_idx(nums) if min_idx != 0: nums = nums[min_idx:] + nums[:min_idx] # 二分查找 tmp_idx = self.bin_search(nums, target) if tmp_idx == -1: return -1 return (tmp_idx + min_idx) % len(nums) def search_min_idx(self, nums): # TODO: return nums.index(min(nums)) def bin_search(self, nums, target): \"\"\" 二分查找法: - 如果nums中存在目标值, 则返回该值的index; - 如果nums中不存在目标值, 则返回 -1. \"\"\" low = 0 high = len(nums) - 1 while low &lt;= high: mid = (low + high) // 2 if target &lt; nums[mid]: high = mid - 1 elif target &gt; nums[mid]: low = mid + 1 else: return mid return -1 34. TODO 35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 思路 扫一次, 若当前值小于 target, 则跳过; 若当前值大于等于 target, 则返回当前索引 若所有元素都小于 target, 则返回(最大索引+1) 12345678class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: for i, num in enumerate(nums): if num &lt; target: continue else: return i return len(nums) 36. 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 输入: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: true 示例 2: 输入: [ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 思路 数独板块中共有 9行 \\ 9列 \\ 9个小块, 每行 \\ 每列 \\ 每个小块 都建立一个 hash map, 用来记录该行\\列\\小块中数字对应的个数 遍历所有 9*9 个元素: 一旦 hash map 中存在大于1个的元素, 则不满足数独条件, 返回 false; 如果遍历结束后, 都未出现 false, 则满足数独条件. 123456789101112131415161718192021222324252627class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: small_box = [[&#123;&#125; for _ in range(3)] for _ in range(3)] # 3*3个 small box row = [&#123;&#125; for _ in range(9)] # 9行 colum = copy.deepcopy(row) # 9列 for idx_row, r in enumerate(board): for idx_colum, num in enumerate(r): if num == '.': continue # 当前元素为 num, 判断该元素属于哪个small_box # 如果对应的small box中没有该数, 设置hash中的key的value为1 # 如果对应的small box已存在该数, 则返回错误 if num not in small_box[idx_row // 3][idx_colum // 3]: small_box[idx_row // 3][idx_colum // 3][num] = 1 else: return False # 判断该元素在当前row中是否存在 if num not in row[idx_row]: row[idx_row][num] = 1 else: return False # 判断该元素在当前列中是否存在 if num not in colum[idx_colum]: colum[idx_colum][num] = 1 else: return False return True 37. TODO 38. 外观数列「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下： 1 11 21 1211 111221 1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 注意：整数序列中的每一项将表示为一个字符串。 示例 1: 输入: 1 输出: &quot;1&quot; 解释：这是一个基本样例。 示例 2: 输入: 4 输出: &quot;1211&quot; 解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。 思路：迭代求解 1234567891011121314151617181920212223242526272829class Solution: def countAndSay(self, n: int) -&gt; str: if n == 1: return '1' s = '1*' while n &gt; 1: s = self.util(s) n -= 1 return s[:-1] def util(self, s): \"\"\" 输入s, 返回s的下一个外观数列, 注意s的最后一个字符是'*'. Args: s (string): 以 * 结尾的字符串 Returns: string: 下一个外观数列 \"\"\" res = '' cnt = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: cnt += 1 else: res += (str(cnt) + s[i - 1]) cnt = 1 s = res + '*' return s 39. 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ ⁠ [7], ⁠ [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 思路: 回溯法 + 利用树的数据结构判断 123456789101112131415161718192021222324252627import copyclass Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: res = [] # 先排序 candidates.sort() def util(candidates, cur_sum, tmp_list): if candidates == []: return # 如果当前列表之和等于 target, 加入res if cur_sum == target: res.append(tmp_list) # 如果当前列表元素之和大于 target，直接返回（剪枝） elif cur_sum &gt; target: return # 如果当前列表元素之和小于 target，继续添加元素 else: for i, c in enumerate(candidates): _tmp_list = copy.deepcopy(tmp_list) _tmp_list.append(c) util(candidates[i:], cur_sum+c, _tmp_list) util(candidates, 0, []) return res 40. 组合之和II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 思路:与上一题相似, 多增加去重步骤 123456789101112131415161718192021class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: res = [] candidates.sort() # [1,1,2,5,6,] def back_track(cur_sum, cur_list, candidates): if cur_sum == target: res.append(cur_list) elif cur_sum &gt; target: return else: for i, c in enumerate(candidates): # 去重 if i &gt; 0 and c == candidates[i-1]: continue _cur_list = cur_list[:] _cur_list.append(c) back_track(cur_sum+c, _cur_list, candidates[i+1:]) back_track(0, [], candidates) return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/tags/LeetCode/"}]},{"title":"2019年的总结","slug":"2019年的总结","date":"2020-01-04T15:15:35.000Z","updated":"2020-02-16T16:03:05.612Z","comments":true,"path":"2019年的总结.html","link":"","permalink":"http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html","excerpt":"","text":"校园 研究生生涯已经过半，终于把除了毕业论文之外的学分修满(.); 从19年4月开始和师兄进行科研，虽然最终实验效果没有想象中的理想，但过程中收获师兄的指导和编程经验难能宝贵； 记得18年，某位前辈说想搞编程一定要学好数据结构，今年终于在Coding和做Leetcode过程中，对数据结构有些理解； 开题过程还算顺利，有幸能做自己感兴趣的3D deeplearning相关的题目； 年底建了个博客，是因为记性太差了，想在上面记录些东西。 旅行 [X] 杭州 [X] 秦皇岛 [X] 大连 [X] 上海 [X] 南京 算下来也走了不少地方。身为一个东北人，印象最深的还是南方城市的人们都非常遵守交通规则，旅行这一路貌似没怎么听过鸣笛声，而且抢道超车的现象少一些… 感觉旅行就是换一个地方逛一逛、瞧一瞧、吃一吃，顺便假装体会下当地的风土人情。 希望家乡沈阳越来越好。 感情 在一起3年多了，自己的心态也成熟一些，最近发现情商高不等于会说好话哄对方开心，而是管理情绪的能力； 个人不太向往轰轰烈烈的感情，有个小窝能安逸生活即可； 虽然个人没有远大的追求，但也会尽力去满足对方对感情的期待； 渐渐发现家庭感的缺失，或许该适当地调整人生中的重要性排序。 其他 关于电影 今年几乎每周都去看一次电影，好片烂片的基本没什么感觉。。印象最深的还是《海贼王》，最动然的是乌索普的坚持。因为现在已经很明白，失败是一种平常，成功才是偶然。 关于书 惭愧，今年只看过一本书《暗时间》。对自己的影响实在太大，让我明白坚持做一件事的意义和如何更好的坚持； 之前买了很多技术类的书，后来发现根本没啥用，碰到问题都Google了。准备今年把这些书全卖了，如果真的需要，不如搞个PDF省心省力。 20202020，做个平凡快乐的人。","categories":[{"name":"总结与随感","slug":"总结与随感","permalink":"http://monteyang.cn/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9A%8F%E6%84%9F/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://monteyang.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"LeetCode-21-30题","slug":"LeetCode-21-30题","date":"2020-01-04T13:42:00.000Z","updated":"2020-02-18T08:44:31.312Z","comments":true,"path":"LeetCode-21-30题.html","link":"","permalink":"http://monteyang.cn/LeetCode-21-30%E9%A2%98.html","excerpt":"leetcode 21~30题","text":"leetcode 21~30题 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 123456789101112131415161718192021222324class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): p1 = l1 p2 = l2 head = ListNode(\"#\") cur = head while p1 or p2: if (p2 is None and p1) or (p1 and (p1.val &lt;= p2.val)): cur.next = ListNode(p1.val) cur = cur.next p1 = p1.next if (p1 is None and p2) or (p2 and (p2.val &lt; p1.val)): cur.next = ListNode(p2.val) cur = cur.next p2 = p2.next return head.next括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 思路:回溯法,利用递归生成括号. 12345678910111213141516171819202122232425262728293031323334class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: \"\"\" l0 r0 / \\ ( l1 r0 / \\ (( () l2 r0 l1 r1 ... \"\"\" res = [] def util(cur_str, n_lb, n_rb): # 超出括号数量则终止 if n_lb &gt; n or n_rb &gt; n: return # 左右括号数量均达到n,则添加到res if n_lb == n_rb == n: res.append(cur_str) # 左右括号数量相等时,当前string只能添加'(',剪枝? if n_lb == n_rb: util(cur_str+'(', n_lb+1, n_rb) # 左括号大于右括号时,当前string可以添加'('或')' if n_lb &gt; n_rb: util(cur_str+'(', n_lb+1, n_rb) util(cur_str+')', n_lb, n_rb+1) # 左括号小于右括号则返回 if n_lb &lt; n_rb: return util('', 0, 0) return res合并k个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路:先对所有链表结点中的value进行排序,然后根据排序后的value生成一个长链表. 12345678910111213141516171819202122class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: # 特殊情况: lists为空 if not lists: return None # 对所有val进行排序 val_all = [] for node in lists: while True: if node: val_all.append(node.val) node = node.next else: break val_all = sorted(val_all) # 生成整个链表 head = ListNode('#') node = head for v in val_all: node.next = ListNode(v) node = node.next return head.next两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 思路:两两交换结点:添加1个头和1个尾,以便交换中间的两个结点. 12345678910111213141516171819202122232425262728293031323334class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: \"\"\" p_head -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 (p) -&gt; q -&gt; r -&gt; s -&gt; (p) -&gt; q -&gt; r \"\"\" # 设置头结点,方便后续处理 p_head = ListNode('#') p_head.next = head # 如图设置p,q,r,s的指向 p = p_head q = p.next while q: r = q.next if not r: # 奇数个结点则跳出 break # 交换 s = r.next r.next = q q.next = s p.next = r # 移动指针p的指向 p = p.next.next q = p.next # 必须返回p_head.next, 不能返回head, 因为head已经在链表中被交换. return p_head.nextk-个一组翻转链表TODO 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 思路: 利用快慢指针: 利用排好序的性质: 类似栈,相等则弹出 1234567891011121314151617class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: p = - float(\"inf\") i = 0 while True: try: # 如果下一个数和当前指向的元素相等, 删除下一个数 if nums[i] == p: del nums[i] # 如果不等, 保留 else: p = nums[i] i += 1 except Exception: break length = len(nums) return length移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 思路:快慢指针 12345678910111213class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: j = 0 for i in range(len(nums)): # 如果第i个元素等于目标值val, 跳过 if nums[i] == val: continue # 如果第i个元素不等于目标值val, 从头依次添加到原list中 else: nums[j] = nums[i] j += 1 return j实现-str-str实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1 说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 123456789class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if needle == '': return 0 for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 TODO: KMP 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1: 输入: dividend = 10, divisor = 3 输出: 3 示例 2: 输入: dividend = 7, divisor = -3 输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 思路:倍增再相减,类似二分查找 12345678910111213141516171819202122232425262728class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: def util(dividend, divisor): \"\"\" 除数倍增(×2), 获取被除数与除数间最大的2次幂倍数 \"\"\" if dividend &lt; divisor: return 0 i = 1 while True: if dividend &gt; divisor*i*2: i *= 2 else: return i # 获取结果的符号 sign = -1 if (dividend &gt; 0) ^ (divisor &gt; 0) else 1 dividend = abs(dividend) divisor = abs(divisor) j = 0 while True: _j = util(dividend, divisor) j += _j dividend = dividend - _j*divisor if dividend &lt; divisor: if sign*j &gt; 2**31-1: return 2**31-1 if sign*j &lt; -2**31: return -2**31 return sign * j串联所有单词的子串给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1： 输入： s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;] 输出：[0,9] 解释： 从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。 输出的顺序不重要, [9,0] 也是有效答案。 示例 2： 输入： s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;] 输出：[] 思路: 1234567891011121314151617181920212223242526272829303132class Solution: def findSubstring(self, s: str, words: List[str]) -&gt; List[int]: res = [] if not words: return res len_sub_string = len(words[0]) # word字符串的长度 # 用一个hash表对应word和word的个数 hash_table = &#123;&#125; for w in words: if w in hash_table: hash_table[w] += 1 else: hash_table[w] = 1 i = 0 # 遍历所有元素的指针 while i &lt;= len(s) - len_sub_string*len(words) + 1: j = i # copy一个hash表作为临时 _hash_table = copy.deepcopy(hash_table) while True: # 在当前指针i处遍历,如果hash表为空,则添加i if not _hash_table: res.append(i) if s[j:j+len_sub_string] in _hash_table: if _hash_table[s[j:j+len_sub_string]] == 1: del _hash_table[s[j:j+len_sub_string]] else: _hash_table[s[j:j+len_sub_string]] -= 1 j = j + len_sub_string else: break i += 1 return res TODO: 时间复杂度","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/tags/LeetCode/"}]},{"title":"LeetCode-11-20题","slug":"LeetCode-11-20题","date":"2019-12-17T13:59:50.000Z","updated":"2020-02-18T08:44:22.268Z","comments":true,"path":"LeetCode-11-20题.html","link":"","permalink":"http://monteyang.cn/LeetCode-11-20%E9%A2%98.html","excerpt":"leetcode 11~20 题","text":"leetcode 11~20 题 11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 1234567891011121314151617181920212223242526272829303132333435class Solution: # 1. 暴力法 ''' def maxArea(self, height): max_area = 0 for i in range(len(height)): for j in range(i+1, len(height)): max_area = max(min(height[i], height[j]) * (j - i), max_area) return max_area ''' # 2. 双指针法 # - 一般来说,距离最远的围成较大面积的可能性较大 # - 两头各放一个指针 # - 较短一侧的指针往里移动, 才可能使面积变大(虽然两指针距离变短,但是较短一侧的高度可能变大) def maxArea(self, height): pt_left = 0 pt_right = len(height) - 1 max_area = 0 while True: # 新算的面积 = min(height[pt_left], height[pt_right])*(pt_right - pt_left) # 最大面积 = max(新算的面积, 原来的最大面积) max_area = max(min(height[pt_left], height[pt_right])*(pt_right - pt_left), max_area) # 选取较小一侧的指针,往内移动一个单位 if height[pt_left] &lt; height[pt_right]: pt_left += 1 else: pt_right -= 1 # 指针汇合时, 循环结束 if pt_left == pt_right: break return max_area 12. 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: “III” 示例 2: 输入: 4 输出: “IV” 示例 3: 输入: 9 输出: “IX” 示例 4: 输入: 58 输出: “LVIII” 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: “MCMXCIV” 解释: M = 1000, CM = 900, XC = 90, IV = 4. 1234567891011121314151617181920212223242526272829class Solution: def intToRoman(self, num: int) -&gt; str: lut = &#123; 1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M' &#125; res = \"\" # 将输入num除以lut的从大到小的key,进行取模. 模变成被除数继续迭代. for i in sorted(lut.keys())[::-1]: n, mod = divmod(num, i) if n == 0: continue else: res += lut[i] * n num = mod if num == 0: break return res 13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 123456789101112131415161718192021222324252627282930class Solution: def romanToInt(self, s: str) -&gt; int: lut = &#123;'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000&#125; res = 0 i = 0 # 先判断当前输入的前两个字符是否是罗马数字, # if 是: 加 # else: 将单个字符转化成数字, 加 while i &lt; len(s): if s[i:i+2] in &#123;'IV', 'IX', 'XL', 'XC', 'CD', 'CM'&#125;: res += lut[s[i:i+2]] i += 2 continue res += lut[s[i]] i += 1 return res14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: &quot;fl&quot;示例 2: 输入: [“dog”,”racecar”,”car”]输出: &quot;&quot;解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def longestCommonPrefix(self, strs): \"\"\"获得 list of string 的公共子串 Args: strs (list): a list of string Returns: str: 公共自创 \"\"\" if not strs: return \"\" commom = strs[0] for i in range(1, len(strs)): commom = self.getCommonPrefix(commom, strs[i]) if commom == \"\": return \"\" return commom def getCommonPrefix(self, str1, str2): \"\"\"返回str1和str2的公共子串 Args: str1 (string): 第一个字符串 str2 (string): 第二个字符串 Returns: string: 公共字符串 \"\"\" i = 0 while i &lt; min(len(str1), len(str2)): if str1[i] == str2[i]: i += 1 else: break return str1[:i]15. 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: def threeSum(self, nums): \"\"\" 返回一组数中之和为0的三个数(list of lists). 解法: 排序 + 使用双指针 Args: nums (list): a list of nums Returns: list: 每个元素都是3个数且3个数之和为0 \"\"\" # 如果不够3个元素, 则返回空 res = [] if len(nums) &lt; 3: return res nums = sorted(nums) # [-4, -1, -1, 0, 1, 2, ] # 确定第一个元素, 第一层遍历 for i in range(len(nums)): # 如果所有元素都大于等于0, 则返回 if nums[i] &gt; 0: return res # !!! 去重方法: 排好序后,相等则跳过... if i &gt; 0 and nums[i] == nums[i-1]: continue # 确定双指针, 一个最左(i+1), 一个最右[-1] pt_left = i + 1 pt_right = len(nums) - 1 # 如果 三数之和等于0, 添加至res列表, 左右指针都到下一个位置 # 如果 三数之和大于0, 右指针往左一个单位, 整体变小 # 如果 三数之和小于0, 左指针往右一个单位, 整体变大 while pt_left &lt; pt_right: if nums[i] + nums[pt_left] + nums[pt_right] == 0: res.append([nums[i], nums[pt_left], nums[pt_right]]) while nums[pt_left] == nums[pt_left+1] and pt_left &lt; pt_right-1: pt_left += 1 while nums[pt_right] == nums[pt_right-1] and pt_left &lt; pt_right-1: pt_right -= 1 pt_left += 1 pt_right -= 1 elif nums[i] + nums[pt_left] + nums[pt_right] &gt; 0: while nums[pt_right] == nums[pt_right-1] and pt_left &lt; pt_right-1: pt_right -= 1 pt_right -= 1 else: while nums[pt_left] == nums[pt_left+1] and pt_left &lt; pt_right-1: pt_left += 1 pt_left += 1 return res16. 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 123456789101112131415161718192021222324252627282930313233343536class Solution: def threeSumClosest(self, nums, target): if len(nums) &lt; 3: return False if len(nums) == 3: return sum(nums) nums = sorted(nums) min_dist = float('inf') for i in range(len(nums)): # 重复的则跳过 if i &gt; 0 and nums[i] == nums[i-1]: continue L = i + 1 R = len(nums) - 1 # 双指针 while L &lt; R: _sum = nums[i] + nums[L] + nums[R] delta = _sum - target # 如果两数之差小于最小值,保存该sum为res if abs(delta) &lt; min_dist: res = _sum min_dist = abs(delta) # 三数之和大于target, if delta &gt; 0: while L &lt; R and nums[R] == nums[R-1]: R -= 1 R -= 1 # 三数之和小于target elif delta &lt; 0: while L &lt; R and nums[L] == nums[L+1]: L += 1 L += 1 else: return _sum return res17. 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 1234567891011121314151617181920212223242526272829class Solution: def letterCombinations(self, digits): # digits = \"324\" if not digits: return [] hashmap = &#123;'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z']&#125; res = [\"\"] def util(res, digit): res_tmp = [] # 两个for循环进行排列组合 for s in hashmap[digit]: for r in res: r += s res_tmp.append(r) return res_tmp for i in digits: res = util(res, i) return res18. 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: def fourSum(self, nums, target): \"\"\" 在list of nums中,获取能够使得和为target的四元组. Args: nums (List[int]): 一组数. target (int): list of lists, int. Returns: List[List[int]]: 所有和为target的四元组. \"\"\" res = [] # 特殊情况, nums中少于4个数 if len(nums) &lt; 4: return res # 1. 排序 nums = sorted(nums) for i in range(len(nums)-3): # 避免重复 if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(i+1, len(nums)-2): # 避免重复 if j &gt; i+1 and nums[j] == nums[j-1]: continue # 双指针: L-左指针, R-右指针 L = j + 1 R = len(nums) - 1 # (左指针向右移,右指针向左移)当左指针超过右指针时,break. while L &lt; R: # 如果四数之和等于target,则添加 if nums[i] + nums[j] + nums[L] + nums[R] == target: res.append([nums[i], nums[j], nums[L], nums[R]]) # 避免重复 while nums[L] == nums[L+1] and L &lt; R-1: L += 1 L += 1 while nums[R] == nums[R-1] and L &lt; R-1: R -= 1 R -= 1 # 如果四数之和小于target,则左指针向右移动 elif nums[i] + nums[j] + nums[L] + nums[R] &lt; target: # 避免重复 while nums[L] == nums[L+1] and L &lt; R-1: L += 1 L += 1 # 如果四数之和大于target,则右指针向左移动 else: # 避免重复 while nums[R] == nums[R-1] and L &lt; R-1: R -= 1 R -= 1 return res19. 删除链表的倒数第n个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路:将所有结点放进一个数组中,直接将数组中倒数第n+1个结点的next指针指向倒数第n-1个结点. 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: def removeNthFromEnd(self, head, n): # 链表长度 arr = [] node = head while node: arr.append(node) node = node.next # 特殊情况 if n == len(arr) == 1: return None if n == len(arr): head = arr[1] return head node_to_del = arr[-n] arr[-n-1].next = node_to_del.next return head20. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true 思路:栈 12345678910111213141516171819class Solution: def isValid(self, s: str) -&gt; bool: stack = [] lut = &#123;'(': ')', '&#123;': '&#125;', '[': ']'&#125; for c in s: # 如果输入的是左侧符号,加入栈中 if c in lut: stack.append(c) continue # 如果输入的是右侧符号: # 如果栈中非空, 判断该符号是否与栈中最后一个符号匹配 if stack == [] and c in lut.values(): return False if len(stack) &gt; 0 and c == lut[stack[-1]]: stack.pop() else: return False return not bool(stack)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/tags/LeetCode/"}]},{"title":"LeetCode-1-10题","slug":"LeetCode-1-10题","date":"2019-12-17T13:47:05.000Z","updated":"2020-02-18T08:44:18.888Z","comments":true,"path":"LeetCode-1-10题.html","link":"","permalink":"http://monteyang.cn/LeetCode-1-10%E9%A2%98.html","excerpt":"leetcode 1~10 题 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]","text":"leetcode 1~10 题 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路:在哈希表中反向存储[元素数值-&gt;元素索引],遍历一次实现O(n). 12345678910111213141516171819202122232425class Solution: def twoSum(self, nums, target): # 哈希表,反过来存 num -&gt; idx, 有可能同一num对应多个idx, 所以 &#123;12: [idx1, idx2, ...]&#125; hashmap = &#123;&#125; for i, n in enumerate(nums): if n not in hashmap: hashmap[n] = [i] else: hashmap[n].append(i) for num_1, idx_1 in hashmap.items(): # num_2 = target - num_1 , 在hashmap中 if target - num_1 in hashmap: # num_1 与 num_2 数值相等时 if (target - num_1 == num_1): # [注意] 如果找到的 num_2 其实是 num_1 自己, 跳过... if (len(hashmap[num_1]) == 1): continue # num_2 与 num_1 不同 if len(hashmap[target-num_1]) &gt;= 2: return hashmap[target-num_1][0], hashmap[target-num_1][1] # num_2 与 num_1 不同 else: return idx_1[0], hashmap[target-num_1][0] return False 2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 思路:每一个位相加时,都要考虑进位. 1234567891011121314151617181920212223class Solution: def addTwoNumbers(self, l1, l2): HeadNode = ListNode(0) cur = HeadNode carry = 0 # 遍历2个链表的同时进行计算,存入result链表 while l1 or l2: x = l1.val if l1 else 0 y = l2.val if l2 else 0 sum_cur = x + y + carry carry = 0 if sum_cur &gt;= 10: carry = 1 sum_cur %= 10 cur.next = ListNode(sum_cur) l1 = l1.next if l1 and l1.next else None l2 = l2.next if l2 and l2.next else None cur = cur.next # l1,l2都遍历完, 但是最后有进位时 if carry: cur.next = ListNode(carry) return HeadNode.next3. 无重复字符的最长子串Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3. Example 2: Input: “bbbbb” Output: 1 Explanation: The answer is “b”, with the length of 1. Example 3: Input: “pwwkew” Output: 3 Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 思路:滑动窗口法:判断新的元素是否存在于已有的窗口内部. 1234567891011121314class Solution: def lengthOfLongestSubstring(self, s): window = [] cur_length = 0 max_length = 0 for i in range(len(s)): if s[i] in window: window = window[window.index(s[i])+1:] window.append(s[i]) cur_length = len(window) if cur_length &gt; max_length: max_length = cur_length return max_length 4. 寻找两个有序数组的中位数There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 1234567891011121314151617181920212223242526272829303132333435# O(m+n)# TODO O(log(m+n))class Solution: def findMedianSortedArrays(self, nums1, nums2): nums = [] length = len(nums1) + len(nums2) p1, p2 = 0, 0 if length == 1: return (nums1+nums2)[0] m_idx = int(length/2)+1 for _ in range(m_idx): if p2 &gt; len(nums2)-1: nums.append(nums1[p1]) p1 += 1 continue if p1 &gt; len(nums1)-1: nums.append(nums2[p2]) p2 += 1 continue if nums1[p1] &lt; nums2[p2]: nums.append(nums1[p1]) p1 = p1 + 1 else: nums.append(nums2[p2]) p2 = p2 + 1 if length % 2 == 0: median = (nums[-1] + nums[-2])/2 else: median = nums[-1] return median 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad” 输出: “bab” 注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd” 输出: “bb” 思路:在每个索引处,从中心展开,获取最长的回文串. 12345678910111213141516171819202122232425262728293031323334class Solution: def longestPalindrome(self, s): s = \" \".join(s) longest_pali = \"\" for cent_idx in range(len(s)): pali = self.get_longest_pali(s, cent_idx) if len(pali) &gt; len(longest_pali): longest_pali = pali return longest_pali def get_longest_pali(self, s, cent_idx): \"\"\"返回字符串s中以索引cent_idx为中心的最长回文子串\"\"\" pali = s[cent_idx] i = 1 while True: left_idx = cent_idx - i right_idx = cent_idx + i # 超出范围,跳出 if left_idx &lt; 0 or right_idx &gt;= len(s): break if s[left_idx] == s[right_idx]: pali = s[left_idx] + pali + s[right_idx] else: break i += 1 pali = pali.replace(\" \", \"\") return pali 6. z-字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = “LEETCODEISHIRING”, numRows = 3 输出: “LCIRETOESIIGEDHN” 示例 2: 输入: s = “LEETCODEISHIRING”, numRows = 4 输出: “LDREOEIIECIHNTSG” 解释: L D R E O E I I E C I H N T S G 思路:用一个 List[string], 第n个元素存储第n行的字符. 12345678910111213141516171819202122class Solution: def convert(self, s, numRows): if numRows &lt; 2: return s res = [\"\" for _ in range(numRows)] i = 0 # 遍历字符串 # res[0]: Z的第一行 # res[1]: Z的第二行 # ... for c in s: res[i] += c if i == 0: order_flag = True if i == numRows - 1: order_flag = False if order_flag: i += 1 else: i -= 1 res_str = \"\" for r in res: res_str += r return res_str7. 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 12345678910111213141516class Solution: def reverse(self, x): res = 0 x_orig = x x = abs(x) while True: temp = x % 10 x = (x - temp)/10 res = res*10 + temp if x == 0: break if x_orig &lt; 0: res = -res if res &lt; -2**31 or res &gt; 2**31-1: return 0 return int(res) 8. 字符串转换整数请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42” 输出: 42 示例 2: 输入: “ -42” 输出: -42 解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: “4193 with words” 输出: 4193 解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 示例 4: 输入: “words and 987” 输出: 0 解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: “-91283472332” 输出: -2147483648 解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def myAtoi(self, str): flag_find_first = True sign = 1 res = 0 for c in str: asc = ord(c) # 找第一个符号, if flag_find_first: # 空字符, 跳过 if asc == 32: continue # 负号, 已找到第一个符号 elif asc == 45: sign = -1 flag_find_first = False continue # 正号, 已找到第一个符号 elif asc == 43: sign = 1 flag_find_first = False continue # 数字字符 elif 48 &lt;= asc and asc &lt;= 57: flag_find_first = False res = asc-48 continue # 非上述字符 else: break # 已有第一个符号(正号或符号或数字)的前提下, 接下来只能是数字符号, 如果不是则break else: if 48 &lt;= asc and asc &lt;= 57: res = int(res*10 + (asc-48)) if sign == 1 and res &gt; (2**31 - 1): res = 2**31 - 1 break if sign == -1 and res &gt; 2**31: res = 2**31 break else: break return sign * res9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 123456789101112class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0: return False else: s = str(x) for i in range(len(s)//2): if s[i] == s[-i-1]: continue else: return False return True 10. 正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 . 和 * 的正则表达式匹配。 . 匹配任意单个字符 * 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 输入: s = “aa”, p = “a” 输出: false 解释: “a” 无法匹配 “aa” 整个字符串。 示例 2: 输入: s = “aa”, p = “a“ 输出: true 解释: 因为 `` 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。 示例 3: 输入: s = “ab”, p = “.“ 输出: true 解释: `.表示可匹配零个或多个（*）任意字符（.`）。 示例 4: 输入: s = “aab”, p = “c*a*b” 输出: true 解释: 因为 * 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。 示例 5: 输入: s = “mississippi”, p = “mis*is*p*.” 输出: false 12345678910class Solution: def isMatch(self, s, p): # 递归基: 都为空 if not p: return not s # 第一个字符相互匹配 first_match = bool(s) and p[0] in &#123;s[0], '.'&#125; # 若之后存在* 212 1* if len(p) &gt; 1 and p[1] == '*': return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p)) return first_match and self.isMatch(s[1:], p[1:])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://monteyang.cn/tags/LeetCode/"}]},{"title":"Python-可迭代对象、迭代器、生成器","slug":"Python-Iterable和Iterator的区分","date":"2019-12-16T13:43:51.000Z","updated":"2020-02-18T08:42:23.996Z","comments":true,"path":"Python-Iterable和Iterator的区分.html","link":"","permalink":"http://monteyang.cn/Python-Iterable%E5%92%8CIterator%E7%9A%84%E5%8C%BA%E5%88%86.html","excerpt":"","text":"可迭代 Iterable可以用 for 循环遍历的，或者说该类中有__iter__()方法的实现，都是可迭代的对象。包括： 集合数据类型，如 list、tuple、dict、set、str等 生成器 generator，包括“( i for i in range(10) )”这种的生成器和带yield的 generator function 迭代器 Iterator可以被 next() 函数调用并不断返回下一个值的对象称为迭代器，该类中有__next__()方法的实现，包括： 减少内存空间 生成器 generator 但list、dict、str虽然是Iterable，却不是Iterator 可以使用iter()函数，把list、dict、str等Iterable变成Iterator 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 生成器 Generator是迭代器的一种，函数中有 yield，可以让函数暂停执行。 生成器对象中的 send() 方法，可将参数传递给生成器中yield的返回值，继续进行迭代。 12345678910def fib(num): a, b = 0, 1 current = 0 while current &lt; num: ret = yield a current += 1obj = fib(10)ret = obj.send(\"ok\")","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"Python-Matplotlib总结","slug":"Python-Matplotlib总结","date":"2019-12-16T09:28:00.000Z","updated":"2020-02-18T09:15:59.524Z","comments":true,"path":"Python-Matplotlib总结.html","link":"","permalink":"http://monteyang.cn/Python-Matplotlib%E6%80%BB%E7%BB%93.html","excerpt":"matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。","text":"matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。 1. 绘制图片1.1 设置图片大小、分辨率123456789101112# 常用的导入方式import matplotlib.pyplot as plt# 设置图片大小, dpi是图片分辨率默认是100fig = plt.figure(figsize=(20, 8), dpi=80)x = np.arange(2, 26, 2)y = np.random.randn(12)plt.plot(x, y)plt.xticks(x)# 调整x轴上的刻度，当刻度太密集时使用列表的步长（列表间隔）来解决，matplotlib会自动帮我们对应# plt.xticks(x[::2])plt.show() 1.2 调整轴上的刻度123x_ticks = [\"第&#123;&#125;个\".format(i) for i in x]plt.xticks(x, x_ticks, rotation=90)plt.show() plt.xticks() 中的两组数据长度务必相同 1.3 设置中文显示matplotlib默认不支持中文，通过matplotlib.rc可以修改12345import matplotlibfrom matplotlib import font_managerfront = &#123;\"family\": \"Microsoft Yahei\", \"size\": \"10\"&#125;matplotlib.rc(\"front\", **font) 1.4 添加描述信息可添加坐标轴含义，图像标题等。123plt.xlabel(\"x轴含义\")plt.ylabel(\"y轴含义\")plt.title(\"标题\") 1.5 保存图片1plt.savefig(\"./fig.png\") 2. 常用统计图2.1 折线图 以折线表示统计量的增减变化。特点：反映事物的变化情况。 2.2 直方图 由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据范围，纵轴表示分布情况。特点：绘制 连续 的数据，展示一组或者多组数据的分布状况。 2.3 条形图 排列在工作表的列或行中的数据可以绘制到条形图中。特点：绘制 离散 的数据，能够看出各个标签对应的数据大小，比较数据之间的差别。 2.4 散点图 用两组数据构成多个坐标点，考察坐标点的分布,判断两变量 之间是否存在某种关联或总结坐标点的分布模式。特点：判断变量之间是否存在数量关联趋势，显示数据的分布规律。12345678# 绘制折线图，x为横坐标，y为纵坐标。plt.plot(x, y)# 绘制直方图，x为需要被分组的量，bins为组数。plt.hist(x, bins)# 绘制条形图，x为序列，height为序列的“高度”。plt.bar(x, height)# 绘制散点图，(x,y)为点的坐标。plt.scatter(x, y)","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"Reinforcement Learning-基本概念","slug":"Reinforcement-Learning-基本概念","date":"2019-12-16T02:08:42.000Z","updated":"2020-02-18T09:08:15.620Z","comments":true,"path":"Reinforcement-Learning-基本概念.html","link":"","permalink":"http://monteyang.cn/Reinforcement-Learning-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html","excerpt":"","text":"1. 概述强化学习是智能体（Agent）与环境（Environment）不断交互, 不断提高自己的决策能力的过程. 面向智能体的学习——通过与环境进行交互 所学习的样本来自于与环境的交互。而非像传统机器学习的样本是现有的。 通过试错和优化进行学习——用试错后的奖励（或惩罚）来学习 总体过程：环境（Environment）会给智能体（Agent）一个观测值（Observation）（全观测时,状态state和observation等价）, 智能体接收到环境给的观测值之后会做出一个动作（Action）, 这个动作给予一个奖励（Reward）, 以及给出一个新的观测值. 智能体根据环境给予的奖励值去更新自己的策略（Policy）. 强化学习的目的 就是为了得到最优的策略。 2. 强化学习的组成整体结构：环境和智能体 每个时刻 $t$: 智能体（Agent） 智能体执行动作$A_t$，并在环境中得到观测 $O_t$和奖励 $R_t$ 环境（Environment） 环境会对智能体的动作 $A_t$的做出反应，然后发送新的观测 $O_t+1$ 和奖励 $R_t+1$ 智能体是我们能控制的部分，环境是我们无法空指的部分。在不同的问题中，智能体和环境所指代的对象不同。 2.1 奖励 Reward奖励$R_t$是强化学习的核心，强化学习的目标就是最大化期望累积奖励 特点 是标量，能够比较大小 表明这个智能体在时刻 $t$ 做得有多好 奖励不一定需要正负都有，全正或全负都可以，只要满足相对大小即可 如果一个问题不满足奖励假设，就不能用强化学习解决！ 奖励值和回报值（Return）的比较 回报值 $G_t$ 又称累积折扣奖励（cumulative discounted reward）。step $t$ 时的 return 为 G_t = R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + ... 其中$\\gamma$表示折扣因子，公式中重视每一步reward的程度随着时间衰减，是一个可调的超参数。 $\\gamma$ 越大，表示我们越关注长期奖励 $\\gamma$ 越小，表示我们越关注短期奖励 智能体的任务就是去最大化累积奖励，即最大化整个过程的奖励. 因此，智能体的任务可以转化成最大化累积奖励的期望。 2.2 状态 State历史（history） 历史 是一个观测、动作和奖励的序列。是智能体在时间 $t$ 以前的所有的交互变量。 H_t = (O_1, A_1, R_2, ..., O_{T-1}, A_{T-1}, R_T, O_T)根据历史： 智能体选择动作 $A_t$ 环境产生新的观测 $O_{t+1}$ 和奖励 $R_{t+1}$ 本质上，状态是历史的一个函数： S_t = f(H_t) 状态可以是全部历史或者部分历史 下棋时，棋盘当前的布局可以看做状态 $S_t = O_t$ 打砖块游戏中，前几帧的观测可以看做状态 $S_{t} = O_{t-3}, O_{t-2}, O_{t-1}, O_t$ 环境状态 $S^e_t$ 所有能够影响环境产生观测/奖励的数据都被认为是环境状态的一部分 环境状态一般是智能体观察不到的 即使环境状态 $S^e_t$ 可见的，一般也包含了不相关的信息 智能体状态 $S^a_t$ 所有能够影响智能体做出下一个动作的数据都被认为是智能体状态的一部分 强化学习中使用的状态 可能是历史的任何函数 $S_t = f(H_t)$ 对于智能体来说，环境状态是未知的，智能体状态是已知的智能体通过智能体的状态来做出相应的动作没有特殊说明的情况下，我们所说的状态均指智能体状态 $S_t = S^a_t$ 全观测和部分观测 全观测： 智能体能够观测到整个环境，即智能体状态等价于环境状态 强化学习主要研究问题——马尔科夫决策过程 部分观测： 智能体不能完全观测到整个环境 建模为部分观测下的马尔科夫决策过程 2.3 动作 Action 动作是智能体与环境交互的媒介 动作必须对环境起到一定的控制作用 动作必须和奖励匹配 3. 智能体的组成智能体的组成主要包括： 策略 值函数 模型 3.1 策略 Policy($\\pi$)Policy是从状态到动作的映射, 用$\\pi$表示, 它告诉智能体如何挑选下一步的action. 强化学习中有两类policy: Deterministic policy(确定性策略) 在确定性策略中，输入一个状态，输出的是某一个确定的action. Stochastic policy(随机性策略) 在随机性策略中，输入一个状态，输出的是每个action的概率分布. 3.2 值函数 值函数是回报值的期望 值函数主要用于评价不同状态的好坏，指导动作的选择 3.3 模型指智能体对环境的预测模型，分为两部分 $\\mathcal{P}$ 预测下一个状态是什么 $\\mathcal{R}$ 预测下一个奖励是什么 4. 强化学习的分类 按环境： 全观测环境下的 部分观测环境下的 按智能体成分： 基于值函数：学习值函数 基于策略：学习策略 Actor Critic：同时学习值函数和策略 按有无模型： 无模型强化学习 基于模型的强化学习 按使用的手段： 传统强化学习 深度强化学习 5. 学习（learning）和规划（planning）解决序列决策问题有两个基本方法： 强化学习 环境未知 智能体与环境进行交互，不断改善策略 规划 环境已知 可以根据模型直接计算，不用交互 环境模型不精确时，既利用环境进行规划，又与环境交互进行强化学习 —&gt; 基于模型的强化学习当环境模型很精确时，可以直接用规划的方式求解 6. 探索（Exploration）和利用（Exploitation） 探索：发现环境中更多的信息； 利用：充分挖掘当前已知信息，来最大化回报值； 两者trade-off，同等重要。 7. 评价和优化 评价：给定一个策略，评价该策略的好坏 —&gt; 求值函数 优化：改善策略 —&gt; 找到最优策略","categories":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://monteyang.cn/categories/Reinforcement-Learning/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://monteyang.cn/tags/Reinforcement-Learning/"}]},{"title":"Python-axis的理解","slug":"Python-axis的理解","date":"2019-01-15T03:40:13.000Z","updated":"2020-02-18T09:15:52.652Z","comments":true,"path":"Python-axis的理解.html","link":"","permalink":"http://monteyang.cn/Python-axis%E7%9A%84%E7%90%86%E8%A7%A3.html","excerpt":"axis的本质是数组层级numpy中的ndarray本质上是一个多维数组，axis表示数组层级123456789arr = np.array(np.arange(12).reshape(3,4))print(arr)\"\"\"array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])\"\"\"print(arr.shape) # (3, 4) axis=0，表示最外层的[]，相应的arr.shape[0]为 3，最外层数组有3个元素； axis=1，表示次外层的[]，相应的arr.shape[1]为 4，这就表示，在最外层的3个数组元素中，每个数组元素中又有4个元素。","text":"axis的本质是数组层级numpy中的ndarray本质上是一个多维数组，axis表示数组层级123456789arr = np.array(np.arange(12).reshape(3,4))print(arr)\"\"\"array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])\"\"\"print(arr.shape) # (3, 4) axis=0，表示最外层的[]，相应的arr.shape[0]为 3，最外层数组有3个元素； axis=1，表示次外层的[]，相应的arr.shape[1]为 4，这就表示，在最外层的3个数组元素中，每个数组元素中又有4个元素。 若函数中axis=i，则沿着第i个下标变化、其余下标都不变的方向进行操作以元素下标的形式表示数组arr为： arr[0][0]\\ arr[0][1]\\ arr[0][2]\\ arr[0][3]\\\\ arr[1][0]\\ arr[1][1]\\ arr[1][2]\\ arr[1][3]\\\\ arr[2][0]\\ arr[2][1]\\ arr[2][2]\\ arr[2][3]\\\\1234567891011\"\"\"print(arr)array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])\"\"\"In [16]: arr.sum(axis=0) # 表示沿着第0个索引变化，其它索引都不变的方向进行求和操作Out[16]: array([12, 15, 18, 21])# 相应的，在多维数组（dim=3,4,...)的情况中，也是如此 由以上结论，我们可以得到二维数组中axis含义的巧记方法： 二维数组中的巧记方法（沿方向操作） axis=0，第一个索引变变化，第二个索引不变，即沿纵向操作； axis=1，第二个索引变变化，第一个索引不变，即沿横向操作。","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"Python-numpy和list中的浅拷贝和深拷贝","slug":"Python-numpy和list中的浅拷贝和深拷贝","date":"2019-01-13T16:58:37.000Z","updated":"2020-02-18T09:15:47.188Z","comments":true,"path":"Python-numpy和list中的浅拷贝和深拷贝.html","link":"","permalink":"http://monteyang.cn/Python-numpy%E5%92%8Clist%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.html","excerpt":"numpy 中 np.copy() 方法是 深拷贝； 切片操作 是 浅拷贝； 直接赋值给另一个变量是 浅拷贝。","text":"numpy 中 np.copy() 方法是 深拷贝； 切片操作 是 浅拷贝； 直接赋值给另一个变量是 浅拷贝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# numpy深拷贝示例In [12]: arr = np.zeros((3,3))In [13]: arrOut[13]: array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])In [14]: b = arr.copy()In [17]: b[0,0] = 1 # 更改b的值In [18]: arr # arr不变，说明copy()方法是深拷贝Out[18]: array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])In [19]: bOut[19]: array([[ 1., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])# numpy浅拷贝示例In [33]: b = arr # 直接赋值给变量bIn [34]: bOut[34]: array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])In [35]: arr[0,0] = 1In [36]: bOut[36]: array([[ 1., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])In [38]: b = arr[:] # 切片操作In [39]: bOut[39]: array([[ 1., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])In [40]: arr[0,2] = 1In [41]: bOut[41]: array([[ 1., 0., 1.], [ 0., 0., 0.], [ 0., 0., 0.]]) 对比：Python的list中 切片操作 是 深拷贝 直接复制给另一个变量是 浅拷贝12345678910111213141516171819# list 深拷贝示例In [7]: a = [1,2]In [8]: b = a[:]In [9]: b[0] = 0 # 更改b的值In [10]: a # a不变，说明列表中的切片操作是深拷贝Out[10]: [1, 2]# list 浅拷贝示例In [29]: a = [1,2]In [30]: b = aIn [31]: a[0] = 0In [32]: bOut[32]: [0, 2]","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"Python - __slot__方法","slug":"Python-slot-方法","date":"2019-01-12T13:45:38.000Z","updated":"2020-02-18T09:18:40.372Z","comments":true,"path":"Python-slot-方法.html","link":"","permalink":"http://monteyang.cn/Python-slot-%E6%96%B9%E6%B3%95.html","excerpt":"","text":"Python中默认用一个字典来保存一个对象的实例属性，使得我们在运行时可以任意设置新属性。 但是，对于已知固有属性的小型类来说，这个字典浪费了很多内存。（由于可设置新属性，Python不能在对象创建时直接分配一个固定量的内存保存所有属性） 因此，如果创建成千上万个这样的小类，Python就会浪费掉很多内存。 此时，引入类中的__slots__方法，使得python： 给类指定一个固定大小的空间存放属性 无法给该类创建的实例添加新的属性 例子： 不使用__slots__ 12345class Point_1(object): def __init__(self, x=0, y=0): self.x = x self.y = y # ... 使用__slots__ 123456class Point_2(object): __slots__ = ['x', 'y'] def __init__(self, x=0, y=0): self.x = x self.y = y # ... 12345678910111213# 创建 Point_1 类的实例 p1In [10]: p1 = Point_1() # 可以给 p1 添加新的属性 zIn [11]: p1.z = 0# 创建 Point_2 类的实例 p2In [12]: p2 = Point_2()# 无法给 p2 添加新的属性In [13]: p2.z---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-19-b152092c7c5d&gt; in &lt;module&gt;()----&gt; 1 p2.z","categories":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://monteyang.cn/tags/Python/"}]},{"title":"矩阵论笔记-1.补:维数公式","slug":"矩阵论笔记-1-补-维数公式","date":"2019-01-04T09:31:55.000Z","updated":"2020-02-16T16:08:52.428Z","comments":true,"path":"矩阵论笔记-1-补-维数公式.html","link":"","permalink":"http://monteyang.cn/%E7%9F%A9%E9%98%B5%E8%AE%BA%E7%AC%94%E8%AE%B0-1-%E8%A1%A5-%E7%BB%B4%E6%95%B0%E5%85%AC%E5%BC%8F.html","excerpt":"","text":"维数公式dim(V+U) = dimV + dimU-dim(V\\cap U)即，和空间的维数等于两空间维数之和减去两空间的交空间的维数。 例子：三维空间中，记$V$为 $xOy$平面， $U$ 为 $yOz$平面 ，即 $dimV = dimU = 2$ 。它们的和空间是三维空间，即 $dim(V+U) = 3$ 。它们的交空间是y轴，即 $dim(V \\cap U)=1$。满足维数公式。","categories":[{"name":"矩阵论","slug":"矩阵论","permalink":"http://monteyang.cn/categories/%E7%9F%A9%E9%98%B5%E8%AE%BA/"}],"tags":[{"name":"矩阵论","slug":"矩阵论","permalink":"http://monteyang.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"}]},{"title":"矩阵论笔记-1.线性空间、线性子空间、矩阵的值域和核空间","slug":"矩阵论笔记-1-线性空间、线性子空间、矩阵的值域和核空间","date":"2019-01-04T09:30:04.000Z","updated":"2020-02-16T16:07:56.260Z","comments":true,"path":"矩阵论笔记-1-线性空间、线性子空间、矩阵的值域和核空间.html","link":"","permalink":"http://monteyang.cn/%E7%9F%A9%E9%98%B5%E8%AE%BA%E7%AC%94%E8%AE%B0-1-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E3%80%81%E7%BA%BF%E6%80%A7%E5%AD%90%E7%A9%BA%E9%97%B4%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E5%80%BC%E5%9F%9F%E5%92%8C%E6%A0%B8%E7%A9%BA%E9%97%B4.html","excerpt":"本文记录于2019年1月 1.线性空间1.1 线性空间的定义设非空集合$V$，一个数域$K$，$x,y,z \\in V$， $k,l\\in K$，如果$V$满足加法封闭和数乘封闭，则称$V$为线性空间。 加法封闭： 加法交换律、加法结合律、零向量、负向量。 数乘封闭： 数对元素的分配律、元素对数的分配律、数因子结合律、单位向量。","text":"本文记录于2019年1月 1.线性空间1.1 线性空间的定义设非空集合$V$，一个数域$K$，$x,y,z \\in V$， $k,l\\in K$，如果$V$满足加法封闭和数乘封闭，则称$V$为线性空间。 加法封闭： 加法交换律、加法结合律、零向量、负向量。 数乘封闭： 数对元素的分配律、元素对数的分配律、数因子结合律、单位向量。 1.2 线性空间的性质 零元素唯一 任一元素的负元素唯一 设 数$k,0,1\\in K$，向量$x, 0, -x \\in V$，有： $0x=0$ $(-1)x=-x$ $k0=0$ 若 $kx=0$, 则 $k=0$ 或 $x=0$ 1.3 线性空间的维数线性空间$V$中线性无关向量组所含向量最大个数$n$，称为$V$的维数，记作 $dimV = n$。 $n$ 维线性空间记作$V^n$。 1.4 线性空间的基$n$维线性空间中，任意$n$个线性无关的向量 $x_1,x_2,…,x_n$，构成该空间的一组基。这n个线性无关的向量称作基向量。 空间中任意一个向量 $x$ 可由这组基唯一表示，即 $x=a_1x_1+a_2x_2+…+a_nx_n$ 。此时，称 $a_1, a_2, …, a_n$ 为 $x$ 在该基下的坐标，记为$[a_1, a_2, …, a_n]^T$。 向量$x$在基 $x_1,x_2,…,x_n$ 下的矩阵表示为： x=\\begin{bmatrix} x_1 & x_2 & ... & x_n \\end{bmatrix} \\cdot \\begin{bmatrix} a_1\\\\ a_2\\\\ ...\\\\ a_n \\end{bmatrix} 1.5 基变换与坐标变换1.5.1 基变换：设 $x_1,x_2,…,x_n$ 是 空间$V^n$ 的旧基，$y_1,y_2,…,y_n$ 是新基。新基可以用旧基表示为 \\begin{bmatrix} y_1 & y_2 & ... & y_n \\end{bmatrix} = \\begin{bmatrix} x_1 & x_2 & ... & x_nliangge \\end{bmatrix} \\cdot C_{n×n}其中，矩阵$C_{n×n}$为 (旧基到新基的) 过渡矩阵。 1.5.2 坐标变换：向量$x$在旧基 $x_1,x_2,…,x_n$下的矩阵表示： x=\\begin{bmatrix} x_1 & x_2 & ... & x_n \\end{bmatrix} \\cdot \\begin{bmatrix} a_1\\\\ a_2\\\\ ...\\\\ a_n \\end{bmatrix} \\tag{1}其中 ，$[a_1, a_2, …, a_n]^T$为 $x$ 在基 $x_1,x_2,…,x_n$下的坐标。 向量$x$在新基$y_1,y_2,…,y_n$下的矩阵表示： x=\\begin{bmatrix} y_1 & y_2 & ... & y_n \\end{bmatrix} \\cdot \\begin{bmatrix} b_1\\\\ b_2\\\\ ...\\\\ b_n \\end{bmatrix} \\tag{2}其中 ，$[b_1, b_2, …, b_n]^T$为 $x$ 在基 $y_1,y_2,…,y_n$下的坐标。由式(1)=式(2)，得 \\begin{bmatrix} b_1\\\\ b_2\\\\ ...\\\\ b_n \\end{bmatrix}=C^{-1} \\cdot \\begin{bmatrix} a_1\\\\ a_2\\\\ ...\\\\ a_n \\end{bmatrix}称作 向量$x$在基变换C下的坐标变换公式。 个人理解： 对线性空间作变换，也就是对线性空间的基做变换。（这是因为，线性空间中的任一向量都能由该空间的一组基线性表示，即一组基可决定一个空间。但是，一个空间可对应不同的多组基） 线性空间中的一个向量本身是不变的，但对基作变换后，基改变，从而基下的坐标改变，称为坐标变换，即，同一向量在不同基下的表示是不同的。 2. 线性子空间2.1 定义$V_1$是线性空间$V$的非空子集和，$V_1$中满足数乘封闭和加法封闭，则称$V_1$是$V$的线性子空间或子空间。 个人理解：三维空间中的一个过原点的二维平面，或一条过原点的直线，都是该三维空间中的线性子空间。这两个子空间也满足数乘封闭和加法封闭。 2.2 性质 线性子空间也是线性空间。（定义中满足数乘、加法封闭，即线性子空间首先要是线性的） 非零线性空间的平凡子空间：线性空间自身以及零空间he。 一个线性空间的子空间，其维数小于等于线性空间的维数（显然）。 延伸：n元齐次线性方程组的解空间 $W$ 是 $n$维向量空间 $V^n$ 的一个子空间。方程组的基础解系就是解空间的基。 2.3 子空间的运算2.3.1 和空间V_1 +V_2 = \\left \\{ x_1 + x_2 \\ | \\ x_1 \\in V_1, x_2 \\in V_2 \\right \\}2.3.2 交空间V_1 \\cap V_2 = \\left \\{ a \\ | \\ a \\in V_1 且 a \\in V_2 \\right \\} 3. 矩阵的值域、核空间3.1 向量张成的空间$x_1,x_2,…,x_n$张成的空间，记为 V_1=L(x_1, x_2, ..., x_n)=\\left \\{ k_1x_1 + k_2x_2 + ... + k_nx_n \\right \\}$$其中$k_i$为常数。 > *个人理解*：类似以向量组为基所生成的空间。 ### 3.2 矩阵的值域 矩阵 $A\\in C^{m×n}$的 $n$ 个列向量为 $a_1, a_2, ..., a_n$，则矩阵A的值域为$$R(A)=L(a_1, a_2, ..., a_n)=\\left \\{ y\\ | \\ y=Ax\\right \\} 个人理解：矩阵的值域是 矩阵中的所有列向量所张成的空间。若把 $A$ 看作一种线性变换，那么矩阵的值域 $y=Ax$ 为线性空间中的原向量 $x$ 经线性变换后所得到的象。 3.3 矩阵的核空间N(A) = \\left \\{ x\\ | \\ Ax=0 \\right \\}核空间也叫零空间，零空间的维数为零度，记作 $n(A)$ 。 个人理解：使 $Ax=0$ 成立的 $x$。若把 $A$ 看作一种线性变换， 那么矩阵的核是经过线性变换后变为零向量的向量（原象）。","categories":[{"name":"矩阵论","slug":"矩阵论","permalink":"http://monteyang.cn/categories/%E7%9F%A9%E9%98%B5%E8%AE%BA/"}],"tags":[{"name":"矩阵论","slug":"矩阵论","permalink":"http://monteyang.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"}]},{"title":"Linux基本命令总结","slug":"Linux基本命令总结","date":"2018-12-17T10:30:04.000Z","updated":"2020-02-16T16:09:17.216Z","comments":true,"path":"Linux基本命令总结.html","link":"","permalink":"http://monteyang.cn/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html","excerpt":"","text":"于2018年12月开始使用Linux操作系统，本文记录于2018-12-17 终端命令格式`command [-options] [parameter]` [] 代表可选 帮助 command --help man command 文件和目录常用命令查看目录内容 ls 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 tree 以树状图列出文件目录结构 选项 含义 -d 只显示目录 切换目录 cd 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 创建和删除操作 touch rm 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，**删除文件夹** 时必须加此参数 mkdir、 拷贝和移动文件 cp 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 mv 查看文件内容 cat more grep 其他 echo 重定向 &gt; 和 &gt;&gt; 将本应显示在终端上的内容 输出／追加 到指定文件中 管道 | 一个命令的输出通过管道 做为 另一个命令的输入 清屏 clear whereis, which 通配符 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 系统信息命令时间和日期 date cal 磁盘和目录空间 序号 命令 作用 01 df -h `disk free` 显示磁盘剩余空间 02 du -h [目录名] `disk usage` 显示目录下的文件大小 进程信息 序号 命令 作用 01 ps aux `process status` 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，`-9` 表示强行终止 > `ps` 默认只会显示当前用户通过终端启动的应用程序 * `ps` 选项说明功能 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 htop， 还有更多的top。。。 用户权限相关用户 和 权限 Linux系统中，每一个用户对于不同的系统资源（文件/目录）拥有不同的使用权限。 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 用户权限还可以通过用户组设置 ls -l 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组 大小 时间 名称 修改文件权限 chmod chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： chmod +/-rwx 文件名|目录名 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： 12345678# 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 12# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx 文件名|目录名 常见数字组合有（u表示用户／g表示组／o表示其他）： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r 远程管理shutdown 安全 关闭 或者 重新启动系统 常用命令示例 1234567891011121314# 重新启动操作系统，其中 now 表示现在$ shutdown -r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 20:25 会关机$ shutdown 20:25# 系统再过十分钟后自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 ssh`ssh [-p port] user@remote` user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 scp 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，指定端口时用的是大写的 -P 而不是小写的123456789101112# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo 常见服务端口号列表： 序号 服务 端口号 01 SSH 服务器 22 02 Web 服务器 80 03 HTTPS 443 04 FTP 服务器 21","categories":[{"name":"Linux","slug":"Linux","permalink":"http://monteyang.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://monteyang.cn/tags/Linux/"}]},{"title":"P问题、NP问题、NP完全问题和NP难问题","slug":"P问题、NP问题、NP完全问题和NP难问题","date":"2018-12-16T07:31:11.000Z","updated":"2020-02-18T08:44:45.996Z","comments":true,"path":"P问题、NP问题、NP完全问题和NP难问题.html","link":"","permalink":"http://monteyang.cn/P%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E3%80%81NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8CNP%E9%9A%BE%E9%97%AE%E9%A2%98.html","excerpt":"","text":"P问题: 存在多项式时间复杂度算法的问题(P：polynominal，多项式) 这是因为对计算机而言, 研究一个超过多项式时间复杂度的问题毫无意义 NP问题: 能在多项式时间内验证得出一个正确解的问题(NP:Nondeterministic polynominal，非确定性多项式) 不一定存在多项式时间复杂度算法的问题 P问题是NP问题的子集 NPC问题: 如果所有NP问题都能在多项式时间内转化为他, 则称该np问题为npc问题(NPC:NP complete又叫NP完全问题) NPC问题是NP问题的子集 NPH问题: NP难问题, 不是一个NP问题, 如果所有的NPC问题都可以在多项式时间内转化为他的话, 我们就叫他NPH（hard）问题。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://monteyang.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]}]}