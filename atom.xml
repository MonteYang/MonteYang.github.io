<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monte&#39;s Blog</title>
  
  <subtitle>朝着咸鱼的反方向努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monteyang.cn/"/>
  <updated>2020-05-08T09:31:43.452Z</updated>
  <id>http://monteyang.cn/</id>
  
  <author>
    <name>Monte Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matplotlib颜色对照表</title>
    <link href="http://monteyang.cn/matplotlib%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.html"/>
    <id>http://monteyang.cn/matplotlib%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.html</id>
    <published>2020-05-08T01:26:36.000Z</published>
    <updated>2020-05-08T09:31:43.452Z</updated>
    
    <content type="html"><![CDATA[<p>matplotlib 颜色对照</p><a id="more"></a><p><img data-src="../images/matplotlib-color-1024x1008.png" alt="matplotlib颜色对照"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">cnames = &#123;</span><br><span class="line"><span class="string">'aliceblue'</span>:            <span class="string">'#F0F8FF'</span>,</span><br><span class="line"><span class="string">'antiquewhite'</span>:         <span class="string">'#FAEBD7'</span>,</span><br><span class="line"><span class="string">'aqua'</span>:                 <span class="string">'#00FFFF'</span>,</span><br><span class="line"><span class="string">'aquamarine'</span>:           <span class="string">'#7FFFD4'</span>,</span><br><span class="line"><span class="string">'azure'</span>:                <span class="string">'#F0FFFF'</span>,</span><br><span class="line"><span class="string">'beige'</span>:                <span class="string">'#F5F5DC'</span>,</span><br><span class="line"><span class="string">'bisque'</span>:               <span class="string">'#FFE4C4'</span>,</span><br><span class="line"><span class="string">'black'</span>:                <span class="string">'#000000'</span>,</span><br><span class="line"><span class="string">'blanchedalmond'</span>:       <span class="string">'#FFEBCD'</span>,</span><br><span class="line"><span class="string">'blue'</span>:                 <span class="string">'#0000FF'</span>,</span><br><span class="line"><span class="string">'blueviolet'</span>:           <span class="string">'#8A2BE2'</span>,</span><br><span class="line"><span class="string">'brown'</span>:                <span class="string">'#A52A2A'</span>,</span><br><span class="line"><span class="string">'burlywood'</span>:            <span class="string">'#DEB887'</span>,</span><br><span class="line"><span class="string">'cadetblue'</span>:            <span class="string">'#5F9EA0'</span>,</span><br><span class="line"><span class="string">'chartreuse'</span>:           <span class="string">'#7FFF00'</span>,</span><br><span class="line"><span class="string">'chocolate'</span>:            <span class="string">'#D2691E'</span>,</span><br><span class="line"><span class="string">'coral'</span>:                <span class="string">'#FF7F50'</span>,</span><br><span class="line"><span class="string">'cornflowerblue'</span>:       <span class="string">'#6495ED'</span>,</span><br><span class="line"><span class="string">'cornsilk'</span>:             <span class="string">'#FFF8DC'</span>,</span><br><span class="line"><span class="string">'crimson'</span>:              <span class="string">'#DC143C'</span>,</span><br><span class="line"><span class="string">'cyan'</span>:                 <span class="string">'#00FFFF'</span>,</span><br><span class="line"><span class="string">'darkblue'</span>:             <span class="string">'#00008B'</span>,</span><br><span class="line"><span class="string">'darkcyan'</span>:             <span class="string">'#008B8B'</span>,</span><br><span class="line"><span class="string">'darkgoldenrod'</span>:        <span class="string">'#B8860B'</span>,</span><br><span class="line"><span class="string">'darkgray'</span>:             <span class="string">'#A9A9A9'</span>,</span><br><span class="line"><span class="string">'darkgreen'</span>:            <span class="string">'#006400'</span>,</span><br><span class="line"><span class="string">'darkkhaki'</span>:            <span class="string">'#BDB76B'</span>,</span><br><span class="line"><span class="string">'darkmagenta'</span>:          <span class="string">'#8B008B'</span>,</span><br><span class="line"><span class="string">'darkolivegreen'</span>:       <span class="string">'#556B2F'</span>,</span><br><span class="line"><span class="string">'darkorange'</span>:           <span class="string">'#FF8C00'</span>,</span><br><span class="line"><span class="string">'darkorchid'</span>:           <span class="string">'#9932CC'</span>,</span><br><span class="line"><span class="string">'darkred'</span>:              <span class="string">'#8B0000'</span>,</span><br><span class="line"><span class="string">'darksalmon'</span>:           <span class="string">'#E9967A'</span>,</span><br><span class="line"><span class="string">'darkseagreen'</span>:         <span class="string">'#8FBC8F'</span>,</span><br><span class="line"><span class="string">'darkslateblue'</span>:        <span class="string">'#483D8B'</span>,</span><br><span class="line"><span class="string">'darkslategray'</span>:        <span class="string">'#2F4F4F'</span>,</span><br><span class="line"><span class="string">'darkturquoise'</span>:        <span class="string">'#00CED1'</span>,</span><br><span class="line"><span class="string">'darkviolet'</span>:           <span class="string">'#9400D3'</span>,</span><br><span class="line"><span class="string">'deeppink'</span>:             <span class="string">'#FF1493'</span>,</span><br><span class="line"><span class="string">'deepskyblue'</span>:          <span class="string">'#00BFFF'</span>,</span><br><span class="line"><span class="string">'dimgray'</span>:              <span class="string">'#696969'</span>,</span><br><span class="line"><span class="string">'dodgerblue'</span>:           <span class="string">'#1E90FF'</span>,</span><br><span class="line"><span class="string">'firebrick'</span>:            <span class="string">'#B22222'</span>,</span><br><span class="line"><span class="string">'floralwhite'</span>:          <span class="string">'#FFFAF0'</span>,</span><br><span class="line"><span class="string">'forestgreen'</span>:          <span class="string">'#228B22'</span>,</span><br><span class="line"><span class="string">'fuchsia'</span>:              <span class="string">'#FF00FF'</span>,</span><br><span class="line"><span class="string">'gainsboro'</span>:            <span class="string">'#DCDCDC'</span>,</span><br><span class="line"><span class="string">'ghostwhite'</span>:           <span class="string">'#F8F8FF'</span>,</span><br><span class="line"><span class="string">'gold'</span>:                 <span class="string">'#FFD700'</span>,</span><br><span class="line"><span class="string">'goldenrod'</span>:            <span class="string">'#DAA520'</span>,</span><br><span class="line"><span class="string">'gray'</span>:                 <span class="string">'#808080'</span>,</span><br><span class="line"><span class="string">'green'</span>:                <span class="string">'#008000'</span>,</span><br><span class="line"><span class="string">'greenyellow'</span>:          <span class="string">'#ADFF2F'</span>,</span><br><span class="line"><span class="string">'honeydew'</span>:             <span class="string">'#F0FFF0'</span>,</span><br><span class="line"><span class="string">'hotpink'</span>:              <span class="string">'#FF69B4'</span>,</span><br><span class="line"><span class="string">'indianred'</span>:            <span class="string">'#CD5C5C'</span>,</span><br><span class="line"><span class="string">'indigo'</span>:               <span class="string">'#4B0082'</span>,</span><br><span class="line"><span class="string">'ivory'</span>:                <span class="string">'#FFFFF0'</span>,</span><br><span class="line"><span class="string">'khaki'</span>:                <span class="string">'#F0E68C'</span>,</span><br><span class="line"><span class="string">'lavender'</span>:             <span class="string">'#E6E6FA'</span>,</span><br><span class="line"><span class="string">'lavenderblush'</span>:        <span class="string">'#FFF0F5'</span>,</span><br><span class="line"><span class="string">'lawngreen'</span>:            <span class="string">'#7CFC00'</span>,</span><br><span class="line"><span class="string">'lemonchiffon'</span>:         <span class="string">'#FFFACD'</span>,</span><br><span class="line"><span class="string">'lightblue'</span>:            <span class="string">'#ADD8E6'</span>,</span><br><span class="line"><span class="string">'lightcoral'</span>:           <span class="string">'#F08080'</span>,</span><br><span class="line"><span class="string">'lightcyan'</span>:            <span class="string">'#E0FFFF'</span>,</span><br><span class="line"><span class="string">'lightgoldenrodyellow'</span>: <span class="string">'#FAFAD2'</span>,</span><br><span class="line"><span class="string">'lightgreen'</span>:           <span class="string">'#90EE90'</span>,</span><br><span class="line"><span class="string">'lightgray'</span>:            <span class="string">'#D3D3D3'</span>,</span><br><span class="line"><span class="string">'lightpink'</span>:            <span class="string">'#FFB6C1'</span>,</span><br><span class="line"><span class="string">'lightsalmon'</span>:          <span class="string">'#FFA07A'</span>,</span><br><span class="line"><span class="string">'lightseagreen'</span>:        <span class="string">'#20B2AA'</span>,</span><br><span class="line"><span class="string">'lightskyblue'</span>:         <span class="string">'#87CEFA'</span>,</span><br><span class="line"><span class="string">'lightslategray'</span>:       <span class="string">'#778899'</span>,</span><br><span class="line"><span class="string">'lightsteelblue'</span>:       <span class="string">'#B0C4DE'</span>,</span><br><span class="line"><span class="string">'lightyellow'</span>:          <span class="string">'#FFFFE0'</span>,</span><br><span class="line"><span class="string">'lime'</span>:                 <span class="string">'#00FF00'</span>,</span><br><span class="line"><span class="string">'limegreen'</span>:            <span class="string">'#32CD32'</span>,</span><br><span class="line"><span class="string">'linen'</span>:                <span class="string">'#FAF0E6'</span>,</span><br><span class="line"><span class="string">'magenta'</span>:              <span class="string">'#FF00FF'</span>,</span><br><span class="line"><span class="string">'maroon'</span>:               <span class="string">'#800000'</span>,</span><br><span class="line"><span class="string">'mediumaquamarine'</span>:     <span class="string">'#66CDAA'</span>,</span><br><span class="line"><span class="string">'mediumblue'</span>:           <span class="string">'#0000CD'</span>,</span><br><span class="line"><span class="string">'mediumorchid'</span>:         <span class="string">'#BA55D3'</span>,</span><br><span class="line"><span class="string">'mediumpurple'</span>:         <span class="string">'#9370DB'</span>,</span><br><span class="line"><span class="string">'mediumseagreen'</span>:       <span class="string">'#3CB371'</span>,</span><br><span class="line"><span class="string">'mediumslateblue'</span>:      <span class="string">'#7B68EE'</span>,</span><br><span class="line"><span class="string">'mediumspringgreen'</span>:    <span class="string">'#00FA9A'</span>,</span><br><span class="line"><span class="string">'mediumturquoise'</span>:      <span class="string">'#48D1CC'</span>,</span><br><span class="line"><span class="string">'mediumvioletred'</span>:      <span class="string">'#C71585'</span>,</span><br><span class="line"><span class="string">'midnightblue'</span>:         <span class="string">'#191970'</span>,</span><br><span class="line"><span class="string">'mintcream'</span>:            <span class="string">'#F5FFFA'</span>,</span><br><span class="line"><span class="string">'mistyrose'</span>:            <span class="string">'#FFE4E1'</span>,</span><br><span class="line"><span class="string">'moccasin'</span>:             <span class="string">'#FFE4B5'</span>,</span><br><span class="line"><span class="string">'navajowhite'</span>:          <span class="string">'#FFDEAD'</span>,</span><br><span class="line"><span class="string">'navy'</span>:                 <span class="string">'#000080'</span>,</span><br><span class="line"><span class="string">'oldlace'</span>:              <span class="string">'#FDF5E6'</span>,</span><br><span class="line"><span class="string">'olive'</span>:                <span class="string">'#808000'</span>,</span><br><span class="line"><span class="string">'olivedrab'</span>:            <span class="string">'#6B8E23'</span>,</span><br><span class="line"><span class="string">'orange'</span>:               <span class="string">'#FFA500'</span>,</span><br><span class="line"><span class="string">'orangered'</span>:            <span class="string">'#FF4500'</span>,</span><br><span class="line"><span class="string">'orchid'</span>:               <span class="string">'#DA70D6'</span>,</span><br><span class="line"><span class="string">'palegoldenrod'</span>:        <span class="string">'#EEE8AA'</span>,</span><br><span class="line"><span class="string">'palegreen'</span>:            <span class="string">'#98FB98'</span>,</span><br><span class="line"><span class="string">'paleturquoise'</span>:        <span class="string">'#AFEEEE'</span>,</span><br><span class="line"><span class="string">'palevioletred'</span>:        <span class="string">'#DB7093'</span>,</span><br><span class="line"><span class="string">'papayawhip'</span>:           <span class="string">'#FFEFD5'</span>,</span><br><span class="line"><span class="string">'peachpuff'</span>:            <span class="string">'#FFDAB9'</span>,</span><br><span class="line"><span class="string">'peru'</span>:                 <span class="string">'#CD853F'</span>,</span><br><span class="line"><span class="string">'pink'</span>:                 <span class="string">'#FFC0CB'</span>,</span><br><span class="line"><span class="string">'plum'</span>:                 <span class="string">'#DDA0DD'</span>,</span><br><span class="line"><span class="string">'powderblue'</span>:           <span class="string">'#B0E0E6'</span>,</span><br><span class="line"><span class="string">'purple'</span>:               <span class="string">'#800080'</span>,</span><br><span class="line"><span class="string">'red'</span>:                  <span class="string">'#FF0000'</span>,</span><br><span class="line"><span class="string">'rosybrown'</span>:            <span class="string">'#BC8F8F'</span>,</span><br><span class="line"><span class="string">'royalblue'</span>:            <span class="string">'#4169E1'</span>,</span><br><span class="line"><span class="string">'saddlebrown'</span>:          <span class="string">'#8B4513'</span>,</span><br><span class="line"><span class="string">'salmon'</span>:               <span class="string">'#FA8072'</span>,</span><br><span class="line"><span class="string">'sandybrown'</span>:           <span class="string">'#FAA460'</span>,</span><br><span class="line"><span class="string">'seagreen'</span>:             <span class="string">'#2E8B57'</span>,</span><br><span class="line"><span class="string">'seashell'</span>:             <span class="string">'#FFF5EE'</span>,</span><br><span class="line"><span class="string">'sienna'</span>:               <span class="string">'#A0522D'</span>,</span><br><span class="line"><span class="string">'silver'</span>:               <span class="string">'#C0C0C0'</span>,</span><br><span class="line"><span class="string">'skyblue'</span>:              <span class="string">'#87CEEB'</span>,</span><br><span class="line"><span class="string">'slateblue'</span>:            <span class="string">'#6A5ACD'</span>,</span><br><span class="line"><span class="string">'slategray'</span>:            <span class="string">'#708090'</span>,</span><br><span class="line"><span class="string">'snow'</span>:                 <span class="string">'#FFFAFA'</span>,</span><br><span class="line"><span class="string">'springgreen'</span>:          <span class="string">'#00FF7F'</span>,</span><br><span class="line"><span class="string">'steelblue'</span>:            <span class="string">'#4682B4'</span>,</span><br><span class="line"><span class="string">'tan'</span>:                  <span class="string">'#D2B48C'</span>,</span><br><span class="line"><span class="string">'teal'</span>:                 <span class="string">'#008080'</span>,</span><br><span class="line"><span class="string">'thistle'</span>:              <span class="string">'#D8BFD8'</span>,</span><br><span class="line"><span class="string">'tomato'</span>:               <span class="string">'#FF6347'</span>,</span><br><span class="line"><span class="string">'turquoise'</span>:            <span class="string">'#40E0D0'</span>,</span><br><span class="line"><span class="string">'violet'</span>:               <span class="string">'#EE82EE'</span>,</span><br><span class="line"><span class="string">'wheat'</span>:                <span class="string">'#F5DEB3'</span>,</span><br><span class="line"><span class="string">'white'</span>:                <span class="string">'#FFFFFF'</span>,</span><br><span class="line"><span class="string">'whitesmoke'</span>:           <span class="string">'#F5F5F5'</span>,</span><br><span class="line"><span class="string">'yellow'</span>:               <span class="string">'#FFFF00'</span>,</span><br><span class="line"><span class="string">'yellowgreen'</span>:          <span class="string">'#9ACD32'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;matplotlib 颜色对照&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度强化学习-rainbow</title>
    <link href="http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-rainbow.html"/>
    <id>http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-rainbow.html</id>
    <published>2020-04-29T22:51:47.000Z</published>
    <updated>2020-05-08T09:32:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>集合了多种 DQN 的变体<br><a id="more"></a></p><ul><li>DQN</li><li>Double DQN</li><li>Dueling DQN</li><li>Prioritized Experience Replay</li><li>NoiseNet: (Noisy Networks for Exploration, AAAI2018)</li><li>Distributional RL: (A Distributional Perspective on Reinforcement Learning, ICML2017)</li></ul><p><img data-src="../images/RL-rainbow.png" alt></p><blockquote><p>参考<br>Rainbow: Combining Improvements in Deep Reinforcement Learning</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合了多种 DQN 的变体&lt;br&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度强化学习" scheme="http://monteyang.cn/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度强化学习-Prioritized Experience Replay</title>
    <link href="http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Prioritized%20Experience%20Replay.html"/>
    <id>http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Prioritized%20Experience%20Replay.html</id>
    <published>2020-04-29T18:27:16.000Z</published>
    <updated>2020-05-08T09:30:46.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h1><p>在之前的 DQN 算法中，一个重要思想是经验回放（Experience Replay），在训练过程中，从经验回放池对样本进行<strong>均匀采样</strong>。</p><p>在实际的问题中，样本往往有它们的优先级，因为有一些样本是相对“珍贵”的。</p><a id="more"></a><h1 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h1><p>优先级的经验回放（Prioritized Experience Replay）则是维护了一个<strong>带优先级</strong>的经验回放池，在这个经验池中：</p><ul><li>不同经验样本的<strong>优先权重不同</strong></li><li>优先权是<strong>用 TD 误差来衡量</strong>的</li><li>带优先级的经验回放池需要使用 sum-tree 以及 binary heap 数据结构实现</li><li>新来的经验样本（transition）的 TD 误差会被设置为最大</li></ul><p><img data-src="../images/RL-优先级经验回放-来源.png" alt="思想来源"></p><p>实际使用时，优先级经验回放会存在的问题：</p><p>TD 误差小的 transition 长时间难以采样到，过分关注 TD 误差大的样本，降低了样本的多样性。</p><p>解决方法：</p><ul><li>两种变体： $p_i = |\delta_i| + \epsilon$ 或 $p_i = 1/rank(i)$</li></ul><blockquote><p>参考<br>Prioritized Experience Replay (ICLR 2016)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Problem&quot;&gt;&lt;a href=&quot;#1-Problem&quot; class=&quot;headerlink&quot; title=&quot;1. Problem&quot;&gt;&lt;/a&gt;1. Problem&lt;/h1&gt;&lt;p&gt;在之前的 DQN 算法中，一个重要思想是经验回放（Experience Replay），在训练过程中，从经验回放池对样本进行&lt;strong&gt;均匀采样&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在实际的问题中，样本往往有它们的优先级，因为有一些样本是相对“珍贵”的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度强化学习" scheme="http://monteyang.cn/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度强化学习-Dueling DQN</title>
    <link href="http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Dueling%20DQN.html"/>
    <id>http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Dueling%20DQN.html</id>
    <published>2020-04-28T03:50:06.000Z</published>
    <updated>2020-04-30T02:28:13.197Z</updated>
    
    <content type="html"><![CDATA[<p>将 Q 函数分解成 V 函数和 A 函数（优势函数）</p><a id="more"></a><p><img data-src="../images/RL-Deuling-DQN-network.png" alt="网络结构"></p><p>优势：</p><ul><li>V 函数只关于状态，而 Q 函数关于状态-动作对，Q 函数的维度要高于 V 函数。所以学习 V 函数的机会更大，不需要估计每个动作的价值。</li><li>V 函数的泛化性能好，当有新动作加入时，不需要重新学习，只需要学习新动作的 A 函数即可。</li><li>减少了 Q 函数由于状态和动作的纬度差导致的噪声和突变</li></ul><p><img data-src="../images/RL-Dueling-DQN-来源.png" alt="思想来源"></p><blockquote><p>参考<br>Dueling Network Architectures for Deep Reinforcement (ICML2016)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将 Q 函数分解成 V 函数和 A 函数（优势函数）&lt;/p&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度强化学习" scheme="http://monteyang.cn/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度强化学习-Double DQN</title>
    <link href="http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Double%20DQN.html"/>
    <id>http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Double%20DQN.html</id>
    <published>2020-04-27T23:14:11.000Z</published>
    <updated>2020-05-08T09:30:28.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h1><p>Q learning 中存在<strong>过估计问题</strong>。过估计问题是指估计的值函数比真实值函数要大。</p><p>在计算 TD 目标值时，$r+\gamma max_a Q(s’,a)$ 中的 max 操作，会引入一个正向的偏差，导致目标值在很多情况下会偏大一些。</p><blockquote><p>例如，对于状态 s 下，如果对于所有的 a，真实的 Q(s, a) 均为 0，但是估计值由于不精确，会导致有些大于 0，有些小于 0。对估计值取最大，会引入一个正向的偏差。</p></blockquote><a id="more"></a><h1 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h1><p>Double DQN 的思想源于 Double Q-learning。</p><p><img data-src="../images/RL-double-dqn来源.png" alt></p><p>Double DQN 中考虑建模两个 Q 网络，一个用于<strong>选择动作</strong>，一个用于<strong>评估动作</strong>。网络 A 和 B 是相互独立的。</p><ul><li>网络 A：选择动作</li><li>网络 B：评估动作</li></ul><p>此时，TD 目标值的计算如下：</p><script type="math/tex; mode=display">r + \gamma Q^B(s', arg\max_a Q^A(s', a))</script><p><strong>在网络 A 中，依然选择的是 Q 值最大的动作，但这个动作对于网络 B 而言不一定是 Q 值最大的。在期望平均的情况下，可以抵消原来计算的正向偏差。</strong></p><p>Double Q-learning 伪代码：</p><p><img data-src="../images/RL-Double-dqn.png" alt></p><p>在代码实现中，原 DQN 算法中本身就有两个网络，只需要 target network 变成可更新的。</p><blockquote><p>参考<br>[1] Van Hasselt H, Guez A, Silver D. Deep reinforcement learning with double q-learning[C]//Thirtieth AAAI conference on artificial intelligence. 2016.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Problem&quot;&gt;&lt;a href=&quot;#1-Problem&quot; class=&quot;headerlink&quot; title=&quot;1. Problem&quot;&gt;&lt;/a&gt;1. Problem&lt;/h1&gt;&lt;p&gt;Q learning 中存在&lt;strong&gt;过估计问题&lt;/strong&gt;。过估计问题是指估计的值函数比真实值函数要大。&lt;/p&gt;
&lt;p&gt;在计算 TD 目标值时，$r+\gamma max_a Q(s’,a)$ 中的 max 操作，会引入一个正向的偏差，导致目标值在很多情况下会偏大一些。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，对于状态 s 下，如果对于所有的 a，真实的 Q(s, a) 均为 0，但是估计值由于不精确，会导致有些大于 0，有些小于 0。对估计值取最大，会引入一个正向的偏差。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度强化学习" scheme="http://monteyang.cn/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度强化学习-DQN</title>
    <link href="http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-DQN.html"/>
    <id>http://monteyang.cn/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-DQN.html</id>
    <published>2020-04-24T16:33:05.000Z</published>
    <updated>2020-04-28T07:17:03.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度强化学习简介"><a href="#深度强化学习简介" class="headerlink" title="深度强化学习简介"></a>深度强化学习简介</h1><p>简单说来，<code>深度学习 + 强化学习 = 深度强化学习</code>。即，使用深度神经网络作为强化学习中的函数近似器，近似强化学习中的值函数模型、策略函数模型。</p><a id="more"></a><hr><h1 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h1><p>DQN（Deep Q Network）算法源自论文《Human-level control through deep reinforcement learning》(Nature2015)，这篇论文的算法框架基于传统强化学习中的 Q-learning（强化学习时间差分方法中已讲述）。在这里回顾一下 Q-learning：</p><p>Q-learning 方法是 off-policy 的时间差分方法。伪代码如图所示</p><p><img data-src="../images/Q-learning.jpg" alt></p><p>Q-learning 中有两个重要的概念：</p><ul><li>off-policy</li><li>时间差分</li></ul><p><strong>off-policy</strong> 是指<strong>行为策略（产生数据的策略）和目标策略不是一个策略</strong>。在 Q-learning 伪代码中，行为策略是$\epsilon -$贪婪策略，而要目标策略是贪婪策略（每个状态取值函数最大的那个动作）。</p><p><strong>时间差分方法</strong>，是指用时间差分目标值来更新当前行为值函数。在 Q-learning伪代码中，时间差分目标值为 $r_t + \gamma \max_a Q(s_{t+1}, a)$。</p><p>Q-learning 是1989年 Watkins 提出来的，2015年nature论文所提出的 DQN 是在Q-learning的基础上修改得到的。</p><p>DQN 对 Q-learning 的修改主要体现在以下3点：</p><ul><li>用深度卷积神经网络近似值函数</li><li>用<strong>经验回放机制</strong>对强化学习的学习过程进行训练</li><li>设置<strong>目标值函数网络</strong>来稳定时间差分算法中的 TD 误差</li></ul><p>下面对以上3点详细展开：</p><h2 id="1-深度卷积神经网络近似值函数"><a href="#1-深度卷积神经网络近似值函数" class="headerlink" title="1. 深度卷积神经网络近似值函数"></a>1. 深度卷积神经网络近似值函数</h2><p>神经网络拟合函数的好处，在之前（强化学习-值函数近似中）已经讲述过，此处不再赘述。</p><h2 id="2-经验回放机制"><a href="#2-经验回放机制" class="headerlink" title="2. 经验回放机制"></a>2. 经验回放机制</h2><p>对神经网络进行训练时，存在的假设是独立同分布。而通过强化学习采集到的数据之间存在着关联性，利用这些时间相关性强的数据进行训练，神经网络当然不稳定。经验回放机制可以<strong>打破数据间的关联</strong>。</p><p>在强化学习过程中，智能体将数据存储到一个数据库中，然后利用均匀随机采样的方法从数据库中抽取数据，然后利用抽取的数据对神经网络进行训练。</p><p><img data-src="../images/DQN-经验回放.png" alt></p><h2 id="3-目标值函数网络"><a href="#3-目标值函数网络" class="headerlink" title="3. 目标值函数网络"></a>3. 目标值函数网络</h2><p>与表格型的Q-learning算法，如图1.1所不同的是，利用神经网络对值函数进行逼近时，值函数的更新步更新的是参数[公式]，更新方法是梯度下降法。因此图1.1中第6行值函数更新实际上变成了监督学习的一次更新过程，其梯度下降法为：</p><p><img data-src="https://www.zhihu.com/equation?tex=%5C%5B%0A%5Ctheta_%7Bt%2B1%7D%3D%5Ctheta_t%2B%5Calpha%5Cleft%5Br%2B%5Cgamma%5Cmax_%7Ba%27%7DQ%5Cleft%28s%27%2Ca%27%3B%5Ctheta%5Cright%29-Q%5Cleft%28s%2Ca%3B%5Ctheta%5Cright%29%5Cright%5D%5Cnabla+Q%5Cleft%28s%2Ca%3B%5Ctheta%5Cright%29%0A%5C%5D" alt></p><p>我们称计算TD目标时所用的网络为目标值函数网络。以往的神经网络逼近值函数时，计算TD目标的值函数所用的网络参数$\theta$，与梯度计算中要逼近的值函数用的网络参数相同，这样就容易使得数据间存在关联性，训练不稳定。为了解决这个问题，DeepMind提出：</p><ul><li>计算TD目标的网络表示为$\theta^-$</li><li>计算值函数逼近的网络表示为$\theta$</li><li>用于动作值函数逼近的网络每一步都更新，而用于计算TD目标的网络每个固定的步数更新一次</li></ul><h2 id="DQN-伪代码"><a href="#DQN-伪代码" class="headerlink" title="DQN 伪代码"></a>DQN 伪代码</h2><p><img data-src="../images/DQN伪代码.jpg" alt></p><p>算法流程：</p><ul><li>初始化<strong>经验回放池 D</strong>，可容纳 N 条数据</li><li>随机初始化值函数网络，权重$\theta$</li><li>初始化目标值函数网络 $\theta^- = \theta$（用来计算TD目标值）</li><li><code>for</code> 每个片段（episode）：<ul><li>初始化第一个状态 $s_1={x_1}$，预处理得到状态对应的特征输入 $\phi_1=\phi(s_1)$</li><li><code>for</code>  episode 中的每一步：<ul><li>通过 <strong>$\epsilon-$贪婪策略</strong> 选择动作 $a_t$</li><li>执行动作 $a_t$，获得奖励 $r_t$，新的图像 $x_{t+1}$</li><li>设置 $s_{t+1} = s_t, a_t, x_{t+1}$，预处理$\phi_{t+1}=\phi(s_{t+1})$</li><li>将转移作为样本$(\phi_t, a_t, r_t, \phi_{t+1})$ <strong>储存在经验池D</strong>中</li><li>从回放记忆D中随机批量采样转换样本数据（<strong>mini batch</strong>）。</li><li>利用<strong>目标值函数网络</strong>求 <strong>TD 目标值</strong>（target）</li><li>TD目标值和当前值函数作差为损失函数，进行梯度下降法，更新网络权重 $\theta$</li><li><strong>每隔 C 步，更新目标值函数网络</strong>的权重（用值函数网络的权重）</li></ul></li><li><code>end for</code></li></ul></li><li><code>end for</code></li></ul><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/26052182" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/26052182</a><br>《Human-level control through deep reinforcement learning》(Nature2015)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深度强化学习简介&quot;&gt;&lt;a href=&quot;#深度强化学习简介&quot; class=&quot;headerlink&quot; title=&quot;深度强化学习简介&quot;&gt;&lt;/a&gt;深度强化学习简介&lt;/h1&gt;&lt;p&gt;简单说来，&lt;code&gt;深度学习 + 强化学习 = 深度强化学习&lt;/code&gt;。即，使用深度神经网络作为强化学习中的函数近似器，近似强化学习中的值函数模型、策略函数模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度强化学习" scheme="http://monteyang.cn/tags/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（四）库</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%93.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%93.html</id>
    <published>2020-04-20T06:05:31.000Z</published>
    <updated>2020-04-24T16:34:02.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。</p><!-- > 首发于公众号【Python与算法之路】 --></blockquote><a id="more"></a><h2 id="按需选择-sort-或者-sorted"><a href="#按需选择-sort-或者-sorted" class="headerlink" title="按需选择 sort() 或者 sorted()"></a>按需选择 <code>sort()</code> 或者 <code>sorted()</code></h2><p>Python 中常用的排序函数有 <code>sort()</code> 和 <code>sorted()</code> </p><p>两者的函数形式分别如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable[, cmp[, key[, reverse]]])</span><br><span class="line">s.sort([cmp[, key[, reverse]]])</span><br></pre></td></tr></table></figure><p><code>sort()</code> 和 <code>sorted()</code> 有3个共同的参数：</p><ul><li><code>cmp</code> ：<strong>用户定义的任何比较函数</strong>，函数的参数为两个可比较的元素（来自 iterable 或者 list ），函数根据第一个参数与第二个参数的关系依次返回 -1、0 或者 +1（第一个参数小于第二个参数则返回负数）。该参数默认值为 <code>None</code>。</li><li><code>key</code> 是一个带参数的函数，<strong>用来为每个元素提取比较值</strong>，默认为 <code>None</code>（即直接比较每个元素）</li><li><code>reverse</code> 表示排序<strong>结果是否反转</strong></li></ul><p>两者对比：</p><ul><li><p><code>sorted()</code> 作用于<strong>任何可迭代的对象</strong>；而 <code>sort()</code> 一般作用于<strong>列表</strong>。</p></li><li><p><code>sorted()</code> 函数会<strong>返回一个排序后的列表，原有列表保持不变</strong>；而 <code>sort()</code> 函数会<strong>直接修改原有列表</strong>，函数返回为 <code>None</code>。实际应用过程中需要保留原有列表，使用 <code>sorted()</code> 函数较为合适，否则可以选择 <code>sort()</code> 函数，因为 <code>sort()</code> 函数不需要复制原有列表，消耗的内存较少，效率也较高。</p></li><li>无论是 <code>sort()</code> 还是 <code>sorted()</code> 函数，传入参数 <code>key</code> 比传入参数 <code>cmp</code> 效率要高。<code>cmp</code> 传入的函数在整个排序过程中会调用多次，函数开销较大；而 <code>key</code> 针对每个元素仅做一次处理，因此使用 key 比使用 <code>cmp</code> 效率要高。</li><li><code>sorted()</code> 功能非常强大，它可以<strong>对不同的数据结构进行排序</strong>，从而满足不同需求。</li></ul><p>例：</p><p><strong>对字典进行排序</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phone_book = &#123;<span class="string">"Linda"</span>: <span class="string">"7750"</span>, <span class="string">"Bob"</span>: <span class="string">"9345"</span>, <span class="string">"Carol"</span>: <span class="string">"5834"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_pb = sorted(phone_book.items(), key=itemgetter(<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sorted_pb)</span><br><span class="line">[(<span class="string">'Carol'</span>, <span class="string">'5834'</span>), (<span class="string">'Linda'</span>, <span class="string">'7750'</span>), (<span class="string">'Bob'</span>, <span class="string">'9345'</span>)]</span><br></pre></td></tr></table></figure><p><strong>多维 List 排序</strong>：实际情况下也会碰到需要对多个字段进行排序的情况，这在 DB 里面用 SQL 语句很容易做到，但使用多维列表联合 <code>sorted()</code> 函数也可以轻易达到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [[<span class="string">"Bob"</span>,<span class="number">95</span>,<span class="string">"A"</span>],[<span class="string">"Alan"</span>,<span class="number">86</span>,<span class="string">"C"</span>],[<span class="string">"Mandy"</span>,<span class="number">82.5</span>,<span class="string">"A"</span>],[<span class="string">"Rob"</span>,<span class="number">86</span>,<span class="string">"E"</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(game_result, key=operator.itemgetter(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">[[<span class="string">'Mandy'</span>, <span class="number">82.5</span>, <span class="string">'A'</span>], [<span class="string">'Bob'</span>, <span class="number">95</span>, <span class="string">'A'</span>], [<span class="string">'Alan'</span>, <span class="number">86</span>, <span class="string">'C'</span>], [<span class="string">'Rob'</span>, <span class="number">86</span>, <span class="string">'E'</span>]]</span><br></pre></td></tr></table></figure><p><strong>字典中混合 List 排序</strong>：字典中的 key 或者值为列表，对列表中的某一个位置的元素排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_dict = &#123;<span class="string">"Li"</span>:[<span class="string">"M"</span>,<span class="number">7</span>],<span class="string">"Zhang"</span>:[<span class="string">"E"</span>,<span class="number">2</span>],<span class="string">"Wang"</span>:[<span class="string">"P"</span>,<span class="number">3</span>],<span class="string">"Du"</span>:[<span class="string">"C"</span>,<span class="number">2</span>],<span class="string">"Ma"</span>:[<span class="string">"C"</span>,<span class="number">9</span>],<span class="string">"Zhe"</span>:[<span class="string">"H"</span>,<span class="number">7</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(my_dict.items(), key=<span class="keyword">lambda</span> item:operator.itemgetter(<span class="number">1</span>)(item[<span class="number">1</span>]))</span><br><span class="line">[(<span class="string">'Du'</span>, [<span class="string">'C'</span>, <span class="number">2</span>]), (<span class="string">'Zhang'</span>, [<span class="string">'E'</span>, <span class="number">2</span>]), (<span class="string">'Wang'</span>, [<span class="string">'P'</span>, <span class="number">3</span>]), (<span class="string">'Zhe'</span>, [<span class="string">'H'</span>, <span class="number">7</span>]), (<span class="string">'Li'</span>, [<span class="string">'M'</span>, <span class="number">7</span>]), (<span class="string">'Ma'</span>, [<span class="string">'C'</span>, <span class="number">9</span>])]</span><br></pre></td></tr></table></figure><p><strong>List 中混合字典排序</strong>：列表中的每一个元素为字典形式，针对字典的多个 key 值进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [&#123;<span class="string">"name"</span>:<span class="string">"Bob"</span>,<span class="string">"wins"</span>:<span class="number">10</span>,<span class="string">"losses"</span>:<span class="number">3</span>,<span class="string">"rating"</span>:<span class="number">75</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"David"</span>,<span class="string">"wins"</span>:<span class="number">3</span>,<span class="string">"losses"</span>:<span class="number">5</span>,<span class="string">"rating"</span>:<span class="number">57</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"Carol"</span>,<span class="string">"wins"</span>:<span class="number">4</span>,<span class="string">"losses"</span>:<span class="number">5</span>,<span class="string">"rating"</span>:<span class="number">57</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"Patty"</span>,<span class="string">"wins"</span>:<span class="number">9</span>,<span class="string">"losses"</span>:<span class="number">3</span>,<span class="string">"rating"</span>:<span class="number">71.48</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(game_result, key=operator.itemgetter(<span class="string">"rating"</span>,<span class="string">"name"</span>))</span><br><span class="line">[&#123;<span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'Carol'</span>, <span class="string">'rating'</span>: <span class="number">57</span>, <span class="string">'wins'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'David'</span>, <span class="string">'rating'</span>: <span class="number">57</span>, <span class="string">'wins'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Patty'</span>, <span class="string">'rating'</span>: <span class="number">71.48</span>, <span class="string">'wins'</span>: <span class="number">9</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>, <span class="string">'rating'</span>: <span class="number">75</span>, <span class="string">'wins'</span>: <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="使用-copy-模块深拷贝对象"><a href="#使用-copy-模块深拷贝对象" class="headerlink" title="使用 copy 模块深拷贝对象"></a>使用 copy 模块深拷贝对象</h2><ul><li><strong>浅拷贝（shallow copy）</strong>：构造一个新的复合对象，并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式有多种，如工厂函数、切片操作、copy 模块中的 <code>copy</code> 操作等。</li><li><strong>深拷贝（deep copy）</strong>：也构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。深拷贝的实现需要依赖 copy 模块的 <code>deepcopy()</code> 操作。</li></ul><p><strong>浅拷贝并不能进行彻底的拷贝，当存在列表、字典等不可变对象的时候，它仅仅拷贝其引用地址</strong>。要解决上述问题需要用到深拷贝，深拷贝不仅拷贝引用也拷贝引用所指向的对象，因此<strong>深拷贝得到的对象和原对象是相互独立的。</strong></p><h2 id="使用-Counter-进行计数统计"><a href="#使用-Counter-进行计数统计" class="headerlink" title="使用 Counter 进行计数统计"></a>使用 Counter 进行计数统计</h2><p>计数统计就是统计某一项出现的次数。可以使用不同数据结构来进行实现：</p><ul><li>例如，使用 <code>defaultdict</code>实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">some_data = [<span class="string">"a"</span>, <span class="string">"2"</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"2"</span>, <span class="string">"b"</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">"a"</span>, <span class="number">5</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>]</span><br><span class="line">count_frq = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> some_data:</span><br><span class="line">    count_frq[item] += <span class="number">1</span></span><br><span class="line">print(count_frq)</span><br><span class="line"><span class="comment"># defaultdict(&lt;class 'int'&gt;, &#123;'a': 3, '2': 2, 2: 1, 4: 2, 5: 2, 'b': 1, 7: 1, 'd': 1, 'z': 1&#125;)</span></span><br></pre></td></tr></table></figure><p>但<strong>更优雅，更 Pythonic 的解决方法是使用 <code>collections.Counter</code></strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">some_data = [<span class="string">"a"</span>, <span class="string">"2"</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"2"</span>, <span class="string">"b"</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">"a"</span>, <span class="number">5</span>, <span class="string">"d"</span>, <span class="string">"z"</span>, <span class="string">"a"</span>]</span><br><span class="line">print(Counter(some_data))</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 3, '2': 2, 4: 2, 5: 2, 2: 1, 'b': 1, 7: 1, 'd': 1, 'z': 1&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="深入掌握-ConfigParser"><a href="#深入掌握-ConfigParser" class="headerlink" title="深入掌握 ConfigParser"></a>深入掌握 ConfigParser</h2><p>常见的配置文件格式有 XML 和 ini 等，其中在 MS Windows 系统上，ini 文件格式用得尤其多，甚至操作系统的 API 也都提供了相关的接口函数来支持它。类似 ini 的文件格式，在 Linux 等操作系统中也是极常用的，比如 pylint 的配置文件就是这个格式。Python 有个标准库来支持它，也就是 ConfigParser。</p><p>ConfigParser 的基本用法通过<a href="http://doc.codingdict.com/python_352/library/configparser.html" target="_blank" rel="external nofollow noopener noreferrer">手册</a>可以掌握，但仍然有几个知识点值得注意。首先就是 <code>getboolean()</code> 这个函数。<code>getboolean()</code> 根据一定的规则将配置项的值转换为布尔值，如以下的配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[section1]</span></span><br><span class="line"><span class="attr">option1</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>当调用 <code>getboolean(&quot;section1&quot;, &quot;option1&quot;)</code> 时，将返回 False。</p><p><strong><code>getboolean()</code> 的真值规则</strong>： 除了 0 以外，no、false 和 off 都会被转义为 False，而对应的 1、yes、true 和 on 则都被转义为 True，其他值都会导致抛出 <code>ValueError</code> 异常。</p><p>还需要注意的是配置项的查找规则。首先，在 ConfigParser 支持的配置文件格式里，有一个 <code>[DEFAULT]</code> 节，当读取的配置项不在指定的节里时，ConfigParser 将会到 <code>[DEFAULT]</code> 节中查找。<br>除此之外，还有一些机制导致项目对配置项的查找更复杂，这就是 class ConfigParser 构造函数中的 defaults 形参以及其 <code>get(section, option[, raw[, vars]])</code> 中的全名参数 <code>vars</code>。如果把这些机制全部用上，那么<strong>配置项值的查找规则</strong>：</p><ul><li>如果找不到节名，就抛出 NoSectionError</li><li>如果给定的配置项出现在 <code>get()</code> 方法的 <code>var</code> 参数中，则返回 <code>var</code> 参数中的值</li><li>如果在指定的节中含有给定的配置项，则返回其值</li><li>如果在 【DEFAULT】中有指定的配置项，则返回其值</li><li>如果在构造函数的 defaults 参数中有指定的配置项，则返回其值</li><li>抛出 NoOptionError</li></ul><h2 id="使用-argparse-处理命令行参数"><a href="#使用-argparse-处理命令行参数" class="headerlink" title="使用 argparse 处理命令行参数"></a>使用 argparse 处理命令行参数</h2><p>尽管应用程序通常能够通过配置文件在不修改代码的情况下改变行为，但提供灵活易用的命令行参数仍然非常有意义，比如：减轻用户的学习成本，通常命令行参数的用法只需要在应用程序名后面加 —help 参数就能获得，而配置文件的配置方法通常需要通读手册才能掌握。</p><p>关于命令行处理，现阶段<strong>最好用的</strong>参数处理标准库是 argparse。</p><ul><li><code>add_argument()</code> 方法用以增加一个参数声明。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><ul><li>除了支持常规的 int/float 等基本数值类型外，argparse 还<strong>支持文件类型</strong>，只要参数合法，程序就能够使用相应的文件描述符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"bar"</span>, type=argparse.FileType(<span class="string">"w"</span>))</span><br><span class="line">parser.parse_args([<span class="string">"out.txt"</span>])</span><br></pre></td></tr></table></figure><ul><li><strong>扩展类型</strong>也变得更加容易，任何可调用对象，比如函数，都可以作为 type 的实参。另外 choices 参数也支持更多的类型，比如：   <code>parser.add_argument(&quot;door&quot;, type=int, choices=range(1, 4))</code>。</li><li>此外，add_argument() 提供了对<strong>必填参数</strong>的支持，只要把 required 参数设置为 True 传递进去，当缺失这一参数时，argparse 就会自动退出程序，并提示用户。</li><li>还支持<strong>参数分组</strong>。add_argument_group() 可以在输出帮助信息时更加清晰，这在用法复杂的 CLI 应用程序中非常有帮助：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">"PROG"</span>, add_help=<span class="literal">False</span>)</span><br><span class="line">group1 = parser.add_argument_group(<span class="string">"group1"</span>, <span class="string">"group1 description"</span>)</span><br><span class="line">group1.add_argument(<span class="string">"foo"</span>, help=<span class="string">"foo help"</span>)</span><br><span class="line">group2 = parser.add_argument_group(<span class="string">"group2"</span>, <span class="string">"group2 description"</span>)</span><br><span class="line">group2.add_argument(<span class="string">"--bar"</span>, help=<span class="string">"bar help"</span>)</span><br><span class="line">parser.print_help()</span><br></pre></td></tr></table></figure><ul><li>另外还有 <code>add_mutually_exclusive_group(required=False)</code> 非常实用：它确保组中的<strong>参数至少有一个或者只有一个</strong>（required=True）。</li><li>argparse 也支持<strong>子命令</strong>，比如 <code>pip</code> 就有 <code>install/uninstall/freeze/list/show</code> 等子命令，这些子命令又接受不同的参数，使用 ArgumentParser.add_subparsers() 就可以实现类似的功能。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">"PROG"</span>)</span><br><span class="line">subparsers = parser.add_subparsers(help=<span class="string">"sub-command help"</span>)</span><br><span class="line">parser_a = subparsers.add_parser(<span class="string">"a"</span>, help=<span class="string">"a help"</span>)</span><br><span class="line">parser_a.add_argument(<span class="string">"--bar"</span>, type=int, help=<span class="string">"bar help"</span>)</span><br><span class="line">parser.parse_args([<span class="string">"a"</span>, <span class="string">"--bar"</span>, <span class="string">"1"</span>])</span><br></pre></td></tr></table></figure><ul><li>除了参数处理之外，当出现<strong>非法参数</strong>时，用户还需要做一些处理，处理完成后，一般是输出提示信息并退出应用程序。ArgumentParser 提供了两个方法函数，分别是 <code>exit(status=0, message=None)</code> 和 <code>error(message)</code>，可以省了 <code>import sys</code> 再调用 <code>sys.exit()</code> 的步骤。</li></ul><h2 id="理解模块-pickle-优劣"><a href="#理解模块-pickle-优劣" class="headerlink" title="理解模块 pickle 优劣"></a>理解模块 pickle 优劣</h2><p>序列化，简单地说就是把内存中的数据结构在不丢失其身份和类型信息的情况下转换成对象的文本或二进制表示的过程。对象序列化后的形式经过反序列化过程应该能恢复原有对象。</p><p>Python 中有很多支持序列化的模块，如 pickle、json、marshal 和 shelve 等。</p><p><strong>pickle 是最通用的序列化模块</strong>，它还有个 C 语言的实现 cPickle，相比 pickle 来说具有较好的性能，其速度大概是 pickle 的 1000 倍，因此在大多数应用程序中应该优先使用 cPickle（注：cPickle 除了不能被继承之外，它们两者的使用基本上区别不大）。pickle 中最主要的两个函数对为 <code>dump()</code> 和 <code>load()</code>，分别用来进行对象的序列化和反序列化。</p><p>pickle 良好的特性总结为以下几点：</p><ul><li><strong>接口简单，容易使用</strong>。使用 <code>dump()</code> 和 <code>load()</code> 便可轻易实现序列化和反序列化。</li><li><strong>pickle 的存储格式具有通用性，能够被不同平台的 Python 解析器共享</strong>。比如 Linux 下序列化的格式文件可以在 Windows 平台的 Python 解析器上进行反序列化，兼容性较好。</li><li><strong>支持的数据类型广泛</strong>。如数字、布尔值、字符串，只包含可序列化对象的元组、字典、列表等，非嵌套的函数、类以及通过类的 <code>__dict__</code> 或者 <code>__getstate__()</code> 可以返回序列化对象的实例等。</li><li><p>pickle 模块是<strong>可以扩展</strong>的。对于实例对象，pickle 在还原对象的时候一般是不调用 <code>__init__()</code> 函数的，如果要调用 <code>__init__()</code> 进行初始化，对于古典类可以在类定义中提供 <code>__getinitargs__()</code> 函数，并返回一个元组，当进行 unpickle 的时候，Python 就会自动调用 <code>__init__()</code>，并把 <code>__getinitargs__()</code> 中返回的元组作为参数传递给 <code>__init__()</code>，而对于新式类，可以提供 <code>__getnewargs__()</code> 来提供对象生成时候的参数，在 unpickle 的时候以 <code>Class.__new__(Class, *arg)</code> 的方式创建对象。对于不可序列化的对象，如 sockets、文件句柄、数据库连接等，也可以通过实现 pickle 协议来解决这些巨献，主要是通过特殊方法 <code>__getstate__()</code> 和 <code>__setstate__()</code> 来返回实例在被 pickle 时的状态。</p><p>  示例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextReader</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = filename    <span class="comment"># 文件名称</span></span><br><span class="line">        self.file = open(filename)    <span class="comment"># 打开文件的句柄</span></span><br><span class="line">        self.postion = self.file.tell()    <span class="comment"># 文件的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        line = self.file.readline()</span><br><span class="line">        self.postion = self.file.tell()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> line.endswith(<span class="string">"\n"</span>):</span><br><span class="line">            line = line[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;: &#123;&#125;"</span>.format(self.postion, line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span>    <span class="comment"># 记录文件被 pickle 时候的状态</span></span><br><span class="line">        state = self.__dict__.copy()    <span class="comment"># 获取被 pickle 时的字典信息</span></span><br><span class="line">        <span class="keyword">del</span> state[<span class="string">"file"</span>]</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span>    <span class="comment"># 设置反序列化后的状态</span></span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line">        file = open(self.filename)</span><br><span class="line">        self.file = file</span><br><span class="line"></span><br><span class="line">reader = TextReader(<span class="string">"zen.text"</span>)</span><br><span class="line">print(reader.readline())</span><br><span class="line">print(reader.readline())</span><br><span class="line">s = pickle.dumps(reader)    <span class="comment"># 在 dumps 的时候会默认调用 __getstate__</span></span><br><span class="line">new_reader = pickle.loads(s)    <span class="comment"># 在 loads 的时候会默认调用 __setstate__</span></span><br><span class="line">print(new_reader.readline())</span><br></pre></td></tr></table></figure></li><li><p>能够自动维护对象间的引用，如果一个对象上存在多个引用，pickle 后不会改变对象间的引用，并且能够自动处理循环和递归引用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a    <span class="comment"># b 引用对象 a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="string">"c"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pickle.dumps((a, b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, b1 = pickle.loads(p)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.append(<span class="string">"d"</span>)    <span class="comment"># 反序列化对 a1 对象的修改仍然会影响到 b1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br></pre></td></tr></table></figure><p>但 pickle 使用也存在以下一些限制：</p></li><li><strong>pickle 不能保证操作的原子性</strong>。pickle 并不是原子操作，也就是说在一个 pickle 调用中如果发生异常，可能部分数据已经被保存，另外如果对象处于深递归状态，那么可能超出 Python 的最大递归深度。递归深度可以通过 <code>sys.setrecursionlimit()</code> 进行扩展。</li><li><strong>pickle 存在安全性问题</strong>。Python 的文档清晰地表明它不提供安全性保证，因此对于一个从不可信的数据源接收到的数据不要轻易进行反序列化。由于 loads() 可以接收字符串作为参数，精心设计的字符串给入侵提供了一种可能。在 Python 解释器中输入代码 <code>pickle.loads(&quot;cos\nsystem\n(S&#39;dir\ntR.&quot;)</code>便可以查看当前目录下所有文件。可以将 dir 替换为其他更具破坏性的命令。如果要进一步提高安全性，用户可以通过继承类 pickle.Unpickler 并重写 <code>find_class()</code> 方法来实现。</li><li><strong>pickle 协议是 Python 特定的，不同语言之间的兼容性难以保障</strong>。用 Python 创建的 pickle 文件可能其他语言不能使用。</li></ul><h2 id="序列化的另一个不错的选择——JSON"><a href="#序列化的另一个不错的选择——JSON" class="headerlink" title="序列化的另一个不错的选择——JSON"></a>序列化的另一个不错的选择——JSON</h2><p>Python 的标准库 JSON 提供的最常用的方法与 pickle 类似，dump/dumps 用来序列化，load/loads 用来反序列化。需要注意 json 默认不支持非 ASCII-based 的编码，如 load 方法可能在处理中文字符时不能正常显示，则需要通过 encoding 参数指定对应的字符编码。在序列化方面，相比 pickle，JSON 具有以下优势：</p><ul><li>使用简单，<strong>支持多种数据类型</strong>。JSON 文档的构成非常简单，仅存在以下两大数据结构：<ul><li><strong>名称/值对的集合</strong>。在各种语言中，它被实现为一个对象、记录、结构、字典、散列表、键列表或关联数组。</li><li><strong>值的有序列表</strong>。在大多数语言中，它被实现为数组、向量、列表或序列。在 Python 中对应支持的数据类型包括字典、列表、字符串、整数、浮点数、True、False、None 等。JSON 中数据结构和 Python 中的转换并不是完全一一对应，存在一定的差异。</li></ul></li><li><strong>存储格式可读性更为友好，容易修改</strong>。相比于 pickle 来说，json 格式更加接近程序员的思维，阅读和修改上要容易得多。dumps() 函数提供了一个参数 indent 使生成的 json 文件可读性更好，0 意味着“每个值单独一行”；大于 0 的数字意味着“每个值单独一行并且使用这个数字的空格来缩进嵌套的数据结构”。但需要注意的是，这个参数是以文件大小变大为代价的。</li><li><strong>json 支持跨平台跨语言操作</strong>。如 Python 中生成的 json 文件可以轻易使用 JavaScript 解析，互操作性更强，而 pickle 格式的文件只能在 Python 语言中支持。此外 json 原生的 JavaScript 支持，客户端浏览器不需要为此使用额外的解释器，特别适用于 Web 应用提供快速、紧凑、方便地序列化操作。此外，相比于 pickle，json 的存储格式更为紧凑，所占空间更小。</li><li><strong>具有较强的扩展性</strong>。json 模块还提供了编码（JSONEncoder）和解码类（JSONDecoder）以便用户对其默认不支持的序列化类型进行扩展。</li></ul><p>Python 中标准模块 json 的性能比 pickle 与 cPickle 稍逊。如果对序列化性能要求非常高的场景，可以使用 cPickle 模块。</p><h2 id="使用-threading-模块编写多线程程序"><a href="#使用-threading-模块编写多线程程序" class="headerlink" title="使用 threading 模块编写多线程程序"></a>使用 threading 模块编写多线程程序</h2><p>GIL 的存在使得 Python 多线程编程暂时无法充分利用多处理器的优势，并不能提高运行速率，但在以下几种情况，如<strong>等待外部资源返回</strong>，或者<strong>为了提高用户体验而建立反应灵活的用户界面</strong>，或者<strong>多用户应用程序</strong>中，多线程仍然是一个比较好的解决方案。</p><p>Python 为多线程编程提供了两个非常简单明了的模块：thread 和 threading。</p><p>thread 模块提供了多线程底层支持模块，以低级原始的方式来处理和控制线程，使用起来较为复杂；而 threading 模块基于 thread 进行包装，将线程的操作对象化，在语言层面提供了丰富的特性。实际应用中，<strong>推荐优先使用 threading 模块而不是 thread 模块。</strong></p><ul><li><p>就线程的<strong>同步和互斥</strong>来说，threading 模块中不仅有 Lock 指令锁，RLock 可重入指令锁，还支持条件变量 Condition、信号量 Semaphore、BoundedSemaphore 以及 Event 事件等。</p></li><li><p><strong>threading 模块主线程和子线程交互友好</strong>，<code>join()</code> 方法能够阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的 timeout（可选参数）。利用该方法可以方便地控制主线程和子线程以及子线程之间的执行。</p></li></ul><p>实际上很多情况下我们可能希望主线程能够等待所有子线程都完成时才退出，这时使用 threading 模块守护线程，可以通过 setDaemon() 函数来设定线程的 daemon 属性。当 daemon 属性设置为 True 的时候表明主线程的退出可以不用等待子线程完成。默认情况下，daemon 标志为 False，所有的非守护线程结束后主线程才会结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(a, delay)</span>:</span></span><br><span class="line">    print(<span class="string">"I will calculate square of &#123;&#125; after delay for &#123;&#125;"</span>.format(a, delay))</span><br><span class="line">    time.sleep(delay)</span><br><span class="line">    print(<span class="string">"calculate begins..."</span>)</span><br><span class="line">    result = a * a</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=myfunc, args=(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">t2 = threading.Thread(target=myfunc, args=(<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">print(t1.isDaemon())</span><br><span class="line">print(t2.isDaemon())</span><br><span class="line">t2.setDaemon(<span class="literal">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><h2 id="使用-Queue-使多线程编程更安全"><a href="#使用-Queue-使多线程编程更安全" class="headerlink" title="使用 Queue 使多线程编程更安全"></a>使用 Queue 使多线程编程更安全</h2><p>多线程编程不是件容易的事情。线程间的同步和互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。</p><p>Python 中的 Queue 模块提供了 3 种队列：</p><ul><li><p><code>Queue.Queue(maxsize)</code>：<strong>先进先出</strong>，maxsize 为队列大小，其值为非正数的时候为无限循环队列</p></li><li><p><code>Queue.LifoQueue(maxsize)</code>：<strong>后进先出，相当于栈</strong></p></li><li><p><code>Queue.PriorityQueue(maxsize)</code>：<strong>优先级队列</strong></p></li></ul><p>这 3 种队列支持以下方法：</p><ul><li><code>Queue.qsize()</code>：返回队列大小。</li><li><code>Queue.empty()</code>：队列为空的时候返回 True，否则返回 False</li><li><code>Queue.full()</code>：当设定了队列大小的情况下，如果队列满则返回 True，否则返回 False。</li><li><code>Queue.put(item[, block[, timeout]])</code>：往队列中添加元素 item，block 设置为 False 的时候，如果队列满则抛出 Full 异常。如果 block 设置为 True，timeout 为 None 的时候则会一直等待直到有空位置，否则会根据 timeout 的设定超时后抛出 Full 异常。</li><li><code>Queue.put_nowait(item)</code>：等于 <code>put(item, False).block</code> 设置为 False 的时候，如果队列空则抛出 Empty 异常。如果 block 设置为 True、timeout 为 None 的时候则会一直等到有元素可用，否则会根据 timeout 的设定超时后抛出 Empty 异常。</li><li><code>Queue.get([block[, timeout]])</code>：从队列中删除元素并返回该元素的值</li><li><code>Queue.get_nowait()</code>：等价于 <code>get(False)</code></li><li><code>Queue.task_done()</code>：发送信号表明入列任务已经完成，经常在消费者线程中用到</li><li><code>Queue.join()</code>：阻塞直至队列中所有的元素处理完毕</li></ul><p>Queue 模块是<strong>线程安全</strong>的。需要注意的是， Queue 模块中的队列和 collections.deque 所表示的队列并不一样，前者主要用于不同线程之间的通信，它内部实现了线程的锁机制；而后者主要是数据结构上的概念。</p><p>多线程下载的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            url = self.queue.get()    <span class="comment"># 从队列中取出一个 url 元素</span></span><br><span class="line">            print(self.name + <span class="string">"begin download"</span> + url + <span class="string">"..."</span>)</span><br><span class="line">            self.download_file(url)    <span class="comment"># 进行文件下载</span></span><br><span class="line">            self.queue.task_done()    <span class="comment"># 下载完毕发送信号</span></span><br><span class="line">            print(self.name + <span class="string">" download completed!!!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(self, url)</span>:</span>    <span class="comment"># 下载文件</span></span><br><span class="line">        urlhandler = urllib2.urlopen(url)</span><br><span class="line">        fname = os.path.basename(url) + <span class="string">".html"</span>    <span class="comment"># 文件名称</span></span><br><span class="line">        <span class="keyword">with</span> open(fname, <span class="string">"wb"</span>) <span class="keyword">as</span> f:    <span class="comment"># 打开文件</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                chunk = urlhandler.read(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                f.write(chunk)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [<span class="string">"https://www.createspace.com/3611970"</span>,<span class="string">"http://wiki.python.org/moni.WebProgramming"</span>]</span><br><span class="line">    queue = Queue.Queue()</span><br><span class="line">    <span class="comment"># create a thread pool and give them a queue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = DownloadThread(queue)    <span class="comment"># 启动 5 个线程同时进行下载</span></span><br><span class="line">        t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        t.start()</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># give the queue some data</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        queue.put(url)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># wait for the queue to finish</span></span><br><span class="line">    queue.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;/p&gt;
&lt;!-- &gt; 首发于公众号【Python与算法之路】 --&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（三）基础语法</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2020-04-14T06:14:55.000Z</published>
    <updated>2020-04-19T00:09:41.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。<br><!-- > 首发于公众号【Python与算法之路】 --></p></blockquote><a id="more"></a><h2 id="关于导入模块"><a href="#关于导入模块" class="headerlink" title="关于导入模块"></a>关于导入模块</h2><p>Python的3种引入外部模块的方式：<code>import</code>语句、<code>from ... import ...</code> 和 <code>__import__</code>函数。其中前两种比较常见。</p><p>在使用 <code>import</code> 时，应注意：</p><ul><li><strong>优先使用 <code>import A</code> 或 <code>import A as a</code></strong></li><li><strong>有节制的使用 <code>from A import B</code></strong></li><li><strong>尽量避免使用 <code>from A import *</code></strong></li></ul><p>对于 <code>from a import ...</code>，如果无节制的使用，会带来的问题：</p><ul><li>命名空间的冲突</li><li>循环嵌套导入的问题（两个文件相互导入对方的变量或函数或类）</li></ul><h2 id="i-1-不等于-i"><a href="#i-1-不等于-i" class="headerlink" title="i += 1 不等于 ++i"></a><code>i += 1</code> 不等于 <code>++i</code></h2><p>Python 解释器会将 <code>++i</code> 解释为 <code>+(+i)</code>，其中 <code>+</code> 表示正数符号。对于 <code>--i</code> 也是类似。</p><p>因此，要明白 <code>++i</code> 在 Python 的语法层面上是合法的，但并不是通常意义上的自增操作。</p><h2 id="使用-with-自动关闭资源"><a href="#使用-with-自动关闭资源" class="headerlink" title="使用 with 自动关闭资源"></a>使用 <code>with</code> 自动关闭资源</h2><p>对文件操作完成后，应该立即关闭它们，因为打开的文件不仅会占用系统资源，而且可能影响其他程序或者进程的操作，甚至会导致用户期望与实际操作结果不一致。</p><p>Python 提供了 with 语句，语法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 表达式 [<span class="keyword">as</span> 目标]:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>with 语句支持嵌套，支持多个 with 子句，它们两者可以相互转换。<code>with expr1 as e1, expr2 as e2</code>与下面的嵌套形式等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expr1 <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="keyword">with</span> expr2 <span class="keyword">as</span> e2:</span><br></pre></td></tr></table></figure><h2 id="使用-else-子句简化循环（异常处理）"><a href="#使用-else-子句简化循环（异常处理）" class="headerlink" title="使用 else 子句简化循环（异常处理）"></a>使用 <code>else</code> 子句简化循环（异常处理）</h2><p>在循环中， <code>else</code> 子句提供了隐含的对循环是否由 <code>break</code> 语句引发循环结束的判断。例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两段代码等价</span></span><br><span class="line"><span class="comment"># 借助了一个标志量 found 来判断循环结束是不是由 break 语句引起的。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            print(<span class="string">"&#123;&#125; is a prime number"</span>.format(i))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"&#123;&#125; is a prime number"</span>.format(i))</span><br></pre></td></tr></table></figure><p>当循环“自然”终结（循环条件为假）时 <code>else</code> 从句会被执行一次，而当循环是由 <code>break</code> 语句中断时，<code>else</code> 子句就不被执行。</p><p>与 <code>for</code> 语句相似，<code>while</code> 语句中的 <code>else</code> 子句的语意是一样的： <code>else</code> 块在循环正常结束和循环条件不成立时被执行。</p><h2 id="遵循异常处理的几点基本原则"><a href="#遵循异常处理的几点基本原则" class="headerlink" title="遵循异常处理的几点基本原则"></a>遵循异常处理的几点基本原则</h2><p>Python中常用的异常处理语法是<code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code>，它们可以有多种组合。语法形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this main action first</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name1 的异常时，进行处理</span></span><br><span class="line"><span class="keyword">except</span> &lt;name1&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name2 或 name3 中的某一个异常时</span></span><br><span class="line"><span class="keyword">except</span> (name2, name3):</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name4 的异常时处理，并获取对应实例</span></span><br><span class="line"><span class="keyword">except</span> &lt;name4&gt; <span class="keyword">as</span> &lt;data&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他异常时，进行处理</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常时，执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无论有没有异常，都执行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p>异常处理，通常需要遵循以下几点基本原则：</p><ul><li><strong>不推荐在 <code>try</code> 中放入过多的代码</strong>。在 try 中放入过多的代码带来的问题是如果程序中抛出异常，将会较难定位，给 debug 和修复带来不便，因此应尽量只在可能抛出异常的语句块前面放入 try 语句。</li><li>谨慎使用单独的 <code>except</code> 语句处理所有异常，<strong>最好能定位具体的异常</strong>。同样也不推荐使用 <code>except Exception</code> 或者 <code>except StandardError</code> 来捕获异常。如果必须使用，最好能够使用 <code>raise</code> 语句将异常抛出向上层传递。</li><li>注意异常捕获的顺序，在合适的层次处理异常。<ul><li>用户也可以继承自内建异常构建自己的异常类，从而在内建类的继承结构上进一步延伸。在这种情况下捕获异常的顺序显得非常重要。为了更精确地定位错误发生的原因，推荐的方法是将继承结构中子类异常在前面的 <code>except</code> 语句中抛出，而父类异常在后面的 <code>except</code> 语句抛出。这样做的原因是当 <code>try</code> 块中有异常发生的时候，解释器根据 <code>except</code> 声明的顺序进行匹配，在第一个匹配的地方便立即处理该异常。</li><li>异常捕获的顺序非常重要，同时异常应该在适当的位置被处理，一个原则就是<strong>如果异常能够在被捕获的位置被处理，那么应该及时处理，不能处理也应该以合适的方式向上层抛出。</strong>向上层传递的时候需要警惕异常被丢失的情况，可以使用不带参数的 raise 来传递。</li></ul></li><li>使用更为友好的异常信息，遵守异常参数的规范。通常来说有两类异常阅读者：使用软件的人和开发软件的人。</li></ul><h2 id="避免-finally-中可能发生的陷阱"><a href="#避免-finally-中可能发生的陷阱" class="headerlink" title="避免 finally 中可能发生的陷阱"></a>避免 finally 中可能发生的陷阱</h2><p>无论 <code>try</code> 语句中是否有异常抛出，<code>finally</code> 语句总会被执行。由于这个特性，<code>finally</code> 语句经常被用来做一些清理工作。<br>但使用 <code>finally</code> 时，也要特别小心一些陷阱。</p><ul><li>当 <code>try</code> 块中发生异常的时候，如果在 <code>except</code> 语句中找不到对应的异常处理，异常将会被临时保存起来，当 <code>finally</code> 执行完毕的时候，临时保存的异常将会再次被抛出，但如果 <code>finally</code> 语句中产生了新的异常或者执行了 <code>return</code> 或者 <code>break</code> 语句，那么临时保存的异常将会被丢失，从而导致异常屏蔽。</li><li>在实际应用程序开发过程中，并不推荐在 <code>finally</code> 中使用 <code>return</code> 语句进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。</li></ul><h2 id="深入理解-None，正确判断对象是否为空"><a href="#深入理解-None，正确判断对象是否为空" class="headerlink" title="深入理解 None，正确判断对象是否为空"></a>深入理解 None，正确判断对象是否为空</h2><p>Python 中以下数据会当作空来处理：</p><ul><li>常量 <code>None</code></li><li>常量 <code>False</code></li><li>任何形式的数值类型零，如 <code>0</code>、<code>0L</code>、<code>0.0</code>、<code>0j</code></li><li>空的序列，如 <code>&#39;&#39;</code>、<code>()</code>、<code>[]</code></li><li>空的字典，如 <code>{}</code></li><li>当用户定义的类中定义了 <code>__nonzero__()</code> 和 <code>__len__()</code> 方法，并且该方法返回整数 <code>0</code> 或 <code>False</code> 的时候。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list1 <span class="comment"># value is not empty</span></span><br><span class="line">    Do something</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># value is empty</span></span><br><span class="line">    Do some other thing</span><br></pre></td></tr></table></figure><ul><li>执行过程中会调用内部方法 <code>__nonzero__()</code> 来判断变量 <code>list1</code> 是否为空并返回其结果。</li></ul><blockquote><p>注： <code>__nonzero__()</code> 方法 —— 该内部方法用于对自身对象进行空值测试，返回 0/1 或 True/False。</p></blockquote><ul><li>如果一个对象没有定义该方法，Python 将获取 <code>__len__()</code> 方法调用的结果来进行判断。<code>__len__()</code> 返回值为 0 则表示为空。如果一个类中既没有定义 <code>__len__()</code> 方法也没有定义 <code>__nonzero__()</code> 方法，该类的实例用 if 判断的结果都为 True。</li></ul><h2 id="格式化字符串时尽量使用-format-方式而不是"><a href="#格式化字符串时尽量使用-format-方式而不是" class="headerlink" title="格式化字符串时尽量使用 .format 方式而不是 %"></a>格式化字符串时尽量使用 <code>.format</code> 方式而不是 <code>%</code></h2><p>推荐尽量使用 <code>format</code> 方式而不是 <code>%</code> 操作符来格式化字符串，理由：</p><ul><li><code>format</code> 方式在使用上较 <code>%</code> 操作符更为灵活。使用 <code>format</code> 方式时，参数的顺序与格式化的顺序不必完全相同</li><li><p><code>format</code> 方式可以方便的作为参数传递</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weather = [(<span class="string">"Monday"</span>, <span class="string">"rain"</span>), (<span class="string">"Tuesday"</span>, <span class="string">"sunny"</span>), (<span class="string">"Wednesday"</span>, <span class="string">"sunny"</span>), (<span class="string">"Thursday"</span>, <span class="string">"rain"</span>), (<span class="string">"Friday"</span>, <span class="string">"cloudy"</span>)]</span><br><span class="line">formatter = <span class="string">"Weather of '&#123;0[0]&#125;' is '&#123;0[1]&#125;'"</span>.format</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> map(formatter, weather):</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure></li><li><p><code>%</code> 最终会被 .format 方式所代替。根据 Python 的官方文档，之所以仍然保留 <code>%</code> 操作符是为了保持向后兼容</p></li><li><code>%</code> 方法在某些特殊情况下使用时需要特别小心，对于 <code>%</code> 直接格式化字符的这种形式，如果字符本身为元组，则需要使用在 <code>%</code> 使用 <code>(itemname,)</code> 这种形式才能避免错误，注意逗号。</li></ul><h2 id="区别对待可变对象和不可变对象"><a href="#区别对待可变对象和不可变对象" class="headerlink" title="区别对待可变对象和不可变对象"></a>区别对待可变对象和不可变对象</h2><p>Python 中一切皆对象，对象根据其值能否修改分为<strong>可变对象</strong>和<strong>不可变对象</strong>。</p><ul><li><p>不可变对象</p><ul><li>数字</li><li>字符串</li><li>元组</li></ul></li><li><p>可变对象</p><ul><li>字典</li><li>列表</li><li>字节数组</li></ul></li></ul><p>在将可变对象<strong>作为函数默认参数</strong>的时候要特别紧惕，<strong>对可变对象的更改会直接影响原对象。</strong></p><p>最好的方法是传入 <code>None</code> 作为默认参数，在创建对象的时候动态生成可变对象。</p><ul><li><p>对于一个可变对象，<strong>切片操作相当于浅拷贝。</strong></p></li><li><p>对于不可变对象，当我们对其进行相关操作的时候，Python 实际上<strong>仍然保持原来的值而且重新创建一个新的对象</strong>，所以字符串对象不允许以索引的方式进行赋值，当有两个对象同时指向一个字符串对象的时候，对其中一个对象的操作并不会影响另一个对象。</p></li></ul><h2 id="函数传参既不是传值也不是传引用"><a href="#函数传参既不是传值也不是传引用" class="headerlink" title="函数传参既不是传值也不是传引用"></a>函数传参既不是传值也不是传引用</h2><p>对于Python中函数的传参方法，<strong>既不是传值，也不是传引用</strong>。</p><p>正确的叫法应该是<strong>传对象</strong>（call by object）或者说<strong>传对象的引用</strong>（call-by-object-reference）。</p><p>函数参数在传递的过程中将整个对象传入，</p><ul><li>对于<strong>可变对象</strong>：它的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象</li><li>对于<strong>不可变对象</strong>：由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的</li></ul><h2 id="慎用变长参数"><a href="#慎用变长参数" class="headerlink" title="慎用变长参数"></a>慎用变长参数</h2><p>慎用可变长度参数<code>*args, **kwargs</code>，原因如下：</p><ul><li>使用过于灵活。变长参数意味着这个函数的签名不够清晰，存在多种调用方式。另外变长参数可能会破坏程序的健壮性。</li><li>如果一个函数的参数列表很长，虽然可以通过使用 <code>*args</code> 和 <code>**kwargs</code> 来简化函数的定义，但通常这个函数可以有更好的实现方式，应该被重构。例如可以直接传入元组和字典。</li></ul><p>可变长参数适合在下列情况下使用：</p><ul><li>为函数添加一个<strong>装饰器</strong></li><li>如果参数的数目不确定，可以考虑使用变长参数</li><li>用来实现函数的多态，或者在继承情况下子类需要调用父类的某些方法的时候</li></ul><h2 id="深入理解-str-和-repr-的区别"><a href="#深入理解-str-和-repr-的区别" class="headerlink" title="深入理解 str() 和 repr() 的区别"></a>深入理解 <code>str()</code> 和 <code>repr()</code> 的区别</h2><p>函数 <code>str()</code> 和 <code>repr()</code> 都可以将 Python 中的对象转换为字符串，两者的使用以及输出都非常相似。有以下几点区别：</p><ul><li><p>两者的目标不同：</p><ul><li><code>str()</code> 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型</li><li>而 <code>repr()</code> 面向开发人员，其目的是准确性，其返回值表示 Python 解释器内部的含义，常用作 debug</li></ul></li><li><p>在解释器中直接输入时默认调用 <code>repr()</code> 函数，而 <code>print</code> 则调用 <code>str()</code> 函数</p></li><li><code>repr()</code> 的返回值一般可以用 <code>eval()</code> 函数来还原对象。通常有如下等式：<code>obj == eval(repr(obj))</code></li><li>一般，类中都应该定义 <code>__repr__()</code> 方法，而 <code>__str__()</code> 方法则为可选，当可读性比准确性更为重要的时候应该考虑定义 <code>__str__()</code> 方法。如果类中没有定义 <code>__str__()</code> 方法，则默认会使用 <code>__repr__()</code> 方法的结果来返回对象的字符串表示形式。用户实现 <code>__repr__()</code> 方法的时，最好保证其返回值可以用 <code>eval()</code> 方法使对象重新还原。</li></ul><h2 id="分清静态方法和类方法的适用场景"><a href="#分清静态方法和类方法的适用场景" class="headerlink" title="分清静态方法和类方法的适用场景"></a>分清静态方法和类方法的适用场景</h2><p>静态方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg1, arg2, ...)</span>:</span></span><br></pre></td></tr></table></figure></p><p>类方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls, arg1, arg2, ...)</span>:</span></span><br></pre></td></tr></table></figure></p><p>都可以通过<code>类名.方法名</code>或者<code>实例.方法名</code>的形式来访问。</p><p>其中，静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数。</p><p><strong>类方法</strong></p><ul><li>在调用的时候没有显式声明 cls，但实际上类本身是作为隐藏参数传入的</li><li>类方法可以判断出自己是通过基类被调用，还是通过某个子类被调用</li><li>类方法通过子类调用时，可以返回子类的属性而非基类的属性</li><li>类方法通过子类调用时，可以调用子类的其他类方法</li></ul><p><strong>静态方法</strong></p><ul><li>既不跟特定的实例相关也不跟特定的类相关</li><li>静态方法定义在类中的原因是，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的可维护性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;br&gt;&lt;!-- &gt; 首发于公众号【Python与算法之路】 --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（二）编程惯用法</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E7%A8%8B%E6%83%AF%E7%94%A8%E6%B3%95.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E7%A8%8B%E6%83%AF%E7%94%A8%E6%B3%95.html</id>
    <published>2020-04-10T02:37:25.000Z</published>
    <updated>2020-04-11T13:05:39.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精炼汇总。</p></blockquote><a id="more"></a><h2 id="利用assert语句发现问题"><a href="#利用assert语句发现问题" class="headerlink" title="利用assert语句发现问题"></a>利用assert语句发现问题</h2><p>assert语句的基本语法如下：</p><p><code>assert expression1 [&quot;,&quot; expression2]</code></p><p>其中，<code>expression1</code>是判断语句，会返回True或False，当返回False时会引发AssertionError。<code>[]</code>中的内容表示是可选的，用来传递具体的异常信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> a == b, <span class="string">"a equals b"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: a equals b</span><br></pre></td></tr></table></figure><p>利用assert语句来发现程序中的问题。断言（assert）在很多语言中都存在，主要为调试程序服务，能够快速方便检查程序的异常或不恰当的输入。</p><p>要注意的是<strong>使用assert是有代价的，它会对性能产生一定的影响</strong>，可以不用尽量不用。</p><h2 id="两个变量进行数据交换"><a href="#两个变量进行数据交换" class="headerlink" title="两个变量进行数据交换"></a>两个变量进行数据交换</h2><p>变量进行数据交换值时，<strong>不推荐使用中间变量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交换x,y</span></span><br><span class="line"><span class="comment"># 使用中间变量</span></span><br><span class="line">temp = x</span><br><span class="line">x = y</span><br><span class="line">y = temp</span><br><span class="line"><span class="comment"># 不使用中间变量</span></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><p>第二种方法在内存中执行的顺序如下：</p><ul><li>先计算右边的表达式 y, x，在内存中创建元组（y, x），其标示符合值分别为 y、x 及其对应的值，其中 y 和 x 是在初始化时已经存在于内存中的对象。</li><li>通过解包操作（unpacking），元组第一标识符（为 y）分配给左边第一个元素（此时为 x），元组第二个标识符（为 x）分配给左边第二个元素（为 y），从而达到实现 x、y 值交换的目的。</li></ul><h2 id="充分利用Lazy-evaluation的特性"><a href="#充分利用Lazy-evaluation的特性" class="headerlink" title="充分利用Lazy evaluation的特性"></a>充分利用Lazy evaluation的特性</h2><p>Lazy evaluation 常被译为“延迟计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。</p><ul><li><strong>避免不必要的计算，带来性能上的提升</strong>。对于 Python 中的条件表达式 if x and y，在 x 为 false 的情况下 y 表达式的值将不再计算。而对于 if x or y，当 x 的值为 true 的时候将直接返回，不再计算 y 的值。</li><li>节省空间，使得无限循环的数据结构成为可能。Python 中最典型的使用延迟计算的例子就是<strong>生成器表达式</strong>了。比如斐波那契：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">print(list(islice(fib(), <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><h2 id="不推荐使用type来进行类型检查"><a href="#不推荐使用type来进行类型检查" class="headerlink" title="不推荐使用type来进行类型检查"></a>不推荐使用type来进行类型检查</h2><p>内建函数 type(object) 用于返回当前对象的类型。可以通过与 Python 自带模块 types 中所定义的名称进行比较，根据其返回值确定变量类型是否符合要求。</p><p>所有<strong>基本类型</strong>对应的名称都可以在 types 模块中找到，然而<strong>使用 type() 函数并不适合用来进行变量类型检查</strong>。这是因为：</p><ul><li>基于内建类型扩展的用户自定义类型，type 函数并不能准确返回结果</li><li>在古典类中，所有类的实例的 type 值都相等</li></ul><p>解决方法是，如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，否则<strong>可以使用 isinstance() 函数来检测</strong>。</p><p><code>isinstance(object, classinfo)</code></p><p>其中，classinfo 可以为直接或间接类名、基本类型名称或者由它们组成的元组，该函数在 classinfo 参数错误的情况下会抛出 TypeError 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># isinstance 基本用法举例如下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">2</span>, float)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"a"</span>, (str, unicode))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">2</span>, <span class="number">3</span>), (str, list, tuple)) <span class="comment"># 支持多种类型列表</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="警惕eval-的安全漏洞"><a href="#警惕eval-的安全漏洞" class="headerlink" title="警惕eval()的安全漏洞"></a>警惕eval()的安全漏洞</h2><p>Python中<code>eval()</code>函数将字符串当成有效的表达式来求值并返回计算结果。其函数声明如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><br>其中，参数 globals 为字典形式，locals 为任何映射对象，它们分别表示全局和局部命名空间。如果传入 globals 参数的字典中缺少 <strong>builtins</strong> 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。locals 参数默认与 globals 相同，如果两者都省略的话，表达式将在 eval() 调用的环境中执行。</p><p>eval 存在安全漏洞，一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExpCalcBot</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Your answer is"</span>, eval(user_func) <span class="comment"># 计算输入的值</span></span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The expression you enter is not valid"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hi, I am ExpCalcBot. please input your expression or enter e to end'</span></span><br><span class="line">inputstr = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Please enter a number or operation. Enter c to complete. :'</span></span><br><span class="line">    inputstr = raw_input()</span><br><span class="line">    <span class="keyword">if</span> inputstr == str(<span class="string">'e'</span>): <span class="comment"># 遇到输入为 e 的时候退出</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">elif</span> repr(inputstr) != repr(<span class="string">''</span>):</span><br><span class="line">        ExpCalcBot(inputstr)</span><br><span class="line">        inputstr = <span class="string">''</span></span><br></pre></td></tr></table></figure><p>由于网络环境下运行它的用户并非都是可信任的，比如输入 <code>__import__(&quot;os&quot;).system(&quot;dir&quot;)</code>，会显示当前目录下的所有文件列表；<strong>如果恶意输入<code>__import__(&quot;os&quot;).system(&quot;del * /Q&quot;)</code>，会导致当前目录下的所有文件都被删除了，而这一切没有任何提示。</strong></p><p>在 globals 参数中禁止全局命名空间的访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExpCalcBot</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        math_fun_list = [<span class="string">"acos"</span>, <span class="string">"asin"</span>, <span class="string">"atan"</span>, <span class="string">"cos"</span>, <span class="string">"e"</span>, <span class="string">"log"</span>, <span class="string">"log10"</span>, <span class="string">"pi"</span>, <span class="string">"pow"</span>, <span class="string">"sin"</span>, <span class="string">"sqrt"</span>, <span class="string">"tan"</span>]</span><br><span class="line">        math_fun_dict = dict([(k, globals().get(k)) <span class="keyword">for</span> k <span class="keyword">in</span> math_fun_list]) <span class="comment"># 形成可以访问的函数的字典</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Your name is"</span>, eval(string, &#123;<span class="string">"__builtins__"</span>: <span class="literal">None</span>&#125;, math_fun_dict)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The expression you enter is not valid"</span></span><br></pre></td></tr></table></figure></p><p>再次进行恶意输入：<code>[c for c in ().__class__.__bases__[0].__subclasses__() if c.__name__ == &quot;Quitter&quot;][0](0)()</code>，</p><p><code># ().__class__.__bases__[0].__subclasses__()</code> 用来显示 object 类的所有子类。类 Quitter 与 “quit” 功能绑定，因此上面的输入会导致程序退出。</p><p><strong>对于有经验的侵入者来说，他可能会有一系列强大的手段，使得 eval 可以解释和调用这些方法，带来更大的破坏</strong>。此外，eval() 函数也给程序的调试带来一定困难，要查看 eval() 里面表达式具体的执行过程很难。因此在实际应用过程中如果使用对象不是信任源，<strong>应该避免使用 eval，在需要使用 eval 的地方可用安全性更好的<code>ast.literal_eval</code>替代。</strong></p><h2 id="使用enumerate-获取序列迭代的索引和值"><a href="#使用enumerate-获取序列迭代的索引和值" class="headerlink" title="使用enumerate()获取序列迭代的索引和值"></a>使用enumerate()获取序列迭代的索引和值</h2><p>使用函数 enumerate()，主要是为了解决在循环中获取索引以及对应值的问题。它具有一定的惰性（lazy），每次只在需要的时候才会产生一个（index, item）对。函数签名如下：</p><p><code>enumerate(sequence, start=0)</code></p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 enumerate() 获取序列迭代的索引和值</span></span><br><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(li):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, e)</span><br></pre></td></tr></table></figure></p><h2 id="区分-与is的适用场景"><a href="#区分-与is的适用场景" class="headerlink" title="区分==与is的适用场景"></a>区分==与is的适用场景</h2><ul><li><p><code>==</code>：用来检验两个对象的<strong>值</strong>是否相等的。它实际调用内部 <code>__eq__()</code> 方法，因此 <code>a == b</code> 相当于 <code>a.__eq__(b)</code>。</p></li><li><p><code>is</code>：用来<strong>比较两个对象在内存中是否拥有同一块内存空间</strong>。仅当 x 和 y 是同一个对象的时候才返回 True，<code>x is b</code> 基本相当于 <code>id(x) == id(y)</code>。</p></li></ul><p><code>==</code> 操作符也是可以被重载的，而 <code>is</code> 不能被重载。一般情况下，如果 <code>x is y</code> 为 True ， <code>x == y</code> 的值一般也为 True（特殊情况除外，如 <code>NaN</code>，<code>a = float(&#39;NaN&#39;)</code>，<code>a is a</code> 为 True，<code>a == a</code> 为 false）。</p><h2 id="构建合理的包层次来管理模块"><a href="#构建合理的包层次来管理模块" class="headerlink" title="构建合理的包层次来管理模块"></a>构建合理的包层次来管理模块</h2><p>每一个 Python 文件都可以看成一个模块（module），使用模块可以增强代码的可维护性和可重用性。</p><p><strong>包即是目录</strong>，但与普通目录不同，它除了包含常规的 Python 文件（也就是模块）以外，还<strong>包含一个 <code>__init__.py</code> 文件，同时它允许嵌套</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Package/<span class="module-access"><span class="module"><span class="identifier">__init__</span>.</span></span>py</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Module1</span>.</span></span>py</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Module2</span>.</span></span>py</span><br><span class="line">    Subpackage/<span class="module-access"><span class="module"><span class="identifier">__init__</span>.</span></span>py</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Module1</span>.</span></span>py</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Module2</span>.</span></span>py</span><br></pre></td></tr></table></figure><p>包中的模块可以通过”.”访问符进行访问，即”包名.模块名”。有以下几种导入方法：</p><ul><li><p>直接导入一个包：</p><p><code>import Package</code></p></li><li><p>导入子模块或子包，包嵌套的情况下可以进行嵌套导入：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Package <span class="keyword">import</span> Module1</span><br><span class="line"><span class="keyword">import</span> Package.Module1</span><br><span class="line"><span class="keyword">from</span> Package <span class="keyword">import</span> Subpackage</span><br><span class="line"><span class="keyword">import</span> Package.Subpackage</span><br><span class="line"><span class="keyword">from</span> Package.Subpackage <span class="keyword">import</span> Module1</span><br><span class="line"><span class="keyword">import</span> Package.Subpackage.Module1</span><br></pre></td></tr></table></figure></li></ul><p><code>__init__.py</code> 的作用：</p><ul><li>使包和普通目录区分</li><li>可以在该文件中申明模块级别的 import 语句，从而使其变成包级别可见</li></ul><p>如果 <code>__init__.py</code> 文件为空，当意图使用 <code>from Package import *</code> 将包 Package 中所有的模块导入当前名字空间时，并不能使得导入的模块生效，这是因为不同平台间的文件的命名规则不同，Python 解释器并不能正确判定模块在对应的平台该如何导入，因此仅仅执行 <code>__init__.py</code> 文件，<strong>如果要控制模块的导入，则需要对 <code>__init__.py</code> 文件做修改。</strong></p><p><code>__init__.py</code> 文件还有一个作用就是通过在该文件中定义 <code>__all__</code> 变量，控制需要导入的子包或者模块。之后再运行 <code>from ... import *</code>，可以看到 <code>__all__</code> 变量中定义的模块和包被导入当前名字空间。</p><p>包的使用能够带来以下便利：</p><ul><li>合理组织代码，便于维护和使用</li><li>能够有效地避免名称空间冲突</li></ul><p>如果模块包含的属性和方法存在同名冲突，使用 <code>import module</code> <strong>可以有效地避免名称冲突</strong>。在嵌套的包结构中，每一个模块都以其所在的完整路径作为其前缀，因此，即使名称一样，但由于模块所对应的其前缀不同，就不会产生冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精炼汇总。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（一）引论</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%AE%BA.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%AE%BA.html</id>
    <published>2020-04-09T17:45:35.000Z</published>
    <updated>2020-04-22T14:10:54.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。</p></blockquote><a id="more"></a><h1 id="理解Pythonic概念"><a href="#理解Pythonic概念" class="headerlink" title="理解Pythonic概念"></a>理解Pythonic概念</h1><ul><li><p>什么是 Pythonic？</p><p>Pythonic的代码就是具有Python独特风格的代码。通俗说来，就是在保证代码可读性的前提下，尽可能地简洁、优雅，看起来像伪代码一样。</p></li><li><p>具有 Python 代码风格的例子</p><ul><li><strong>交换两个变量</strong>。其他语言交换两个变量时，一般需要一个临时的中间变量，而Python中可以用一行代码直接交换。</li><li><strong>for循环直接遍历容器</strong>。其他语言中，需要根据索引下标i对容器进行遍历，而Python可以用for循环直接遍历容器。</li><li><strong>使用 <code>str.format()</code> 格式化字符串</strong>，是最Pythonic的字符串格式化方法。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交换两个变量</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环遍历容器</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> alist:</span><br><span class="line">    do_sth_with(elem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># format格式化字符串</span></span><br><span class="line">print(<span class="string">"&#123;greet&#125; from &#123;language&#125;!"</span>.format(greet=<span class="string">"hello, world!"</span>, language=<span class="string">"Python"</span>))</span><br></pre></td></tr></table></figure><ul><li>Python的库和框架：现有的框架就好比现有的“轮子”，学会利用这些框架，不重复造轮子。</li></ul><h1 id="编写Pythonic代码"><a href="#编写Pythonic代码" class="headerlink" title="编写Pythonic代码"></a>编写Pythonic代码</h1><p>注意要避免的事：</p><ul><li>避免只用大小写来区分不同的对象。</li><li>避免使用容易混淆的名称。</li><li>不要害怕过长的变量名。能表达清楚变量代表的含义即可。</li></ul><p>深入理解Pythonic的几个途径：</p><ul><li>学习语言特性和库特性时，<strong>从官方文档入手，</strong> 仿照他们的书写规范。</li><li>Python的版本更新快，跟进前言，掌握新特性。</li><li>学习业界公认的Pythonic代码，如Flask、gevent和requests等。</li></ul><h1 id="理解Python和C语言的不同之处"><a href="#理解Python和C语言的不同之处" class="headerlink" title="理解Python和C语言的不同之处"></a>理解Python和C语言的不同之处</h1><ul><li><strong>“缩进”和“{}”：</strong> C语言用花括号<code>{}</code>分隔代码块，Python中用缩进分隔，避免混用空格和Tab键。</li><li><strong><code>&#39;</code>与<code>&quot;</code>：</strong> 在C语言中，单引号<code>&#39;</code>表示单个的字符型数据(char)，双引号<code>&quot;</code>表示字符串，默认以<code>\0</code>结尾；在Python中，<code>&#39;</code>和<code>&quot;</code>无明显区别。</li><li><strong>三元操作符<code>?:</code>：</strong> C语言中的三元操作符 <code>C?X:Y</code>，表示当条件C为True的时候，取值X，否则取值Y。在Python中的等价形式为 <code>X if C else Y</code>。</li><li><strong>switch…case：</strong> C语言中的<code>switch...case</code>分支语句，Python中可以使用<code>if...elif...else...</code>代替。</li></ul><h1 id="在代码中添加注释"><a href="#在代码中添加注释" class="headerlink" title="在代码中添加注释"></a>在代码中添加注释</h1><p>Python中有3种形式注释：</p><ul><li>块注释</li><li>行注释</li><li>文档注释(dostring)</li></ul><p>需要注意：</p><ol><li>使用块或行注释时，仅仅注释那些复杂操作、算法，还有那些难以理解的、不够一目了然的代码。</li><li>注释和代码隔开一定距离。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>  <span class="comment"># 这样的注释略近</span></span><br><span class="line">x = x + <span class="number">1</span>       <span class="comment"># 更好的注释位置</span></span><br></pre></td></tr></table></figure><ol><li>给外部可访问的函数或方法添加文档注释。描述其功能、参数、返回值及可能的异常等信息。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span><span class="params">(name, lines)</span>:</span></span><br><span class="line">    <span class="string">"""Return lines that begin with name.</span></span><br><span class="line"><span class="string">    Lines are expected to look like:</span></span><br><span class="line"><span class="string">        name: space separated values</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name: string, parameter name.</span></span><br><span class="line"><span class="string">        lines: iterable of string, lines in the file.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List of values in the lines that match.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    retval = []</span><br><span class="line">    matches = itertools.ifilter(<span class="keyword">lambda</span> x: x.startswith(name + <span class="string">":"</span>), lines)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> matches:</span><br><span class="line">        retval.extend(line[len(name) + <span class="number">1</span> :].split())</span><br><span class="line">    <span class="keyword">return</span> retval</span><br></pre></td></tr></table></figure><ol><li>建议在文件头包含copyright声明、模块描述，有必要的话还可以加入作者信息。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright 2014 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"># you may not ...</span></span><br></pre></td></tr></table></figure><ol><li>更新代码之后，注释要和代码同步更新。在实际工作中，很容易发生代码不断迭代，而忘了更新注释的情况，需要加以小心。</li></ol><h1 id="适当添加空行，使代码布局更优雅、合理"><a href="#适当添加空行，使代码布局更优雅、合理" class="headerlink" title="适当添加空行，使代码布局更优雅、合理"></a>适当添加空行，使代码布局更优雅、合理</h1><ol><li>在一组代码表达完一个完整思路之后，应用空行进行分隔。</li><li><strong>保持上下文语义的易理解性。</strong> 当一个函数调用另一个函数时，尽量将它们放在一起，一般<strong>调用者在上，被调用者在下。</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    B()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ol><li><strong>空格的使用</strong><ul><li>二元运算符（赋值<code>=</code>，比较（<code>==, &lt;, &gt;, !=, &lt;=, &gt;=, in, not in, is, is not</code>），布尔运算（<code>and, or, not</code>））的左右两边。如<code>x == 1</code></li><li>逗号和分号前不要使用空格。</li><li>函数名和左括号之间、序列索引操作时序列名和<code>[]</code>之间不需要空格，函数的参数<code>=</code>两侧不需要空格。</li></ul></li></ol><h1 id="编写函数的4个原则"><a href="#编写函数的4个原则" class="headerlink" title="编写函数的4个原则"></a>编写函数的4个原则</h1><ol><li>函数设计尽量短小，嵌套层次不宜过深。</li><li>函数声明需合理、简单、易于使用。</li><li>函数参数设计时，应考虑向下兼容（<strong>兼容之前的版本</strong>）。</li><li>一个函数只做一件事（<strong>解耦合</strong>）。</li></ol><hr><ul><li>参考：《编写高质量代码——改善Python程序的91个建议》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Blender学习资料</title>
    <link href="http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html"/>
    <id>http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html</id>
    <published>2020-03-10T03:51:23.000Z</published>
    <updated>2020-03-10T13:15:45.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender是什么？"><a href="#Blender是什么？" class="headerlink" title="Blender是什么？"></a>Blender是什么？</h1><blockquote><p>摘自官方手册：<br>Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括<strong>建模、渲染、动画&amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟</strong>。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且<strong>可通过Python脚本来自定义界面</strong>)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。</p></blockquote><a id="more"></a><p>可以看出，Blender的功能很强大，从3D图形到视频，它都能搞。</p><p>博主之前对3D建模软件完全不了解，仅仅是听说过3DMax、Maya这些名字而已。在查阅了一些资料后，发现这种3D建模软件还是适合设计类专业的同学进行系统学习。</p><p>在查资料的过程中，发现这个软件有很多优秀的特点，包括：</p><ul><li><strong>跨平台</strong>： 对Linux用户很友好</li><li><strong>开源</strong>： 基于社区的开源项目，很吊，更新迭代快，完善速度快</li><li><strong>插件</strong>： 可以想象很多大牛会在这搞一些“骚操作”插件</li><li><strong>有Python API</strong>： 这就更骚了，会写代码的话，建模效率岂不是飞起？</li></ul><p>其实博主个人对3D建模、设计什么的不是很感兴趣，所以就学习下基本的操作和Python的调用，也是因为之前师兄说Blender中可以用Python对3D模型处理，之后可能会用得上吧。</p><h1 id="学习资料和社区"><a href="#学习资料和社区" class="headerlink" title="学习资料和社区"></a>学习资料和社区</h1><ul><li><a href="https://www.blendercn.org/" target="_blank" rel="external nofollow noopener noreferrer">Blender中国社区</a>: 国内Blender资料最全的社区。包括视频教程、中文文档、论坛等。</li><li><a href="https://docs.blender.org/manual/zh-hans/dev/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.83 参考手册</a></li><li><a href="https://docs.blender.org/api/current/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.82 Python API Documentation</a></li><li><a href="https://www.bilibili.com/video/av17804799/" target="_blank" rel="external nofollow noopener noreferrer">Blender官方入门教程（中文）B站</a>: 每个视频极短，适合小白入门，</li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>众所周知，无论是玩什么软件，掌握快捷键都能<strong>极大程度地提高工作效率</strong>。</p><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><ul><li>停止当前操作：【ESC】</li><li>快捷搜索：【SPACE】</li><li>撤销：【Ctrl】+【z】</li><li>重做：【Ctrl】+【shift】+【z】</li><li>渲染：【F12】</li><li>单选：【鼠标右键】（RMB）</li><li>全选：【A】</li><li>框选：【B】</li><li>刷选：【C】</li><li>套选：【Ctrl】+【鼠标左键】（LMB）</li><li>删除：【X】/【Delete】</li><li>复制：【Shift】+【D】</li><li>添加：【Shift】+【A】</li><li>取消：【Esc】/【RMB】</li><li>确认：【Return】/【LMB】</li></ul><h2 id="界面操作"><a href="#界面操作" class="headerlink" title="界面操作"></a>界面操作</h2><ul><li>工具栏位置对称切换：【F5】</li><li>固定/解固定工具栏：【SHIFT】+【LMB】</li><li>放大/缩小：【SHIFT】+【SPACE】</li><li>放大/缩小：【Ctrl】+【UP】/【Ctrl】+【DOWN】</li><li>移动视窗：【SHIFT】+【鼠标滚轮】</li><li>旋转视窗：【鼠标滚轮】</li><li>3DView：【SHIFT】+【F5】</li><li>UVEditorView：【SHIFT】+【F10】</li></ul><h2 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h2><ul><li>透视开启/关闭：【5】</li><li>前视图（+Ctrl后视图）：【1】</li><li>右视图（+Ctrl左视图）：【2】</li><li>顶视图（+Ctrl底视图）：【7】</li><li>摄像机视角（如果有摄像机）：【0】</li><li>将当前视图设为摄像机视角：【Ctrl】+【alt】+【0】</li><li>全屏显示当前视图：【Ctrl】+【up】</li><li>显示选中目标：小键盘【del】</li><li>显示所有目标：【Home】</li><li>场景平移：【Shift】+【鼠标中键】</li><li>场景缩放：【Ctrl】+【鼠标中键】（或者【滚轮】）</li></ul><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><ul><li>编辑模式：【Tab】</li><li>点线面三模式切换（编辑模式下）：【Tab】+【Ctrl】</li><li>加选/减选：【Ctrl】+【小键盘+/-】（可定义为【PageUP】，【PageDown】）</li><li>选择循环点/边/面：【Alt】+【LMB】</li><li>线框模式：【Z】</li><li>隐藏选中目标：【H】</li><li>显示所有隐藏目标：【Alt】+【H】</li></ul><h2 id="选中目标状态下"><a href="#选中目标状态下" class="headerlink" title="选中目标状态下"></a>选中目标状态下</h2><ul><li>挤出：【E】+【LMB】（挤出到鼠标位置）</li><li>移动：【G】</li><li>旋转：【R】</li><li>缩放：【S】(以上操作再按下X、Y、Z以固定轴向、轴心活动）</li><li>内插面：【i】</li><li>顶点/边滑移：【GG】</li><li>环切：【Ctrl】+【R】</li><li>边线折痕：【Shift】+【E】</li><li>快捷拓展命令栏：【W】</li><li>切割：【K】</li><li>分割：【Y】</li><li>分离（单独个体）：【P】</li><li>合并：【Ctrl】+【J】</li><li>倒角：【Ctrl】+【B】</li><li>球形化：【Shift】+【Alt】+【S】</li><li>关联选取：【L】</li><li>相似选取：【Shift】+【G】</li><li>创建父级：【Ctrl】+【P】</li><li>清除父级：【Alt】+【P】</li><li>吸附：【Shift】+【S】</li></ul><h2 id="节点编辑器"><a href="#节点编辑器" class="headerlink" title="节点编辑器"></a>节点编辑器</h2><ul><li>连接节点：【F】（选取两个目标）</li><li>断开节点：【Ctrl】+【LMB】（划掉连接线）</li><li>添加转接点：【Shift】+【LMB】（划掉连接线）</li><li>合并节点：【Ctrl】+【J】</li><li>断开选中节点：【Alt】+【D】</li><li>移动背景视图：【Alt】+【鼠标滚轮】</li><li>显示激活节点：小键盘【del】</li><li>显示所有节点：【Home】</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li>删除动画关键帧在信息清单视图：（DopeSheet）中按【B】框选按【X】删除选中的keyframes</li><li>插入一个关键帧（keyframe）：【I】</li><li>清除该关键帧：【Alt】-【I】</li><li>清空所有关键帧（删除所有的F-Curves）：【Alt】-【Shift】-【I】</li><li>assignadriver：【D】</li><li>clearthedriver：【Alt】-【D】</li><li>addaKeyingSet：【K】</li><li>cleartheKeyingSet：【Alt】-【K】</li><li>清除posemode下的旋转：【Alt】+【R】</li><li>清除posemode下的缩放：【Alt】+【S】</li><li>清楚posemode下的位移：【Alt】+【G】</li></ul><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><ul><li>到文本开始处：【Home】</li><li>到文本结束处：【End】</li><li>拷贝文本：【Ctrl】-【C】</li><li>粘贴文本：【Ctrl】-【V】</li><li>选择所有文本：【Ctrl】-【A】</li></ul><h2 id="数字调整"><a href="#数字调整" class="headerlink" title="数字调整"></a>数字调整</h2><ul><li>拖动时捕捉离散步骤：【Ctrl】</li><li>更高的调整精度：【Shift】</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>编辑模式下，弹出边编辑菜单，其中有UV映射常用的seem（缝边）功能：【Ctrl】+【E】</li><li>合并物体：【Ctrl】+【J】</li><li>分离物体：【P】</li><li>把选中的两个相邻三角形合并成四边形（quads）：【ALT】+【J】</li><li>吸附游标到选择点：【SHIFT】+【S】</li><li>撕开所选边：【V】</li><li>撕开所选边并填充：【ALT】+【V】</li><li>编辑模式下，合并选中的2个节点：【ALT】+【M】</li><li>打开吸附模式：【SHIFT】+【TAB】</li><li>打开点线面选择模式选取菜单：【Ctrl】+【TAB】</li><li>在EditMode下，将选中的表面变成三角面：【Ctrl】+【T】</li><li>环切loopcut：【Ctrl】+【R】</li><li>多个环切：【再按住鼠标滚轮上下滚动】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Blender是什么？&quot;&gt;&lt;a href=&quot;#Blender是什么？&quot; class=&quot;headerlink&quot; title=&quot;Blender是什么？&quot;&gt;&lt;/a&gt;Blender是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;摘自官方手册：&lt;br&gt;Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括&lt;strong&gt;建模、渲染、动画&amp;amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟&lt;/strong&gt;。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且&lt;strong&gt;可通过Python脚本来自定义界面&lt;/strong&gt;)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://monteyang.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Blender" scheme="http://monteyang.cn/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>Python-for循环的内部机制</title>
    <link href="http://monteyang.cn/Python-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.html"/>
    <id>http://monteyang.cn/Python-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.html</id>
    <published>2020-03-02T06:36:24.000Z</published>
    <updated>2020-03-31T08:23:05.631Z</updated>
    
    <content type="html"><![CDATA[<p>Python中，使用for循环可以迭代容器对象中的元素，这里容器对象包括是列表（list）、元组（tuple）、字典（dict）、集合（set）等。但是，为什么这些对象可以使用for循环进行操作呢？</p><a id="more"></a><p>首先，定义一个简单的类尝试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> TestRange(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'TestRange'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br></pre></td></tr></table></figure></p><p>错误信息提示，’TestRange’ object 不是可迭代的对象。那么，什么才是可迭代的对象呢？</p><p>在可迭代的对象中，需要实现一个<code>__iter__</code>魔法方法，而且这个方法的返回值需要是一个迭代器。那么，什么是迭代器呢？</p><p>迭代器只需要实现<code>__next__</code>魔法方法。</p><p>以列表（list）为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">13</span>,<span class="number">12</span>,<span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret = nums.__iter__() <span class="comment"># x有此方法，说明list是可迭代的，而且该方法返回一个迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret</span><br><span class="line">&lt;list_iterator object at <span class="number">0x100f32198</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>如上所示，列表nums中实现了<code>__iter__</code>方法，而且返回一个迭代器（iterator），迭代器中实现了<code>__next__</code>方法。在不断调用<code>__next__</code>的过程中，就是在不断返回nums中的元素，直到出现<code>StopIteration</code>的错误。</p></blockquote><p>其实，for语句的作用与此类似。<strong>for语句的内部机制为</strong>：</p><ul><li>先判断对象是否为可迭代对象，即是否存在<code>__iter__</code>方法，如果存在则调用<code>__iter__</code>方法，返回一个迭代器；否则，直接抛出TypeError异常；</li><li>不断地调用迭代器的<code>__next__</code>方法，每次调用按顺序迭代获取当前的值；</li><li>迭代完所有元素，就抛出异常 StopIteration，这个异常 python 解释器自己会处理；</li></ul><p>前面的 TestRange 报错是因为它没有实现迭代器协议里面的这两个方法，现在继续改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _max)</span>:</span></span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line">        self._max = _max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.i &lt; self._max:</span><br><span class="line">            i = self.i</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 达到停止条件时，抛出此异常</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行测试</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> TestRange(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>因为这个类中，已经实现了<code>__next__</code>方法，所以基于这个类所创建的对象，本身就是一个迭代器。又因为可迭代对象需要有<code>__iter__</code>方法，而且返回一个迭代器，所以<code>__iter__</code>返回对象本身<code>self</code>即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中，使用for循环可以迭代容器对象中的元素，这里容器对象包括是列表（list）、元组（tuple）、字典（dict）、集合（set）等。但是，为什么这些对象可以使用for循环进行操作呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树</title>
    <link href="http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html"/>
    <id>http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html</id>
    <published>2020-02-22T06:49:11.000Z</published>
    <updated>2020-03-05T12:20:34.682Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="../images/机器学习-决策树.png" alt></p><hr><a id="more"></a><h1 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h1><p>从根节点开始，在每一个节点进行决策，最终走到叶子节点。既可以做<strong>分类</strong>，也可以做<strong>回归</strong>。</p><p>优点：可读性强，分类速度快。</p><p>通常，决策树学习分为三步： <strong>特征选择</strong>、<strong>决策树生成（构建）</strong>和<strong>决策树的剪枝</strong>。</p><blockquote><p><strong>难点在于决策树的构建</strong>。当构建好决策树后，利用其进行测试，对数据进行分类或回归都是十分简单的。</p></blockquote><h1 id="树的组成"><a href="#树的组成" class="headerlink" title="树的组成"></a>树的组成</h1><ul><li>根节点： 第一个判断条件的节点</li><li>非叶子结点： 中间的过程</li><li>叶子节点： 得到最终的决策结果</li></ul><p>决策树中的每个节点（特征）相当于在数据中切一刀，如果候选的特征越多，切的次数越多。</p><h1 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h1><p>决策树的训练过程就是<strong>决策树的生成</strong>，从给定数据集，构造出一课树。</p><p>从根节点开始选择特征，考虑如何进行特征切分。</p><blockquote><p>从根节点到下面的节点，如何进行选择和切分？</p></blockquote><p>思路： 从根节点到下面的节点所对应的特征，应该依次是从分类效果最好到不好。</p><p>因此，目标： 通过一种衡量标准，计算不同特征进行分支选择后的分类情况，衡量特征的分类效果，找出最好的特征当作根节点，以此类推。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>熵：<strong>表示随机变量不确定性的度量。不确定性越强，熵值越高</strong>。</p><p>假设 $X$ 是一个具有有限个值的离散型随机变量，服从如下的概率分布：</p><script type="math/tex; mode=display">P(X=x_i)=p_i,\qquad i=1,2,\cdots,n</script><p>则，随机变量$X$的熵定义为：</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np_i log p_i \quad (2)</script><p>假设 X 服从如下分布：</p><script type="math/tex; mode=display">P(X=1)=p，P(X=0)=1-p，0 \le p \le 1</script><p>于是根据 <strong>公式（2）</strong> 得到它的熵为：</p><script type="math/tex; mode=display">H(p)=-p\log_2p-(1-p)\log_2(1-p)</script><p><img data-src="../images/机器学习-决策树-熵.png" alt></p><p>概率和熵值大小的关系：</p><ul><li>当 p=0或1 时，H(p)=0，随机变量没有不确定性</li><li>当 p=0.5 时，H(p)=1，随机变量的不确定性最大</li></ul><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>设随机变量 $(X,Y)$ 的<strong>联合概率分布</strong>为：</p><script type="math/tex; mode=display">P(X=x_i,Y=y_j)=p_{ij},\quad i=1,2,\cdots,n;\quad j=1,2,\cdots ,m</script><p><strong>条件熵 $H(Y|X)$</strong> 表示在已知随机变量 $X$ 的取值条件下，随机变量 $Y$ 的不确定性。</p><p>其数学定义为：$X$ 给定的条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望，</p><script type="math/tex; mode=display">H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)</script><p>其中，$p_i=P(X=x_i),\quad i=1,2,\cdots,n$</p><p>在此基础上，引出<strong>信息增益</strong>（Information Gain），它<strong>表示在特征 $X$ 给定的条件下，而使得类 $Y$ 的信息不确定性减少的程度</strong>。数学精确表述如下：特征 $A$ 对训练数据集 $D$ 的<strong>信息增益 $G(D,A)$</strong> 定义为集合 $D$ 的熵 $H(D)$ 与特征 $A$ 给定的条件下 $D$ 的条件熵 $H(D | A)$ 之差，即：</p><script type="math/tex; mode=display">G(D,A)=H(D)-H(D|A)</script><p>决策树学习应用信息增益准则选择特征。给定训练数据集 $D$ 和特征 $A$。熵 $H(D)$ 表示对数据集 $D$ 进行分类的不确定性，而条件熵 $H(D|A)$ 表示在特征 $A$ 给定的条件下对数据集 $D$ 进行分类的不确定性。而他们的差，即信息增益就表示由于特征 $A$ 给定的情况下而使得对数据集 $D$ 进行分类的不确定性减少的程度。显然，对于数据集 $D$ 而言，信息增益依赖于特征。一般情况下，不同的特征具有不同的信息增益。<strong>信息增益大的特征具有更强的分类能力。</strong></p><p>由以上的表述，我们应该清楚地知道，决策树构建过程中，我们应该选择信息增益最大的特征进行分裂构建。</p><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>ID3算法的核心是递归的构建决策树，递归的过程中，在每个节点上，计算信息增益选择特征，直至满足递归停止条件（所有特征的信息增益都很小或者没有特征可以选择）。</p><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>C4.5 算法和 ID3 算法基本上完全一致，只是特征选择时的选择方法将信息增益换成<strong>信息增益比</strong>。</p><blockquote><p><strong>信息增益比</strong>：<br>特征 $A$ 对训练数据集 $D$ 的信息增益比 $G_R(D,A)$ 表示特征 $A$ 的信息增益 $G(D,A)$ 与训练数据集 $D$ 关于特征 $A$ 的熵 $H_A(D)$ 的比值，即：</p><script type="math/tex; mode=display">G_R(D,A)=\frac{G(D,A)}{H_A(D)}</script></blockquote><hr><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><p>决策树过拟合风险很大，理论上可以完全分开（极限情况：每个数据对应一个叶子结点）</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>在构建决策树的过程中，进行剪枝，预剪枝的方法包括：</p><ul><li>限制树的<strong>深度</strong></li><li>限制<strong>叶子结点的个数</strong></li><li>限制<strong>叶子结点的样本数</strong></li><li>限制<strong>信息增益</strong></li></ul><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是，建立树之后，再进行剪枝。<br>通过一定的衡量标准，衡量是否分裂该结点。</p><p>总体思路为：</p><p>由完全树 T0 开始，剪枝部分结点得到 T1，再次剪枝部分结点得到 T2……直到剩下树根的树 Tk；在验证数据集上对这 k 个树分别评价，选择损失函数最小的树 Ta。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;../images/机器学习-决策树.png&quot; alt&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-41-50题</title>
    <link href="http://monteyang.cn/LeetCode-41-50%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-41-50%E9%A2%98.html</id>
    <published>2020-02-11T05:24:11.000Z</published>
    <updated>2020-02-22T04:54:20.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode 41~50 题</p></blockquote><a id="more"></a><h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><pre><code>输入: [1,2,0]输出: 3</code></pre><p>示例 2:</p><pre><code>输入: [3,4,-1,1]输出: 2</code></pre><p>示例 3:</p><pre><code>输入: [7,8,9,11,12]输出: 1</code></pre><p>说明:</p><ul><li>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _nums = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n &gt; len(nums):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _nums[n<span class="number">-1</span>] = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(_nums):</span><br><span class="line">            <span class="keyword">if</span> num != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        water_sum = <span class="number">0</span></span><br><span class="line">        left_max_height = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历从 idx=1 到 idx=leng(height)-2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(height) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 求左边最高的墙高</span></span><br><span class="line">            left_max_height = height[i - <span class="number">1</span>] \</span><br><span class="line">                 <span class="keyword">if</span> height[i - <span class="number">1</span>] &gt; left_max_height <span class="keyword">else</span> left_max_height</span><br><span class="line">            <span class="comment"># 求右边最高的墙高</span></span><br><span class="line">            right_max_height = <span class="number">0</span></span><br><span class="line">            right_max_height = max(height[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 当前列可容纳的水量</span></span><br><span class="line">            water = max(min(left_max_height, right_max_height) - height[i], <span class="number">0</span>)</span><br><span class="line">            water_sum += water</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water_sum</span><br></pre></td></tr></table></figure><hr><h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><ul><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            self._dict.update(&#123;str(i): i&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 使num1为长度较小的</span></span><br><span class="line">        <span class="keyword">if</span> len(num1) &gt; len(num2):</span><br><span class="line">            num1, num2 = num2, num1</span><br><span class="line">        num2 = self.str2int(num2)</span><br><span class="line">        <span class="comment"># 将num1的每一位与num2相乘</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num1)+<span class="number">1</span>):</span><br><span class="line">            res += self._dict[num1[-i]] * num2 * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""将str类型转化为int类型"""</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)+<span class="number">1</span>):</span><br><span class="line">            ret += self._dict[num[-i]] * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h1 id="44-TODO"><a href="#44-TODO" class="headerlink" title="44. TODO"></a>44. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><pre><code>输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p>说明:</p><pre><code>假设你总是可以到达数组的最后一个位置。</code></pre><blockquote><p>思路：考虑贪心算法，如何确定下一步的位置？考虑下下一步能够到的最远距离。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(idx)</span>:</span></span><br><span class="line">            <span class="string">"""输入当前idx, 返回当前应走到的索引"""</span></span><br><span class="line">            max_distance = <span class="number">0</span></span><br><span class="line">            go2idx = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历当前可以走的所有索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums[idx]+<span class="number">1</span>):</span><br><span class="line">                next_idx = idx + i  <span class="comment"># 下一位置的索引</span></span><br><span class="line">                <span class="keyword">if</span> next_idx &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> len(nums) - <span class="number">1</span></span><br><span class="line">                distance = next_idx + nums[next_idx]  <span class="comment"># 可以走的距离</span></span><br><span class="line">                <span class="keyword">if</span> distance &gt; max_distance:</span><br><span class="line">                    max_distance = distance</span><br><span class="line">                    go2idx = next_idx</span><br><span class="line">            <span class="keyword">return</span> go2idx</span><br><span class="line"></span><br><span class="line">        next_idx = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> next_idx &lt; len(nums)<span class="number">-1</span>:</span><br><span class="line">            next_idx = util(next_idx)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><blockquote><p>思路：用树结构思考，考虑深度优先遍历</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(mem, residual)</span>:</span></span><br><span class="line">            <span class="comment"># 如果没有剩余元素，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> residual:</span><br><span class="line">                res.append(mem)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(residual)):</span><br><span class="line">                residual_tmp = copy.deepcopy(residual)</span><br><span class="line">                residual_tmp.pop(i)</span><br><span class="line">                dfs(mem+[residual[i]], residual_tmp)</span><br><span class="line"></span><br><span class="line">        dfs([], nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="47-TODO"><a href="#47-TODO" class="headerlink" title="47. TODO"></a>47. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="48-TODO"><a href="#48-TODO" class="headerlink" title="48. TODO"></a>48. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="49-TODO"><a href="#49-TODO" class="headerlink" title="49. TODO"></a>49. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="50-TODO"><a href="#50-TODO" class="headerlink" title="50. TODO"></a>50. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode 41~50 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-PointNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html</id>
    <published>2020-01-09T06:56:01.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation"><a href="#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation" class="headerlink" title="PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation"></a>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</h2><ul><li>关键词: point cloud, deep learning</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>直接对点云进行学习 =&gt; 实现分类/分割</li></ul><ul><li>针对点云的深度学习算法需满足的特性:<ul><li><strong>无序性</strong>: 所有点无次序</li><li><strong>点与点之间的关系</strong>: 点与neighbor之间存在局部的结构关系</li><li><strong>变换下的不变性</strong>: 旋转/平移等不改变点云模型的整体类别和局部分割类别</li></ul></li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>提取点云的全局/局部特征<ul><li>全局特征: 表示形状类别的特征</li><li>局部特征: 每个点的特征</li></ul></li></ul><ul><li>T-Net: 将所有点对齐到一个规范空间中</li><li>用<strong>对称函数</strong> MaxPooling: 解决点云的无序性</li><li>对于Segmentation: 局部特征 + 全局特征 (Aggregation)</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/PointNet-Network.png" alt="Network" title="PointNet"></p><ul><li>输入的点数为 n</li><li>global feature 维度1024不是对应点数,而是模型整体的特征</li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>3D分类: ModelNet40</li><li>3D部件分割: ShapeNet的子集(16类)</li><li>3D场景分割: I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,M. Fischer, and S. Savarese. 3d semantic parsing of large-scale indoor spaces.</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>数据预处理<ul><li>在Mesh的表面均匀采样1024个点</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>3D 分类:<ul><li>accuracy</li></ul></li><li>3D 分割:<ul><li>mIoU</li></ul></li></ul><h3 id="4-Disadvantages"><a href="#4-Disadvantages" class="headerlink" title="4. Disadvantages"></a>4. Disadvantages</h3><p>未充分挖掘局部结构特征</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot;&gt;&lt;a href=&quot;#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&quot;&gt;&lt;/a&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: point cloud, deep learning&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-VoxNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html</id>
    <published>2020-01-09T06:38:39.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition"><a href="#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition" class="headerlink" title="VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition"></a>VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition</h2><ul><li>关键词: voxel, 3D deep learning</li><li>会议: IROS</li><li>源码: official √<ul><li><a href="https://github.com/MonteYang/VoxNet.pytorch" target="_blank" rel="external nofollow noopener noreferrer">我的复现: by PyTorch</a></li></ul></li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><p>针对Voxel的3d物体识别/分类</p><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><p>将在视频领域取得一定效果的3D CNN用于Voxel的特征提取</p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/3-VoxNet-Network.png" alt title="VoxNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>3种数据集:</p><ul><li>LiDAR data - Sydney Urban Objects</li><li>CAD data - ModelNet</li><li>RGBD data - NYUv2</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO:</p><h3 id="4-Advantages"><a href="#4-Advantages" class="headerlink" title="4. Advantages"></a>4. Advantages</h3><ul><li>表现性能超过了之前的 ShapeNet</li><li>参数比 ShapeNet 少一些  <blockquote><p>ShapeNet is a relatively large architecture, with over 12.4 million parameters, while VoxNet has less than 1 million.</p></blockquote></li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>计算性能受Voxel的分辨率限制: 当Voxel分辨率过高时,内存占用过高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot;&gt;&lt;a href=&quot;#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot; class=&quot;headerlink&quot; title=&quot;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&quot;&gt;&lt;/a&gt;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: voxel, 3D deep learning&lt;/li&gt;
&lt;li&gt;会议: IROS&lt;/li&gt;
&lt;li&gt;源码: official √&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MonteYang/VoxNet.pytorch&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;我的复现: by PyTorch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Voxel" scheme="http://monteyang.cn/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Ciss-Net</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html</id>
    <published>2020-01-09T06:28:22.000Z</published>
    <updated>2020-03-11T13:18:23.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context-Reinforced-Semantic-Segmentation"><a href="#Context-Reinforced-Semantic-Segmentation" class="headerlink" title="Context-Reinforced Semantic Segmentation"></a><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf" target="_blank" rel="external nofollow noopener noreferrer">Context-Reinforced Semantic Segmentation</a></h2><ul><li>关键词: 强化学习, image segmentation, context</li><li>会议: CVPR 2019</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>Context(上下文信息)在语义分割中至关重要, 挖掘图像中上下文信息</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>使用分割后的图片 p-maps 作为上下文信息的来源</li><li>该项工作提出Context-Net -&gt; 更好的挖掘上下文信息</li><li>将上下文信息的学习过程定义为马尔科夫决策问题(MDP), 使用强化学习方法进行优化</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/CissNet-Network.png" alt="Ciss_Net"></p><ul><li>Environment: <code>p-map</code></li><li>Agent: <code>Context Net</code><ul><li>State: $\{Y_I\}$</li><li>Action: $\{B_I\}$</li></ul></li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>ADE20K</li><li>Cityscapes</li><li>Pascal Context</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO</p><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><!-- ### 4. Advantages ### 5. Disadvantages -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context-Reinforced-Semantic-Segmentation&quot;&gt;&lt;a href=&quot;#Context-Reinforced-Semantic-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;Context-Reinforced Semantic Segmentation&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Context-Reinforced Semantic Segmentation&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: 强化学习, image segmentation, context&lt;/li&gt;
&lt;li&gt;会议: CVPR 2019&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="image segmentation" scheme="http://monteyang.cn/tags/image-segmentation/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-MeshNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html</id>
    <published>2020-01-09T03:18:28.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation"><a href="#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation" class="headerlink" title="MeshNet: Mesh Neural Network for 3D Shape Representation"></a>MeshNet: Mesh Neural Network for 3D Shape Representation</h2><ul><li>关键词: Mesh, 3D shape classification/retrieval</li><li>会议: AAAI 2018</li><li>源码: √</li></ul><a id="more"></a><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>PoinNet</li><li>KC-Net</li></ul><blockquote><p>Related Work:</p><ul><li>Mesh Feature Extraction</li><li>Deep Learning Methods for 3D Shape Representation<ul><li>voxel-based</li><li>view-based</li><li>point-based</li><li>fusion method</li></ul></li></ul></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h3><ul><li>直接对 Mesh 进行形状表示的学习</li><li>应用于 3D shape classification/retrieval</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>将一个face视作一个单元</li><li><p>face的特征分为:</p><ul><li><strong>空间特征</strong></li><li><strong>结构特征</strong></li></ul></li><li><p>针对<strong>空间特征</strong>和<strong>结构特征</strong>分别提出:</p><ul><li>Spatial Descriptor<ul><li>面的中心点作为输入</li><li>采用与point cloud类似的处理方法</li></ul></li><li>Structural Descriptor<ul><li><strong>face rotate convolution</strong></li><li><strong>face kernel correlation</strong></li></ul></li></ul></li><li><p>整合空间特征和结构特征: 提出 Mesh Convolution</p></li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/MeshNet-Network.png" alt="MeshNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>ModelNet40</p><ul><li>for 3D classification/retrieval</li><li>40类别</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>Mesh模型需先简化至<strong>不多于1024个面</strong>(以面为单位,类似PointNet中以点为单位)</li><li>由于Mesh的面数不恒定, 随机选取填满1024个面 for batch training</li><li>数据增强: 所有点按高斯分布进行随机平移: N(0, 0.01)</li><li>for Classification:<ul><li>global features 后添加 MLP(512, 256, 40): 40表示40个类别</li><li>MLP的最后两层添加dropout层: drop概率为0.5</li></ul></li><li>for Retrieval:<ul><li>global features 直接计算 L2 距离</li></ul></li><li>训练时的超参数:<ul><li>SGD optimizer</li><li>initial learning rate 0.01</li><li>momentum 0.9</li><li>weight decay 0.0005</li><li>batch size 64.</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>Classification: Accuracy</li><li>Retrieval: mAP</li></ul><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><p>TODO:</p><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><p><img data-src="/images/MeshNet-exp-results.png" alt="实验结果" title="ModelNet实验结果"><br>&lt;!— ### 4. Advantages</p><ul><li>将point的方法应用于Mesh的特征提取(空间提取, KC)</li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>空间特征提取 不仅考虑面的中心点, 可以加入中心点周围的三个点的信息, 可能会有所提升.</li><li>当前面和周围三个面可能会有相似的特征.可否进行替换 —&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot;&gt;&lt;a href=&quot;#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot; class=&quot;headerlink&quot; title=&quot;MeshNet: Mesh Neural Network for 3D Shape Representation&quot;&gt;&lt;/a&gt;MeshNet: Mesh Neural Network for 3D Shape Representation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: Mesh, 3D shape classification/retrieval&lt;/li&gt;
&lt;li&gt;会议: AAAI 2018&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Mesh" scheme="http://monteyang.cn/tags/Mesh/"/>
    
  </entry>
  
  <entry>
    <title>Paper Reading Plan</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html</id>
    <published>2020-01-09T03:02:40.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h2><ul><li>[x] AlexNet</li><li>[x] VGGNet</li><li>[x] ResNet</li><li>[x] InceptionNet</li><li>[ ] DenseNet</li><li>[ ] SENet</li></ul><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><ul><li>[x] MeshNet</li><li>[ ] MeshCNN</li></ul><h2 id="Voxel"><a href="#Voxel" class="headerlink" title="Voxel"></a>Voxel</h2><ul><li>[ ] 3D ShapeNet</li><li>[ ] VoxNet</li><li>[ ] OctNet</li><li>[ ] FPNN</li><li>[ ] O-CNN</li></ul><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>[X] PointNet</li><li>[x] PointNet++</li><li>[x] KC-Net</li><li>[ ] PointSIFT</li><li>[ ] Point-Voxel</li><li>[ ] PointGrid</li></ul><h2 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h2><ul><li>[ ] DeepSDF</li></ul><h2 id="Reinfocement-Learning"><a href="#Reinfocement-Learning" class="headerlink" title="Reinfocement Learning"></a>Reinfocement Learning</h2><ul><li>[ ] DDPG</li><li>[ ] MADDPG</li></ul><h2 id="CNN-basic"><a href="#CNN-basic" class="headerlink" title="CNN-basic"></a>CNN-basic</h2><ul><li>[x] Tricks-of-CNN</li></ul><h2 id="Image-Segmentation"><a href="#Image-Segmentation" class="headerlink" title="Image Segmentation"></a>Image Segmentation</h2><ul><li>[ ] FCN</li><li>[ ] U-Net</li><li>[ ] SegNet</li><li>[ ] DeepLab系列</li><li>[ ] Fully Convolutional DenseNet</li><li>[ ] E-Net</li><li>[ ] Link-Net</li><li>[ ] Mask R-CNN</li><li>[ ] PSPNet</li><li>[ ] RefineNet</li><li>[ ] HR-Net</li><li>[ ] Ciss-Net</li></ul><!-- ---- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation-CVPR2017-论文链接-tensorflow代码-pytorch代码- PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space-NIPS2017-论文链接-tensorflow代码-pytorch代码- Escape from Cells: Deep Kd-Networks for the Recognition of 3D Point Cloud Models-ICCV2017-论文链接-pytorch代码- KCNet: Mining Point Cloud Local Structures by Kernel Correlation and Graph Pooling-CVPR2018-论文链接-caffe代码-pytorch代码- Pointwise Convolutional Neural Networks-CVPR2018-论文链接-tensorflow代码- SO-Net: Self-Organizing Network for Point Cloud Analysis-CVPR2018-论文链接-pytorch代码- Recurrent Slice Networks for 3D Segmentation of Point Clouds-CVPR2018-论文链接-pytorch代码- SPLATNet: Sparse Lattice Networks for Point Cloud Processing-CVPR2018-l论文链接-caffe代码-pytorch代码- Large-scale Point Cloud Semantic Segmentation with Superpoint Graphs-CVPR2018-论文链接-pytorch代码- Dynamic Graph CNN for Learning on Point Cloud-arxiv2018-论文链接-代码链接- Local Spectral Graph Convolution for Point Set Feature Learning-ECCV2018-论文链接-tensorflow代码- SpiderCNN: Deep Learning on Point Sets with Parameterized Convolutional Filters-ECCV2018-论文链接-tensorflow代码- Point Convolutional Neural Networks by Extension Operators-SIGGRAPH 2018-论文链接-tensorflow代码- PointCNN: Convolution On X-Transformed Points-NeurIPS 2018-论文链接-tensorflow代码-mxnet代码-pytorch代码- PointSIFT: A SIFT-like Network Module for 3D Point Cloud Semantic Segmentation-arxiv2018-论文链接-tensorflow代码-pytorch代码- PointConv: Deep Convolutional Networks on 3D Point Clouds-arxiv2018-论文链接- Adversarial Autoencoders for Generating 3D Point Clouds-arxiv2018-论文链接- Modeling Local Geometric Structure of 3D Point Clouds using Geo-CNN-论文链接- Supervised Fitting of Geometric Primitives to 3D Point Clouds-CVPR2019-l论文链接-tensorflow代码- Multi-view Point Cloud Registration with Adaptive Convergence Threshold and its Application on 3D Model Retrieval-论文链接- Iterative Transformer Network for 3D Point Cloud-arxiv2018-论文链接- DeepMapping: Unsupervised Map Estimation From Multiple Point Clouds-arxiv2018-论文链接- CAPNet: Continuous Approximation Projection For 3D Point Cloud Reconstruction Using 2D Supervision-论文链接-AAAI2019-代码链接- Increasing the Capability of Neural Networks for Surface Reconstruction from Noisy Point Clouds-arxiv2018-论文链接- Topology-Aware Surface Reconstruction for Point Clouds-arxiv2018-论文链接- Nesti-Net: Normal Estimation for Unstructured 3D Point Clouds using Convolutional Neural Networks-arxiv2018-论文链接- Inferring Point Clouds from Single Monocular Images by Depth Intermediation-arxiv2018-论文链接- Learning Saliency Maps for Adversarial Point-Cloud Generation-arxiv2019-论文链接- A Graph-CNN for 3D Point Cloud Classification- ICASSP 2018-论文链接-tensorflow代码- GSPN: Generative Shape Proposal Network for 3D Instance Segmentation in Point Cloud-arxiv2018-论文链接- PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud-arxiv2018-论文链接- Deep RBFNet: Point Cloud Feature Learning using Radial Basis Functions-arxiv2018-论文链接- IPOD: Intensive Point-based Object Detector for Point Cloud-arxiv2018-论文链接- PointPillars: Fast Encoders for Object Detection from Point Clouds-arxiv2018-论文链接- 3D Point Cloud Learning for Large-scale Environment Analysis and Place Recognition-arxiv2018-论文链接- 3D Point Cloud Denoising via Bipartite Graph Approximation and Reweighted Graph Laplacian-arxiv2018-论文链接- Casualty Detection from 3D Point Cloud Data for Autonomous Ground Mobile Rescue Robots-SSRR)2018-论文链接- Deflecting 3D Adversarial Point Clouds Through Outlier-Guided Removal-arxiv2018-论文链接- Machine learning enables polymer cloud-point engineering via inverse design-arxiv2018-论文链接- 3D Convolution on RGB-D Point Clouds for Accurate Model-free Object Pose Estimation-arxiv2018-论文链接- Feature Preserving and Uniformity-controllable Point Cloud Simplification on Graph-arxiv2018-论文链接- GeoNet: Deep Geodesic Networks for Point Cloud Analysis-CVPR2019-论文链接- POINTCLEANNET: Learning to Denoise and Remove Outliers from Dense Point Clouds-arxiv2018-论文链接-pytorch代码- Generic Primitive Detection in Point Clouds Using Novel Minimal Quadric Fits-T-PAMI2019-论文链接- Fast 3D Line Segment Detection From Unorganized Point Cloud-arxiv2019-论文链接- Extending Adversarial Attacks and Defenses to Deep 3D Point Cloud Classifiers-arxiv2019-论文链接-tensorflow代码- Skeletonisation Algorithms for Unorganised Point Clouds with Theoretical Guarantees-arxiv2019-论文链接- Automatic normal orientation in point clouds of building interiors-arxiv2019-论文链接- Fitting 3D Shapes from Partial and Noisy Point Clouds with Evolutionary Computing-arxiv2019-论文链接- Context Prediction for Unsupervised Deep Learning on Point Clouds-arxiv2019-论文链接- Dense 3D Point Cloud Reconstruction Using a Deep Pyramid Network-WACV 2019-论文链接- Points2Pix: 3D Point-Cloud to Image Translation using conditional Generative Adversarial Networks-arxiv2019-l论文链接- NeuralSampler: Euclidean Point Cloud Auto-Encoder and Sampler-arxiv2019-l论文链接- Embedded Delaunay triangulations for point clouds of surfaces in-arxiv2019-l论文链接- 3D point cloud registration with shape constraint-ICIP 2017-论文链接- Occupancy-map-based rate distortion optimization for video-based point cloud compression-arxiv2019-论文链接- 3D Graph Embedding Learning with a Structure-aware Loss Function for Point Cloud Semantic Instance Segmentation-arxiv2019-论文链接- PIXOR: Real-time 3D Object Detection from Point Clouds- CVPR2018-论文链接-pytorch代码- Multi-view Incremental Segmentation of 3D Point Clouds for Mobile Robots-arxiv2019-论文链接- Point cloud denoising based on tensor Tucker decomposition-CVPR2019-l论文链接- Associatively Segmenting Instances and Semantics in Point Clouds-CVPR2019-论文链接- Zero-shot Learning of 3D Point Cloud Objects-MVA2019-论文链接- Octree guided CNN with Spherical Kernels for 3D Point Clouds-arxiv2019-论文链接- Real-time Multiple People Hand Localization in 4D Point Clouds-arxiv2019-论文链接- Variational Graph Methods for Efficient Point Cloud Sparsification-arxiv2019-代码链接- HoloCast: Graph Signal Processing for Graceful Point Cloud Delivery-arxiv2019-论文链接- Fast Registration for cross-source point clouds by using weak regional affinity and pixel-wise refinement-ICME 2019-论文链接- PointNetLK: Robust & Efficient Point Cloud Registration using PointNet-arxiv2019-论文链接- Neural Style Transfer for Point Clouds-arxiv2019-论文链接- OREOS: Oriented Recognition of 3D Point Clouds in Outdoor Scenarios-arxiv2019-论文链接- Learning Convolutional Transforms for Lossy Point Cloud Geometry Compression-arxiv2019-论文链接- Monocular 3D Object Detection with Pseudo-LiDAR Point Cloud-论文链接-arxiv2019- FVNet: 3D Front-View Proposal Generation for Real-Time Object Detection from Point Clouds-论文链接-arxiv2019- Unpaired Point Cloud Completion on Real Scans using Adversarial Training-论文链接-arxiv2019- USIP: Unsupervised Stable Interest Point Detection from 3D Point Clouds-论文链接-arxiv2019-代码链接- MortonNet: Self-Supervised Learning of Local Features in 3D Point Clouds-论文链接-arxiv2019- Discrete Rotation Equivariance for Point Cloud Recognition-论文链接-ICRA 2019-代码链接- JSIS3D: Joint Semantic-Instance Segmentation of 3D Point Clouds with Multi-Task Pointwise Networks and Multi-Value Conditional Random Fields-论文链接-CVPR 2019(oral)-代码链接- DeepPoint3D: Learning Discriminative Local Descriptors using Deep Metric Learning on 3D Point Clouds-论文链接-arxiv2019- A Dataset for Semantic Segmentation of Point Cloud Sequences-论文链接-arxiv2019- Point Cloud Oversegmentation with Graph-Structured Deep Metric Learning-论文链接-CVPR2019- Generalizing discrete convolutions for unstructured point clouds-论文链接-arxiv2019- 3D Point Cloud Denoising via Deep Neural Network based Local Surface Estimation-论文链接-arxiv2019- Complexer-YOLO: Real-Time 3D Object Detection and Tracking on Semantic Point Clouds-论文链接-arxiv2019- Total Denoising: Unsupervised Learning of 3D Point Cloud Cleaning-论文链接-arxiv2019- 3D Object Recognition with Ensemble Learning — A Study of Point Cloud-Based Deep Learning Models-论文链接-arxiv2019- Deep Hough Voting for 3D Object Detection in Point Clouds-论文链接-arxiv2019- 2D3D-MatchNet: Learning to Match Keypoints Across 2D Image and 3D Point Cloud-论文链接-arxiv2019- PCAN: 3D Attention Map Learning Using Contextual Information for Point Cloud Based Retrieval-论文链接-CVPR2019- Graph-based Inpainting for 3D Dynamic Point Clouds-论文链接-arxiv2019- 3D Dynamic Point Cloud Denoising via Spatio-temporal Graph Modeling-论文链接-arxiv2019- RL-GAN-Net: A Reinforcement Learning Agent Controlled GAN Network for Real-Time Point Cloud Shape Completion-论文链接-cvpr2019-代码链接- Unsupervised Feature Learning for Point Cloud by Contrasting and Clustering With Graph Convolutional Neural Network-论文链接-arxiv2019- Loop-Closure Detection Based on 3D Point Cloud Learning for Self-Driving Industry Vehicles-论文链接-arxiv2019- Oriented Point Sampling for Plane Detection in Unorganized Point Clouds-论文链接-ICRA2019- Deep Closest Point: Learning Representations for Point Cloud Registration-论文链接-arxiv2019- Deep AutoEncoder-based Lossy Geometry Compression for Point Clouds-论文链接-arxiv2019- DeepICP: An End-to-End Deep Neural Network for 3D Point Cloud Registration-论文链接-arxiv2019- Deep Unsupervised Learning of 3D Point Clouds via Graph Topology Inference and Filtering-论文链接-arxiv2019- Cooper: Cooperative Perception for Connected Autonomous Vehicles based on 3D Point Clouds-论文链接 -ICDCS 2019- 3D Point Cloud Generative Adversarial Network Based on Tree Structured Graph Convolutions-论文链接-arxiv2019- SAWNet: A Spatially Aware Deep Neural Network for 3D Point Cloud Processing-论文链接-arxiv2019- A Two-stage Classification Method for High-dimensional Data and Point Clouds-论文链接-arxiv2019- GAPNet: Graph Attention based Point Neural Network for Exploiting Local Feature of Point Cloud-论文链接-arxiv2019- RIU-Net: Embarrassingly simple semantic segmentation of 3D LiDAR point cloud-论文链接-arxiv2019- Domain Adaptation for Vehicle Detection from Bird’s Eye View LiDAR Point Cloud Data-论文链接-Under review for IEEE SMC 2019- Robust Point Cloud Based Reconstruction of Large-Scale Outdoor Scenes-论文链接-CVPR2019- Efficient Curvature Estimation for Oriented Point Clouds-论文链接-arxiv2019- Leveraging binding-site structure for drug discovery with point-cloud methods-论文链接-arxiv2019- NPTC-net: Narrow-Band Parallel Transport Convolutional Neural Network on Point Clouds-论文链接-arxiv2019- Partial Computing Offloading Assisted Cloud Point Registration in Multi-robot SLAM-论文链接-arxiv2019- Point Clouds Learning with Attention-based Graph Convolution Networks-论文链接-arxiv2019- Learning Object Bounding Boxes for 3D Instance Segmentation on Point Clouds-论文链接-arxiv2019- Direct structural analysis of domains defined by point clouds-论文链接-arxiv2019- Learning Shape Representation on Sparse Point Clouds for Volumetric Image Segmentation-论文链接-MICCAI 2019 --><!--Templete---分界线---## 文章信息- 标题:- 关键词:- 会议:- 源码: √## 相关文章:> Related Work:## Note### 1. Plroblem### 2. Method#### Network Structure### 3. Experiment#### 3.1 Dataset#### 3.2 Implemention#### 3.3 Metric#### 3.4 Ablation Study#### 3.5 Result<!--### 4. Advantages### 5. Disadvantages-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Neural-Network&quot;&gt;&lt;a href=&quot;#Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Neural Network&quot;&gt;&lt;/a&gt;Neural Network&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[x] AlexNet&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="计划" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="paper reading plan" scheme="http://monteyang.cn/tags/paper-reading-plan/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31-40题</title>
    <link href="http://monteyang.cn/LeetCode-31-40%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-31-40%E9%A2%98.html</id>
    <published>2020-01-08T02:56:02.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>31~40</code> 题</p></blockquote><a id="more"></a><hr><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><blockquote><p>思路:<br>字典序算法</p><ol><li>从右往左, 找出第一个小于右邻的数 <code>list[x]</code>;</li><li>从右往左, 找出第一个比 <code>list[x]</code> 大的数 <code>list[y]</code>;</li><li>交换 <code>list[x]</code> 和 <code>list[y]</code>;</li><li>将 <code>list[x]</code> 后面的序列从小到大排序. </li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在下一个更大的字典序(即当前序列为最大的字典序), 则将序列转为最小字典序</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">-1</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                y = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 3, 4</span></span><br><span class="line">        nums[x], nums[y] = nums[y], nums[x]</span><br><span class="line">        nums[x+<span class="number">1</span>:] = sorted(nums[x+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><blockquote><p>思路:</p><ol><li>用栈实现括号匹配</li><li>用数组保存一个有效括号的索引值</li><li>对所有索引值进行排序</li><li>找出连续索引长度中的最长长度</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># ()()()(()()()(()))</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        idxs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># 如果栈为空时</span></span><br><span class="line">            <span class="keyword">if</span> stack == []:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 如果栈非空时</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    idxs.append(i)</span><br><span class="line">                    idxs.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line"></span><br><span class="line">        idxs.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> idxs: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(idxs)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> idxs[j+<span class="number">1</span>] - idxs[j] == <span class="number">1</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> max_length &lt; length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(length, max_length)</span><br></pre></td></tr></table></figure><hr><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p><p>示例 1:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums = [4,5,6,7,0,1,2]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 找出最小值的索引</span></span><br><span class="line">        min_idx = self.search_min_idx(nums)</span><br><span class="line">        <span class="keyword">if</span> min_idx != <span class="number">0</span>:</span><br><span class="line">            nums = nums[min_idx:] + nums[:min_idx]</span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        tmp_idx = self.bin_search(nums, target)</span><br><span class="line">        <span class="keyword">if</span> tmp_idx == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> (tmp_idx + min_idx) % len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_min_idx</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> </span></span><br><span class="line">        <span class="keyword">return</span> nums.index(min(nums))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        二分查找法:</span></span><br><span class="line"><span class="string">            - 如果nums中存在目标值, 则返回该值的index;</span></span><br><span class="line"><span class="string">            - 如果nums中不存在目标值, 则返回 -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h1 id="34-TODO"><a href="#34-TODO" class="headerlink" title="34. TODO"></a>34. TODO</h1><hr><h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><pre><code>输入: [1,3,5,6], 5输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [1,3,5,6], 2输出: 1</code></pre><p>示例 3:</p><pre><code>输入: [1,3,5,6], 7输出: 4</code></pre><p>示例 4:</p><pre><code>输入: [1,3,5,6], 0输出: 0</code></pre><blockquote><p><strong>思路</strong></p><ol><li>扫一次, 若当前值小于 <code>target</code>, 则跳过; 若当前值大于等于 <code>target</code>, 则返回当前索引</li><li>若所有元素都小于 <code>target</code>, 则返回<code>(最大索引+1)</code></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><hr><h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1:</p><pre><code>输入:[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true</code></pre><p>示例 2:</p><pre><code>输入:[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。    但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><pre><code>一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。给定数独永远是 9x9 形式的。</code></pre><blockquote><p><strong>思路</strong></p><ol><li>数独板块中共有 <strong>9行 \ 9列 \ 9个小块</strong>, <strong>每行 \ 每列 \ 每个小块</strong> 都建立一个 hash map, 用来记录该<strong>行\列\小块</strong>中数字对应的个数</li><li>遍历所有 9*9 个元素:<ol><li>一旦 hash map 中存在大于1个的元素, 则不满足数独条件, 返回 <code>false</code>;</li><li>如果遍历结束后, 都未出现 <code>false</code>, 则满足数独条件.</li></ol></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        small_box = [[&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]  <span class="comment"># 3*3个 small box</span></span><br><span class="line">        row = [&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 9行</span></span><br><span class="line">        colum = copy.deepcopy(row)  <span class="comment"># 9列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx_row, r <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> idx_colum, num <span class="keyword">in</span> enumerate(r):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">'.'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前元素为 num, 判断该元素属于哪个small_box</span></span><br><span class="line">                <span class="comment"># 如果对应的small box中没有该数, 设置hash中的key的value为1</span></span><br><span class="line">                <span class="comment"># 如果对应的small box已存在该数, 则返回错误</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>]:</span><br><span class="line">                    small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前row中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> row[idx_row]:</span><br><span class="line">                    row[idx_row][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前列中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> colum[idx_colum]:</span><br><span class="line">                    colum[idx_colum][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="37-TODO"><a href="#37-TODO" class="headerlink" title="37. TODO"></a>37. TODO</h1><hr><h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221</li></ol><p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>示例 1:</p><pre><code>输入: 1输出: &quot;1&quot;解释：这是一个基本样例。</code></pre><p>示例 2:</p><pre><code>输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre><blockquote><p>思路：<br>迭代求解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        s = <span class="string">'1*'</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            s = self.util(s)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">""" 输入s, 返回s的下一个外观数列, 注意s的最后一个字符是'*'.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            s (string): 以 * 结尾的字符串</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 下一个外观数列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (str(cnt) + s[i - <span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        s = res + <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><hr><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><pre><code>所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><pre><code>输入: candidates = [2,3,6,7], target = 7,所求解集为:[⁠ [7],⁠ [2,2,3]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,3,5], target = 8,所求解集为:[[2,2,2,2],[2,3,3],[3,5]]</code></pre><blockquote><p>思路: 回溯法 + 利用树的数据结构判断</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        candidates.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(candidates, cur_sum, tmp_list)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> candidates == []: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表之和等于 target, 加入res</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(tmp_list)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表元素之和大于 target，直接返回（剪枝）</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前列表元素之和小于 target，继续添加元素</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    _tmp_list = copy.deepcopy(tmp_list)</span><br><span class="line">                    _tmp_list.append(c)</span><br><span class="line">                    util(candidates[i:], cur_sum+c, _tmp_list)</span><br><span class="line">        </span><br><span class="line">        util(candidates, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="40-组合之和II"><a href="#40-组合之和II" class="headerlink" title="40. 组合之和II"></a>40. 组合之和II</h1><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1:</p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[[1,2,2],[5]]</code></pre><blockquote><p>思路:<br>与上一题相似, 多增加去重步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()  <span class="comment"># [1,1,2,5,6,]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(cur_sum, cur_list, candidates)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(cur_list)</span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> c == candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                    _cur_list = cur_list[:]</span><br><span class="line">                    _cur_list.append(c)</span><br><span class="line">                    back_track(cur_sum+c, _cur_list, candidates[i+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        back_track(<span class="number">0</span>, [], candidates)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;31~40&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
