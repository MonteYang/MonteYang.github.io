<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monte&#39;s Blog</title>
  
  <subtitle>朝着咸鱼的反方向努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monteyang.cn/"/>
  <updated>2020-03-10T13:15:45.375Z</updated>
  <id>http://monteyang.cn/</id>
  
  <author>
    <name>Monte Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blender学习资料</title>
    <link href="http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html"/>
    <id>http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html</id>
    <published>2020-03-10T03:51:23.000Z</published>
    <updated>2020-03-10T13:15:45.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender是什么？"><a href="#Blender是什么？" class="headerlink" title="Blender是什么？"></a>Blender是什么？</h1><blockquote><p>摘自官方手册：<br>Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括<strong>建模、渲染、动画&amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟</strong>。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且<strong>可通过Python脚本来自定义界面</strong>)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。</p></blockquote><a id="more"></a><p>可以看出，Blender的功能很强大，从3D图形到视频，它都能搞。</p><p>博主之前对3D建模软件完全不了解，仅仅是听说过3DMax、Maya这些名字而已。在查阅了一些资料后，发现这种3D建模软件还是适合设计类专业的同学进行系统学习。</p><p>在查资料的过程中，发现这个软件有很多优秀的特点，包括：</p><ul><li><strong>跨平台</strong>： 对Linux用户很友好</li><li><strong>开源</strong>： 基于社区的开源项目，很吊，更新迭代快，完善速度快</li><li><strong>插件</strong>： 可以想象很多大牛会在这搞一些“骚操作”插件</li><li><strong>有Python API</strong>： 这就更骚了，会写代码的话，建模效率岂不是飞起？</li></ul><p>其实博主个人对3D建模、设计什么的不是很感兴趣，所以就学习下基本的操作和Python的调用，也是因为之前师兄说Blender中可以用Python对3D模型处理，之后可能会用得上吧。</p><h1 id="学习资料和社区"><a href="#学习资料和社区" class="headerlink" title="学习资料和社区"></a>学习资料和社区</h1><ul><li><a href="https://www.blendercn.org/" target="_blank" rel="external nofollow noopener noreferrer">Blender中国社区</a>: 国内Blender资料最全的社区。包括视频教程、中文文档、论坛等。</li><li><a href="https://docs.blender.org/manual/zh-hans/dev/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.83 参考手册</a></li><li><a href="https://docs.blender.org/api/current/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.82 Python API Documentation</a></li><li><a href="https://www.bilibili.com/video/av17804799/" target="_blank" rel="external nofollow noopener noreferrer">Blender官方入门教程（中文）B站</a>: 每个视频极短，适合小白入门，</li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>众所周知，无论是玩什么软件，掌握快捷键都能<strong>极大程度地提高工作效率</strong>。</p><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><ul><li>停止当前操作：【ESC】</li><li>快捷搜索：【SPACE】</li><li>撤销：【Ctrl】+【z】</li><li>重做：【Ctrl】+【shift】+【z】</li><li>渲染：【F12】</li><li>单选：【鼠标右键】（RMB）</li><li>全选：【A】</li><li>框选：【B】</li><li>刷选：【C】</li><li>套选：【Ctrl】+【鼠标左键】（LMB）</li><li>删除：【X】/【Delete】</li><li>复制：【Shift】+【D】</li><li>添加：【Shift】+【A】</li><li>取消：【Esc】/【RMB】</li><li>确认：【Return】/【LMB】</li></ul><h2 id="界面操作"><a href="#界面操作" class="headerlink" title="界面操作"></a>界面操作</h2><ul><li>工具栏位置对称切换：【F5】</li><li>固定/解固定工具栏：【SHIFT】+【LMB】</li><li>放大/缩小：【SHIFT】+【SPACE】</li><li>放大/缩小：【Ctrl】+【UP】/【Ctrl】+【DOWN】</li><li>移动视窗：【SHIFT】+【鼠标滚轮】</li><li>旋转视窗：【鼠标滚轮】</li><li>3DView：【SHIFT】+【F5】</li><li>UVEditorView：【SHIFT】+【F10】</li></ul><h2 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h2><ul><li>透视开启/关闭：【5】</li><li>前视图（+Ctrl后视图）：【1】</li><li>右视图（+Ctrl左视图）：【2】</li><li>顶视图（+Ctrl底视图）：【7】</li><li>摄像机视角（如果有摄像机）：【0】</li><li>将当前视图设为摄像机视角：【Ctrl】+【alt】+【0】</li><li>全屏显示当前视图：【Ctrl】+【up】</li><li>显示选中目标：小键盘【del】</li><li>显示所有目标：【Home】</li><li>场景平移：【Shift】+【鼠标中键】</li><li>场景缩放：【Ctrl】+【鼠标中键】（或者【滚轮】）</li></ul><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><ul><li>编辑模式：【Tab】</li><li>点线面三模式切换（编辑模式下）：【Tab】+【Ctrl】</li><li>加选/减选：【Ctrl】+【小键盘+/-】（可定义为【PageUP】，【PageDown】）</li><li>选择循环点/边/面：【Alt】+【LMB】</li><li>线框模式：【Z】</li><li>隐藏选中目标：【H】</li><li>显示所有隐藏目标：【Alt】+【H】</li></ul><h2 id="选中目标状态下"><a href="#选中目标状态下" class="headerlink" title="选中目标状态下"></a>选中目标状态下</h2><ul><li>挤出：【E】+【LMB】（挤出到鼠标位置）</li><li>移动：【G】</li><li>旋转：【R】</li><li>缩放：【S】(以上操作再按下X、Y、Z以固定轴向、轴心活动）</li><li>内插面：【i】</li><li>顶点/边滑移：【GG】</li><li>环切：【Ctrl】+【R】</li><li>边线折痕：【Shift】+【E】</li><li>快捷拓展命令栏：【W】</li><li>切割：【K】</li><li>分割：【Y】</li><li>分离（单独个体）：【P】</li><li>合并：【Ctrl】+【J】</li><li>倒角：【Ctrl】+【B】</li><li>球形化：【Shift】+【Alt】+【S】</li><li>关联选取：【L】</li><li>相似选取：【Shift】+【G】</li><li>创建父级：【Ctrl】+【P】</li><li>清除父级：【Alt】+【P】</li><li>吸附：【Shift】+【S】</li></ul><h2 id="节点编辑器"><a href="#节点编辑器" class="headerlink" title="节点编辑器"></a>节点编辑器</h2><ul><li>连接节点：【F】（选取两个目标）</li><li>断开节点：【Ctrl】+【LMB】（划掉连接线）</li><li>添加转接点：【Shift】+【LMB】（划掉连接线）</li><li>合并节点：【Ctrl】+【J】</li><li>断开选中节点：【Alt】+【D】</li><li>移动背景视图：【Alt】+【鼠标滚轮】</li><li>显示激活节点：小键盘【del】</li><li>显示所有节点：【Home】</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li>删除动画关键帧在信息清单视图：（DopeSheet）中按【B】框选按【X】删除选中的keyframes</li><li>插入一个关键帧（keyframe）：【I】</li><li>清除该关键帧：【Alt】-【I】</li><li>清空所有关键帧（删除所有的F-Curves）：【Alt】-【Shift】-【I】</li><li>assignadriver：【D】</li><li>clearthedriver：【Alt】-【D】</li><li>addaKeyingSet：【K】</li><li>cleartheKeyingSet：【Alt】-【K】</li><li>清除posemode下的旋转：【Alt】+【R】</li><li>清除posemode下的缩放：【Alt】+【S】</li><li>清楚posemode下的位移：【Alt】+【G】</li></ul><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><ul><li>到文本开始处：【Home】</li><li>到文本结束处：【End】</li><li>拷贝文本：【Ctrl】-【C】</li><li>粘贴文本：【Ctrl】-【V】</li><li>选择所有文本：【Ctrl】-【A】</li></ul><h2 id="数字调整"><a href="#数字调整" class="headerlink" title="数字调整"></a>数字调整</h2><ul><li>拖动时捕捉离散步骤：【Ctrl】</li><li>更高的调整精度：【Shift】</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>编辑模式下，弹出边编辑菜单，其中有UV映射常用的seem（缝边）功能：【Ctrl】+【E】</li><li>合并物体：【Ctrl】+【J】</li><li>分离物体：【P】</li><li>把选中的两个相邻三角形合并成四边形（quads）：【ALT】+【J】</li><li>吸附游标到选择点：【SHIFT】+【S】</li><li>撕开所选边：【V】</li><li>撕开所选边并填充：【ALT】+【V】</li><li>编辑模式下，合并选中的2个节点：【ALT】+【M】</li><li>打开吸附模式：【SHIFT】+【TAB】</li><li>打开点线面选择模式选取菜单：【Ctrl】+【TAB】</li><li>在EditMode下，将选中的表面变成三角面：【Ctrl】+【T】</li><li>环切loopcut：【Ctrl】+【R】</li><li>多个环切：【再按住鼠标滚轮上下滚动】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Blender是什么？&quot;&gt;&lt;a href=&quot;#Blender是什么？&quot; class=&quot;headerlink&quot; title=&quot;Blender是什么？&quot;&gt;&lt;/a&gt;Blender是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;摘自官方手册：&lt;br&gt;Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括&lt;strong&gt;建模、渲染、动画&amp;amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟&lt;/strong&gt;。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且&lt;strong&gt;可通过Python脚本来自定义界面&lt;/strong&gt;)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://monteyang.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Blender" scheme="http://monteyang.cn/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树</title>
    <link href="http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html"/>
    <id>http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html</id>
    <published>2020-02-22T06:49:11.000Z</published>
    <updated>2020-03-05T12:20:34.682Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="../images/机器学习-决策树.png" alt></p><hr><a id="more"></a><h1 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h1><p>从根节点开始，在每一个节点进行决策，最终走到叶子节点。既可以做<strong>分类</strong>，也可以做<strong>回归</strong>。</p><p>优点：可读性强，分类速度快。</p><p>通常，决策树学习分为三步： <strong>特征选择</strong>、<strong>决策树生成（构建）</strong>和<strong>决策树的剪枝</strong>。</p><blockquote><p><strong>难点在于决策树的构建</strong>。当构建好决策树后，利用其进行测试，对数据进行分类或回归都是十分简单的。</p></blockquote><h1 id="树的组成"><a href="#树的组成" class="headerlink" title="树的组成"></a>树的组成</h1><ul><li>根节点： 第一个判断条件的节点</li><li>非叶子结点： 中间的过程</li><li>叶子节点： 得到最终的决策结果</li></ul><p>决策树中的每个节点（特征）相当于在数据中切一刀，如果候选的特征越多，切的次数越多。</p><h1 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h1><p>决策树的训练过程就是<strong>决策树的生成</strong>，从给定数据集，构造出一课树。</p><p>从根节点开始选择特征，考虑如何进行特征切分。</p><blockquote><p>从根节点到下面的节点，如何进行选择和切分？</p></blockquote><p>思路： 从根节点到下面的节点所对应的特征，应该依次是从分类效果最好到不好。</p><p>因此，目标： 通过一种衡量标准，计算不同特征进行分支选择后的分类情况，衡量特征的分类效果，找出最好的特征当作根节点，以此类推。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>熵：<strong>表示随机变量不确定性的度量。不确定性越强，熵值越高</strong>。</p><p>假设 $X$ 是一个具有有限个值的离散型随机变量，服从如下的概率分布：</p><script type="math/tex; mode=display">P(X=x_i)=p_i,\qquad i=1,2,\cdots,n</script><p>则，随机变量$X$的熵定义为：</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np_i log p_i \quad (2)</script><p>假设 X 服从如下分布：</p><script type="math/tex; mode=display">P(X=1)=p，P(X=0)=1-p，0 \le p \le 1</script><p>于是根据 <strong>公式（2）</strong> 得到它的熵为：</p><script type="math/tex; mode=display">H(p)=-p\log_2p-(1-p)\log_2(1-p)</script><p><img data-src="../images/机器学习-决策树-熵.png" alt></p><p>概率和熵值大小的关系：</p><ul><li>当 p=0或1 时，H(p)=0，随机变量没有不确定性</li><li>当 p=0.5 时，H(p)=1，随机变量的不确定性最大</li></ul><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>设随机变量 $(X,Y)$ 的<strong>联合概率分布</strong>为：</p><script type="math/tex; mode=display">P(X=x_i,Y=y_j)=p_{ij},\quad i=1,2,\cdots,n;\quad j=1,2,\cdots ,m</script><p><strong>条件熵 $H(Y|X)$</strong> 表示在已知随机变量 $X$ 的取值条件下，随机变量 $Y$ 的不确定性。</p><p>其数学定义为：$X$ 给定的条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望，</p><script type="math/tex; mode=display">H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)</script><p>其中，$p_i=P(X=x_i),\quad i=1,2,\cdots,n$</p><p>在此基础上，引出<strong>信息增益</strong>（Information Gain），它<strong>表示在特征 $X$ 给定的条件下，而使得类 $Y$ 的信息不确定性减少的程度</strong>。数学精确表述如下：特征 $A$ 对训练数据集 $D$ 的<strong>信息增益 $G(D,A)$</strong> 定义为集合 $D$ 的熵 $H(D)$ 与特征 $A$ 给定的条件下 $D$ 的条件熵 $H(D | A)$ 之差，即：</p><script type="math/tex; mode=display">G(D,A)=H(D)-H(D|A)</script><p>决策树学习应用信息增益准则选择特征。给定训练数据集 $D$ 和特征 $A$。熵 $H(D)$ 表示对数据集 $D$ 进行分类的不确定性，而条件熵 $H(D|A)$ 表示在特征 $A$ 给定的条件下对数据集 $D$ 进行分类的不确定性。而他们的差，即信息增益就表示由于特征 $A$ 给定的情况下而使得对数据集 $D$ 进行分类的不确定性减少的程度。显然，对于数据集 $D$ 而言，信息增益依赖于特征。一般情况下，不同的特征具有不同的信息增益。<strong>信息增益大的特征具有更强的分类能力。</strong></p><p>由以上的表述，我们应该清楚地知道，决策树构建过程中，我们应该选择信息增益最大的特征进行分裂构建。</p><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>ID3算法的核心是递归的构建决策树，递归的过程中，在每个节点上，计算信息增益选择特征，直至满足递归停止条件（所有特征的信息增益都很小或者没有特征可以选择）。</p><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>C4.5 算法和 ID3 算法基本上完全一致，只是特征选择时的选择方法将信息增益换成<strong>信息增益比</strong>。</p><blockquote><p><strong>信息增益比</strong>：<br>特征 $A$ 对训练数据集 $D$ 的信息增益比 $G_R(D,A)$ 表示特征 $A$ 的信息增益 $G(D,A)$ 与训练数据集 $D$ 关于特征 $A$ 的熵 $H_A(D)$ 的比值，即：</p><script type="math/tex; mode=display">G_R(D,A)=\frac{G(D,A)}{H_A(D)}</script></blockquote><hr><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><p>决策树过拟合风险很大，理论上可以完全分开（极限情况：每个数据对应一个叶子结点）</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>在构建决策树的过程中，进行剪枝，预剪枝的方法包括：</p><ul><li>限制树的<strong>深度</strong></li><li>限制<strong>叶子结点的个数</strong></li><li>限制<strong>叶子结点的样本数</strong></li><li>限制<strong>信息增益</strong></li></ul><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是，建立树之后，再进行剪枝。<br>通过一定的衡量标准，衡量是否分裂该结点。</p><p>总体思路为：</p><p>由完全树 T0 开始，剪枝部分结点得到 T1，再次剪枝部分结点得到 T2……直到剩下树根的树 Tk；在验证数据集上对这 k 个树分别评价，选择损失函数最小的树 Ta。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;../images/机器学习-决策树.png&quot; alt&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-41-50题</title>
    <link href="http://monteyang.cn/LeetCode-41-50%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-41-50%E9%A2%98.html</id>
    <published>2020-02-11T05:24:11.000Z</published>
    <updated>2020-02-22T04:54:20.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode 41~50 题</p></blockquote><a id="more"></a><h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><pre><code>输入: [1,2,0]输出: 3</code></pre><p>示例 2:</p><pre><code>输入: [3,4,-1,1]输出: 2</code></pre><p>示例 3:</p><pre><code>输入: [7,8,9,11,12]输出: 1</code></pre><p>说明:</p><ul><li>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _nums = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n &gt; len(nums):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _nums[n<span class="number">-1</span>] = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(_nums):</span><br><span class="line">            <span class="keyword">if</span> num != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        water_sum = <span class="number">0</span></span><br><span class="line">        left_max_height = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历从 idx=1 到 idx=leng(height)-2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(height) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 求左边最高的墙高</span></span><br><span class="line">            left_max_height = height[i - <span class="number">1</span>] \</span><br><span class="line">                 <span class="keyword">if</span> height[i - <span class="number">1</span>] &gt; left_max_height <span class="keyword">else</span> left_max_height</span><br><span class="line">            <span class="comment"># 求右边最高的墙高</span></span><br><span class="line">            right_max_height = <span class="number">0</span></span><br><span class="line">            right_max_height = max(height[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 当前列可容纳的水量</span></span><br><span class="line">            water = max(min(left_max_height, right_max_height) - height[i], <span class="number">0</span>)</span><br><span class="line">            water_sum += water</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water_sum</span><br></pre></td></tr></table></figure><hr><h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><ul><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            self._dict.update(&#123;str(i): i&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 使num1为长度较小的</span></span><br><span class="line">        <span class="keyword">if</span> len(num1) &gt; len(num2):</span><br><span class="line">            num1, num2 = num2, num1</span><br><span class="line">        num2 = self.str2int(num2)</span><br><span class="line">        <span class="comment"># 将num1的每一位与num2相乘</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num1)+<span class="number">1</span>):</span><br><span class="line">            res += self._dict[num1[-i]] * num2 * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""将str类型转化为int类型"""</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)+<span class="number">1</span>):</span><br><span class="line">            ret += self._dict[num[-i]] * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h1 id="44-TODO"><a href="#44-TODO" class="headerlink" title="44. TODO"></a>44. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><pre><code>输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p>说明:</p><pre><code>假设你总是可以到达数组的最后一个位置。</code></pre><blockquote><p>思路：考虑贪心算法，如何确定下一步的位置？考虑下下一步能够到的最远距离。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(idx)</span>:</span></span><br><span class="line">            <span class="string">"""输入当前idx, 返回当前应走到的索引"""</span></span><br><span class="line">            max_distance = <span class="number">0</span></span><br><span class="line">            go2idx = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历当前可以走的所有索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums[idx]+<span class="number">1</span>):</span><br><span class="line">                next_idx = idx + i  <span class="comment"># 下一位置的索引</span></span><br><span class="line">                <span class="keyword">if</span> next_idx &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> len(nums) - <span class="number">1</span></span><br><span class="line">                distance = next_idx + nums[next_idx]  <span class="comment"># 可以走的距离</span></span><br><span class="line">                <span class="keyword">if</span> distance &gt; max_distance:</span><br><span class="line">                    max_distance = distance</span><br><span class="line">                    go2idx = next_idx</span><br><span class="line">            <span class="keyword">return</span> go2idx</span><br><span class="line"></span><br><span class="line">        next_idx = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> next_idx &lt; len(nums)<span class="number">-1</span>:</span><br><span class="line">            next_idx = util(next_idx)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><blockquote><p>思路：用树结构思考，考虑深度优先遍历</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(mem, residual)</span>:</span></span><br><span class="line">            <span class="comment"># 如果没有剩余元素，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> residual:</span><br><span class="line">                res.append(mem)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(residual)):</span><br><span class="line">                residual_tmp = copy.deepcopy(residual)</span><br><span class="line">                residual_tmp.pop(i)</span><br><span class="line">                dfs(mem+[residual[i]], residual_tmp)</span><br><span class="line"></span><br><span class="line">        dfs([], nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="47-TODO"><a href="#47-TODO" class="headerlink" title="47. TODO"></a>47. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="48-TODO"><a href="#48-TODO" class="headerlink" title="48. TODO"></a>48. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="49-TODO"><a href="#49-TODO" class="headerlink" title="49. TODO"></a>49. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="50-TODO"><a href="#50-TODO" class="headerlink" title="50. TODO"></a>50. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode 41~50 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-PointNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html</id>
    <published>2020-01-09T06:56:01.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation"><a href="#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation" class="headerlink" title="PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation"></a>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</h2><ul><li>关键词: point cloud, deep learning</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>直接对点云进行学习 =&gt; 实现分类/分割</li></ul><ul><li>针对点云的深度学习算法需满足的特性:<ul><li><strong>无序性</strong>: 所有点无次序</li><li><strong>点与点之间的关系</strong>: 点与neighbor之间存在局部的结构关系</li><li><strong>变换下的不变性</strong>: 旋转/平移等不改变点云模型的整体类别和局部分割类别</li></ul></li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>提取点云的全局/局部特征<ul><li>全局特征: 表示形状类别的特征</li><li>局部特征: 每个点的特征</li></ul></li></ul><ul><li>T-Net: 将所有点对齐到一个规范空间中</li><li>用<strong>对称函数</strong> MaxPooling: 解决点云的无序性</li><li>对于Segmentation: 局部特征 + 全局特征 (Aggregation)</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/PointNet-Network.png" alt="Network" title="PointNet"></p><ul><li>输入的点数为 n</li><li>global feature 维度1024不是对应点数,而是模型整体的特征</li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>3D分类: ModelNet40</li><li>3D部件分割: ShapeNet的子集(16类)</li><li>3D场景分割: I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,M. Fischer, and S. Savarese. 3d semantic parsing of large-scale indoor spaces.</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>数据预处理<ul><li>在Mesh的表面均匀采样1024个点</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>3D 分类:<ul><li>accuracy</li></ul></li><li>3D 分割:<ul><li>mIoU</li></ul></li></ul><h3 id="4-Disadvantages"><a href="#4-Disadvantages" class="headerlink" title="4. Disadvantages"></a>4. Disadvantages</h3><p>未充分挖掘局部结构特征</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot;&gt;&lt;a href=&quot;#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&quot;&gt;&lt;/a&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: point cloud, deep learning&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-VoxNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html</id>
    <published>2020-01-09T06:38:39.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition"><a href="#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition" class="headerlink" title="VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition"></a>VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition</h2><ul><li>关键词: voxel, 3D deep learning</li><li>会议: IROS</li><li>源码: official √<ul><li><a href="https://github.com/MonteYang/VoxNet.pytorch" target="_blank" rel="external nofollow noopener noreferrer">我的复现: by PyTorch</a></li></ul></li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><p>针对Voxel的3d物体识别/分类</p><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><p>将在视频领域取得一定效果的3D CNN用于Voxel的特征提取</p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/3-VoxNet-Network.png" alt title="VoxNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>3种数据集:</p><ul><li>LiDAR data - Sydney Urban Objects</li><li>CAD data - ModelNet</li><li>RGBD data - NYUv2</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO:</p><h3 id="4-Advantages"><a href="#4-Advantages" class="headerlink" title="4. Advantages"></a>4. Advantages</h3><ul><li>表现性能超过了之前的 ShapeNet</li><li>参数比 ShapeNet 少一些  <blockquote><p>ShapeNet is a relatively large architecture, with over 12.4 million parameters, while VoxNet has less than 1 million.</p></blockquote></li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>计算性能受Voxel的分辨率限制: 当Voxel分辨率过高时,内存占用过高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot;&gt;&lt;a href=&quot;#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot; class=&quot;headerlink&quot; title=&quot;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&quot;&gt;&lt;/a&gt;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: voxel, 3D deep learning&lt;/li&gt;
&lt;li&gt;会议: IROS&lt;/li&gt;
&lt;li&gt;源码: official √&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MonteYang/VoxNet.pytorch&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;我的复现: by PyTorch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Voxel" scheme="http://monteyang.cn/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Ciss-Net</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html</id>
    <published>2020-01-09T06:28:22.000Z</published>
    <updated>2020-03-11T13:18:23.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context-Reinforced-Semantic-Segmentation"><a href="#Context-Reinforced-Semantic-Segmentation" class="headerlink" title="Context-Reinforced Semantic Segmentation"></a><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf" target="_blank" rel="external nofollow noopener noreferrer">Context-Reinforced Semantic Segmentation</a></h2><ul><li>关键词: 强化学习, image segmentation, context</li><li>会议: CVPR 2019</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>Context(上下文信息)在语义分割中至关重要, 挖掘图像中上下文信息</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>使用分割后的图片 p-maps 作为上下文信息的来源</li><li>该项工作提出Context-Net -&gt; 更好的挖掘上下文信息</li><li>将上下文信息的学习过程定义为马尔科夫决策问题(MDP), 使用强化学习方法进行优化</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/CissNet-Network.png" alt="Ciss_Net"></p><ul><li>Environment: <code>p-map</code></li><li>Agent: <code>Context Net</code><ul><li>State: $\{Y_I\}$</li><li>Action: $\{B_I\}$</li></ul></li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>ADE20K</li><li>Cityscapes</li><li>Pascal Context</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO</p><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><!-- ### 4. Advantages ### 5. Disadvantages -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context-Reinforced-Semantic-Segmentation&quot;&gt;&lt;a href=&quot;#Context-Reinforced-Semantic-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;Context-Reinforced Semantic Segmentation&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Context-Reinforced Semantic Segmentation&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: 强化学习, image segmentation, context&lt;/li&gt;
&lt;li&gt;会议: CVPR 2019&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="image segmentation" scheme="http://monteyang.cn/tags/image-segmentation/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-MeshNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html</id>
    <published>2020-01-09T03:18:28.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation"><a href="#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation" class="headerlink" title="MeshNet: Mesh Neural Network for 3D Shape Representation"></a>MeshNet: Mesh Neural Network for 3D Shape Representation</h2><ul><li>关键词: Mesh, 3D shape classification/retrieval</li><li>会议: AAAI 2018</li><li>源码: √</li></ul><a id="more"></a><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>PoinNet</li><li>KC-Net</li></ul><blockquote><p>Related Work:</p><ul><li>Mesh Feature Extraction</li><li>Deep Learning Methods for 3D Shape Representation<ul><li>voxel-based</li><li>view-based</li><li>point-based</li><li>fusion method</li></ul></li></ul></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h3><ul><li>直接对 Mesh 进行形状表示的学习</li><li>应用于 3D shape classification/retrieval</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>将一个face视作一个单元</li><li><p>face的特征分为:</p><ul><li><strong>空间特征</strong></li><li><strong>结构特征</strong></li></ul></li><li><p>针对<strong>空间特征</strong>和<strong>结构特征</strong>分别提出:</p><ul><li>Spatial Descriptor<ul><li>面的中心点作为输入</li><li>采用与point cloud类似的处理方法</li></ul></li><li>Structural Descriptor<ul><li><strong>face rotate convolution</strong></li><li><strong>face kernel correlation</strong></li></ul></li></ul></li><li><p>整合空间特征和结构特征: 提出 Mesh Convolution</p></li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/MeshNet-Network.png" alt="MeshNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>ModelNet40</p><ul><li>for 3D classification/retrieval</li><li>40类别</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>Mesh模型需先简化至<strong>不多于1024个面</strong>(以面为单位,类似PointNet中以点为单位)</li><li>由于Mesh的面数不恒定, 随机选取填满1024个面 for batch training</li><li>数据增强: 所有点按高斯分布进行随机平移: N(0, 0.01)</li><li>for Classification:<ul><li>global features 后添加 MLP(512, 256, 40): 40表示40个类别</li><li>MLP的最后两层添加dropout层: drop概率为0.5</li></ul></li><li>for Retrieval:<ul><li>global features 直接计算 L2 距离</li></ul></li><li>训练时的超参数:<ul><li>SGD optimizer</li><li>initial learning rate 0.01</li><li>momentum 0.9</li><li>weight decay 0.0005</li><li>batch size 64.</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>Classification: Accuracy</li><li>Retrieval: mAP</li></ul><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><p>TODO:</p><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><p><img data-src="/images/MeshNet-exp-results.png" alt="实验结果" title="ModelNet实验结果"><br>&lt;!— ### 4. Advantages</p><ul><li>将point的方法应用于Mesh的特征提取(空间提取, KC)</li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>空间特征提取 不仅考虑面的中心点, 可以加入中心点周围的三个点的信息, 可能会有所提升.</li><li>当前面和周围三个面可能会有相似的特征.可否进行替换 —&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot;&gt;&lt;a href=&quot;#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot; class=&quot;headerlink&quot; title=&quot;MeshNet: Mesh Neural Network for 3D Shape Representation&quot;&gt;&lt;/a&gt;MeshNet: Mesh Neural Network for 3D Shape Representation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: Mesh, 3D shape classification/retrieval&lt;/li&gt;
&lt;li&gt;会议: AAAI 2018&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Mesh" scheme="http://monteyang.cn/tags/Mesh/"/>
    
  </entry>
  
  <entry>
    <title>Paper Reading Plan</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html</id>
    <published>2020-01-09T03:02:40.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h2><ul><li>[x] AlexNet</li><li>[x] VGGNet</li><li>[x] ResNet</li><li>[x] InceptionNet</li><li>[ ] DenseNet</li><li>[ ] SENet</li></ul><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><ul><li>[x] MeshNet</li><li>[ ] MeshCNN</li></ul><h2 id="Voxel"><a href="#Voxel" class="headerlink" title="Voxel"></a>Voxel</h2><ul><li>[ ] 3D ShapeNet</li><li>[ ] VoxNet</li><li>[ ] OctNet</li><li>[ ] FPNN</li><li>[ ] O-CNN</li></ul><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>[X] PointNet</li><li>[x] PointNet++</li><li>[x] KC-Net</li><li>[ ] PointSIFT</li><li>[ ] Point-Voxel</li><li>[ ] PointGrid</li></ul><h2 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h2><ul><li>[ ] DeepSDF</li></ul><h2 id="Reinfocement-Learning"><a href="#Reinfocement-Learning" class="headerlink" title="Reinfocement Learning"></a>Reinfocement Learning</h2><ul><li>[ ] DDPG</li><li>[ ] MADDPG</li></ul><h2 id="CNN-basic"><a href="#CNN-basic" class="headerlink" title="CNN-basic"></a>CNN-basic</h2><ul><li>[x] Tricks-of-CNN</li></ul><h2 id="Image-Segmentation"><a href="#Image-Segmentation" class="headerlink" title="Image Segmentation"></a>Image Segmentation</h2><ul><li>[ ] FCN</li><li>[ ] U-Net</li><li>[ ] SegNet</li><li>[ ] DeepLab系列</li><li>[ ] Fully Convolutional DenseNet</li><li>[ ] E-Net</li><li>[ ] Link-Net</li><li>[ ] Mask R-CNN</li><li>[ ] PSPNet</li><li>[ ] RefineNet</li><li>[ ] HR-Net</li><li>[ ] Ciss-Net</li></ul><!-- ---- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation-CVPR2017-论文链接-tensorflow代码-pytorch代码- PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space-NIPS2017-论文链接-tensorflow代码-pytorch代码- Escape from Cells: Deep Kd-Networks for the Recognition of 3D Point Cloud Models-ICCV2017-论文链接-pytorch代码- KCNet: Mining Point Cloud Local Structures by Kernel Correlation and Graph Pooling-CVPR2018-论文链接-caffe代码-pytorch代码- Pointwise Convolutional Neural Networks-CVPR2018-论文链接-tensorflow代码- SO-Net: Self-Organizing Network for Point Cloud Analysis-CVPR2018-论文链接-pytorch代码- Recurrent Slice Networks for 3D Segmentation of Point Clouds-CVPR2018-论文链接-pytorch代码- SPLATNet: Sparse Lattice Networks for Point Cloud Processing-CVPR2018-l论文链接-caffe代码-pytorch代码- Large-scale Point Cloud Semantic Segmentation with Superpoint Graphs-CVPR2018-论文链接-pytorch代码- Dynamic Graph CNN for Learning on Point Cloud-arxiv2018-论文链接-代码链接- Local Spectral Graph Convolution for Point Set Feature Learning-ECCV2018-论文链接-tensorflow代码- SpiderCNN: Deep Learning on Point Sets with Parameterized Convolutional Filters-ECCV2018-论文链接-tensorflow代码- Point Convolutional Neural Networks by Extension Operators-SIGGRAPH 2018-论文链接-tensorflow代码- PointCNN: Convolution On X-Transformed Points-NeurIPS 2018-论文链接-tensorflow代码-mxnet代码-pytorch代码- PointSIFT: A SIFT-like Network Module for 3D Point Cloud Semantic Segmentation-arxiv2018-论文链接-tensorflow代码-pytorch代码- PointConv: Deep Convolutional Networks on 3D Point Clouds-arxiv2018-论文链接- Adversarial Autoencoders for Generating 3D Point Clouds-arxiv2018-论文链接- Modeling Local Geometric Structure of 3D Point Clouds using Geo-CNN-论文链接- Supervised Fitting of Geometric Primitives to 3D Point Clouds-CVPR2019-l论文链接-tensorflow代码- Multi-view Point Cloud Registration with Adaptive Convergence Threshold and its Application on 3D Model Retrieval-论文链接- Iterative Transformer Network for 3D Point Cloud-arxiv2018-论文链接- DeepMapping: Unsupervised Map Estimation From Multiple Point Clouds-arxiv2018-论文链接- CAPNet: Continuous Approximation Projection For 3D Point Cloud Reconstruction Using 2D Supervision-论文链接-AAAI2019-代码链接- Increasing the Capability of Neural Networks for Surface Reconstruction from Noisy Point Clouds-arxiv2018-论文链接- Topology-Aware Surface Reconstruction for Point Clouds-arxiv2018-论文链接- Nesti-Net: Normal Estimation for Unstructured 3D Point Clouds using Convolutional Neural Networks-arxiv2018-论文链接- Inferring Point Clouds from Single Monocular Images by Depth Intermediation-arxiv2018-论文链接- Learning Saliency Maps for Adversarial Point-Cloud Generation-arxiv2019-论文链接- A Graph-CNN for 3D Point Cloud Classification- ICASSP 2018-论文链接-tensorflow代码- GSPN: Generative Shape Proposal Network for 3D Instance Segmentation in Point Cloud-arxiv2018-论文链接- PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud-arxiv2018-论文链接- Deep RBFNet: Point Cloud Feature Learning using Radial Basis Functions-arxiv2018-论文链接- IPOD: Intensive Point-based Object Detector for Point Cloud-arxiv2018-论文链接- PointPillars: Fast Encoders for Object Detection from Point Clouds-arxiv2018-论文链接- 3D Point Cloud Learning for Large-scale Environment Analysis and Place Recognition-arxiv2018-论文链接- 3D Point Cloud Denoising via Bipartite Graph Approximation and Reweighted Graph Laplacian-arxiv2018-论文链接- Casualty Detection from 3D Point Cloud Data for Autonomous Ground Mobile Rescue Robots-SSRR)2018-论文链接- Deflecting 3D Adversarial Point Clouds Through Outlier-Guided Removal-arxiv2018-论文链接- Machine learning enables polymer cloud-point engineering via inverse design-arxiv2018-论文链接- 3D Convolution on RGB-D Point Clouds for Accurate Model-free Object Pose Estimation-arxiv2018-论文链接- Feature Preserving and Uniformity-controllable Point Cloud Simplification on Graph-arxiv2018-论文链接- GeoNet: Deep Geodesic Networks for Point Cloud Analysis-CVPR2019-论文链接- POINTCLEANNET: Learning to Denoise and Remove Outliers from Dense Point Clouds-arxiv2018-论文链接-pytorch代码- Generic Primitive Detection in Point Clouds Using Novel Minimal Quadric Fits-T-PAMI2019-论文链接- Fast 3D Line Segment Detection From Unorganized Point Cloud-arxiv2019-论文链接- Extending Adversarial Attacks and Defenses to Deep 3D Point Cloud Classifiers-arxiv2019-论文链接-tensorflow代码- Skeletonisation Algorithms for Unorganised Point Clouds with Theoretical Guarantees-arxiv2019-论文链接- Automatic normal orientation in point clouds of building interiors-arxiv2019-论文链接- Fitting 3D Shapes from Partial and Noisy Point Clouds with Evolutionary Computing-arxiv2019-论文链接- Context Prediction for Unsupervised Deep Learning on Point Clouds-arxiv2019-论文链接- Dense 3D Point Cloud Reconstruction Using a Deep Pyramid Network-WACV 2019-论文链接- Points2Pix: 3D Point-Cloud to Image Translation using conditional Generative Adversarial Networks-arxiv2019-l论文链接- NeuralSampler: Euclidean Point Cloud Auto-Encoder and Sampler-arxiv2019-l论文链接- Embedded Delaunay triangulations for point clouds of surfaces in-arxiv2019-l论文链接- 3D point cloud registration with shape constraint-ICIP 2017-论文链接- Occupancy-map-based rate distortion optimization for video-based point cloud compression-arxiv2019-论文链接- 3D Graph Embedding Learning with a Structure-aware Loss Function for Point Cloud Semantic Instance Segmentation-arxiv2019-论文链接- PIXOR: Real-time 3D Object Detection from Point Clouds- CVPR2018-论文链接-pytorch代码- Multi-view Incremental Segmentation of 3D Point Clouds for Mobile Robots-arxiv2019-论文链接- Point cloud denoising based on tensor Tucker decomposition-CVPR2019-l论文链接- Associatively Segmenting Instances and Semantics in Point Clouds-CVPR2019-论文链接- Zero-shot Learning of 3D Point Cloud Objects-MVA2019-论文链接- Octree guided CNN with Spherical Kernels for 3D Point Clouds-arxiv2019-论文链接- Real-time Multiple People Hand Localization in 4D Point Clouds-arxiv2019-论文链接- Variational Graph Methods for Efficient Point Cloud Sparsification-arxiv2019-代码链接- HoloCast: Graph Signal Processing for Graceful Point Cloud Delivery-arxiv2019-论文链接- Fast Registration for cross-source point clouds by using weak regional affinity and pixel-wise refinement-ICME 2019-论文链接- PointNetLK: Robust & Efficient Point Cloud Registration using PointNet-arxiv2019-论文链接- Neural Style Transfer for Point Clouds-arxiv2019-论文链接- OREOS: Oriented Recognition of 3D Point Clouds in Outdoor Scenarios-arxiv2019-论文链接- Learning Convolutional Transforms for Lossy Point Cloud Geometry Compression-arxiv2019-论文链接- Monocular 3D Object Detection with Pseudo-LiDAR Point Cloud-论文链接-arxiv2019- FVNet: 3D Front-View Proposal Generation for Real-Time Object Detection from Point Clouds-论文链接-arxiv2019- Unpaired Point Cloud Completion on Real Scans using Adversarial Training-论文链接-arxiv2019- USIP: Unsupervised Stable Interest Point Detection from 3D Point Clouds-论文链接-arxiv2019-代码链接- MortonNet: Self-Supervised Learning of Local Features in 3D Point Clouds-论文链接-arxiv2019- Discrete Rotation Equivariance for Point Cloud Recognition-论文链接-ICRA 2019-代码链接- JSIS3D: Joint Semantic-Instance Segmentation of 3D Point Clouds with Multi-Task Pointwise Networks and Multi-Value Conditional Random Fields-论文链接-CVPR 2019(oral)-代码链接- DeepPoint3D: Learning Discriminative Local Descriptors using Deep Metric Learning on 3D Point Clouds-论文链接-arxiv2019- A Dataset for Semantic Segmentation of Point Cloud Sequences-论文链接-arxiv2019- Point Cloud Oversegmentation with Graph-Structured Deep Metric Learning-论文链接-CVPR2019- Generalizing discrete convolutions for unstructured point clouds-论文链接-arxiv2019- 3D Point Cloud Denoising via Deep Neural Network based Local Surface Estimation-论文链接-arxiv2019- Complexer-YOLO: Real-Time 3D Object Detection and Tracking on Semantic Point Clouds-论文链接-arxiv2019- Total Denoising: Unsupervised Learning of 3D Point Cloud Cleaning-论文链接-arxiv2019- 3D Object Recognition with Ensemble Learning — A Study of Point Cloud-Based Deep Learning Models-论文链接-arxiv2019- Deep Hough Voting for 3D Object Detection in Point Clouds-论文链接-arxiv2019- 2D3D-MatchNet: Learning to Match Keypoints Across 2D Image and 3D Point Cloud-论文链接-arxiv2019- PCAN: 3D Attention Map Learning Using Contextual Information for Point Cloud Based Retrieval-论文链接-CVPR2019- Graph-based Inpainting for 3D Dynamic Point Clouds-论文链接-arxiv2019- 3D Dynamic Point Cloud Denoising via Spatio-temporal Graph Modeling-论文链接-arxiv2019- RL-GAN-Net: A Reinforcement Learning Agent Controlled GAN Network for Real-Time Point Cloud Shape Completion-论文链接-cvpr2019-代码链接- Unsupervised Feature Learning for Point Cloud by Contrasting and Clustering With Graph Convolutional Neural Network-论文链接-arxiv2019- Loop-Closure Detection Based on 3D Point Cloud Learning for Self-Driving Industry Vehicles-论文链接-arxiv2019- Oriented Point Sampling for Plane Detection in Unorganized Point Clouds-论文链接-ICRA2019- Deep Closest Point: Learning Representations for Point Cloud Registration-论文链接-arxiv2019- Deep AutoEncoder-based Lossy Geometry Compression for Point Clouds-论文链接-arxiv2019- DeepICP: An End-to-End Deep Neural Network for 3D Point Cloud Registration-论文链接-arxiv2019- Deep Unsupervised Learning of 3D Point Clouds via Graph Topology Inference and Filtering-论文链接-arxiv2019- Cooper: Cooperative Perception for Connected Autonomous Vehicles based on 3D Point Clouds-论文链接 -ICDCS 2019- 3D Point Cloud Generative Adversarial Network Based on Tree Structured Graph Convolutions-论文链接-arxiv2019- SAWNet: A Spatially Aware Deep Neural Network for 3D Point Cloud Processing-论文链接-arxiv2019- A Two-stage Classification Method for High-dimensional Data and Point Clouds-论文链接-arxiv2019- GAPNet: Graph Attention based Point Neural Network for Exploiting Local Feature of Point Cloud-论文链接-arxiv2019- RIU-Net: Embarrassingly simple semantic segmentation of 3D LiDAR point cloud-论文链接-arxiv2019- Domain Adaptation for Vehicle Detection from Bird’s Eye View LiDAR Point Cloud Data-论文链接-Under review for IEEE SMC 2019- Robust Point Cloud Based Reconstruction of Large-Scale Outdoor Scenes-论文链接-CVPR2019- Efficient Curvature Estimation for Oriented Point Clouds-论文链接-arxiv2019- Leveraging binding-site structure for drug discovery with point-cloud methods-论文链接-arxiv2019- NPTC-net: Narrow-Band Parallel Transport Convolutional Neural Network on Point Clouds-论文链接-arxiv2019- Partial Computing Offloading Assisted Cloud Point Registration in Multi-robot SLAM-论文链接-arxiv2019- Point Clouds Learning with Attention-based Graph Convolution Networks-论文链接-arxiv2019- Learning Object Bounding Boxes for 3D Instance Segmentation on Point Clouds-论文链接-arxiv2019- Direct structural analysis of domains defined by point clouds-论文链接-arxiv2019- Learning Shape Representation on Sparse Point Clouds for Volumetric Image Segmentation-论文链接-MICCAI 2019 --><!--Templete---分界线---## 文章信息- 标题:- 关键词:- 会议:- 源码: √## 相关文章:> Related Work:## Note### 1. Plroblem### 2. Method#### Network Structure### 3. Experiment#### 3.1 Dataset#### 3.2 Implemention#### 3.3 Metric#### 3.4 Ablation Study#### 3.5 Result<!--### 4. Advantages### 5. Disadvantages-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Neural-Network&quot;&gt;&lt;a href=&quot;#Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Neural Network&quot;&gt;&lt;/a&gt;Neural Network&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[x] AlexNet&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="计划" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="paper reading plan" scheme="http://monteyang.cn/tags/paper-reading-plan/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31-40题</title>
    <link href="http://monteyang.cn/LeetCode-31-40%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-31-40%E9%A2%98.html</id>
    <published>2020-01-08T02:56:02.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>31~40</code> 题</p></blockquote><a id="more"></a><hr><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><blockquote><p>思路:<br>字典序算法</p><ol><li>从右往左, 找出第一个小于右邻的数 <code>list[x]</code>;</li><li>从右往左, 找出第一个比 <code>list[x]</code> 大的数 <code>list[y]</code>;</li><li>交换 <code>list[x]</code> 和 <code>list[y]</code>;</li><li>将 <code>list[x]</code> 后面的序列从小到大排序. </li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在下一个更大的字典序(即当前序列为最大的字典序), 则将序列转为最小字典序</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">-1</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                y = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 3, 4</span></span><br><span class="line">        nums[x], nums[y] = nums[y], nums[x]</span><br><span class="line">        nums[x+<span class="number">1</span>:] = sorted(nums[x+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><blockquote><p>思路:</p><ol><li>用栈实现括号匹配</li><li>用数组保存一个有效括号的索引值</li><li>对所有索引值进行排序</li><li>找出连续索引长度中的最长长度</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># ()()()(()()()(()))</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        idxs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># 如果栈为空时</span></span><br><span class="line">            <span class="keyword">if</span> stack == []:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 如果栈非空时</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    idxs.append(i)</span><br><span class="line">                    idxs.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line"></span><br><span class="line">        idxs.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> idxs: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(idxs)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> idxs[j+<span class="number">1</span>] - idxs[j] == <span class="number">1</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> max_length &lt; length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(length, max_length)</span><br></pre></td></tr></table></figure><hr><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p><p>示例 1:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums = [4,5,6,7,0,1,2]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 找出最小值的索引</span></span><br><span class="line">        min_idx = self.search_min_idx(nums)</span><br><span class="line">        <span class="keyword">if</span> min_idx != <span class="number">0</span>:</span><br><span class="line">            nums = nums[min_idx:] + nums[:min_idx]</span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        tmp_idx = self.bin_search(nums, target)</span><br><span class="line">        <span class="keyword">if</span> tmp_idx == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> (tmp_idx + min_idx) % len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_min_idx</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> </span></span><br><span class="line">        <span class="keyword">return</span> nums.index(min(nums))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        二分查找法:</span></span><br><span class="line"><span class="string">            - 如果nums中存在目标值, 则返回该值的index;</span></span><br><span class="line"><span class="string">            - 如果nums中不存在目标值, 则返回 -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h1 id="34-TODO"><a href="#34-TODO" class="headerlink" title="34. TODO"></a>34. TODO</h1><hr><h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><pre><code>输入: [1,3,5,6], 5输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [1,3,5,6], 2输出: 1</code></pre><p>示例 3:</p><pre><code>输入: [1,3,5,6], 7输出: 4</code></pre><p>示例 4:</p><pre><code>输入: [1,3,5,6], 0输出: 0</code></pre><blockquote><p><strong>思路</strong></p><ol><li>扫一次, 若当前值小于 <code>target</code>, 则跳过; 若当前值大于等于 <code>target</code>, 则返回当前索引</li><li>若所有元素都小于 <code>target</code>, 则返回<code>(最大索引+1)</code></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><hr><h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1:</p><pre><code>输入:[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true</code></pre><p>示例 2:</p><pre><code>输入:[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。    但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><pre><code>一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。给定数独永远是 9x9 形式的。</code></pre><blockquote><p><strong>思路</strong></p><ol><li>数独板块中共有 <strong>9行 \ 9列 \ 9个小块</strong>, <strong>每行 \ 每列 \ 每个小块</strong> 都建立一个 hash map, 用来记录该<strong>行\列\小块</strong>中数字对应的个数</li><li>遍历所有 9*9 个元素:<ol><li>一旦 hash map 中存在大于1个的元素, 则不满足数独条件, 返回 <code>false</code>;</li><li>如果遍历结束后, 都未出现 <code>false</code>, 则满足数独条件.</li></ol></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        small_box = [[&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]  <span class="comment"># 3*3个 small box</span></span><br><span class="line">        row = [&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 9行</span></span><br><span class="line">        colum = copy.deepcopy(row)  <span class="comment"># 9列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx_row, r <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> idx_colum, num <span class="keyword">in</span> enumerate(r):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">'.'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前元素为 num, 判断该元素属于哪个small_box</span></span><br><span class="line">                <span class="comment"># 如果对应的small box中没有该数, 设置hash中的key的value为1</span></span><br><span class="line">                <span class="comment"># 如果对应的small box已存在该数, 则返回错误</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>]:</span><br><span class="line">                    small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前row中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> row[idx_row]:</span><br><span class="line">                    row[idx_row][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前列中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> colum[idx_colum]:</span><br><span class="line">                    colum[idx_colum][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="37-TODO"><a href="#37-TODO" class="headerlink" title="37. TODO"></a>37. TODO</h1><hr><h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221</li></ol><p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>示例 1:</p><pre><code>输入: 1输出: &quot;1&quot;解释：这是一个基本样例。</code></pre><p>示例 2:</p><pre><code>输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre><blockquote><p>思路：<br>迭代求解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        s = <span class="string">'1*'</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            s = self.util(s)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">""" 输入s, 返回s的下一个外观数列, 注意s的最后一个字符是'*'.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            s (string): 以 * 结尾的字符串</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 下一个外观数列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (str(cnt) + s[i - <span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        s = res + <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><hr><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><pre><code>所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><pre><code>输入: candidates = [2,3,6,7], target = 7,所求解集为:[⁠ [7],⁠ [2,2,3]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,3,5], target = 8,所求解集为:[[2,2,2,2],[2,3,3],[3,5]]</code></pre><blockquote><p>思路: 回溯法 + 利用树的数据结构判断</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        candidates.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(candidates, cur_sum, tmp_list)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> candidates == []: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表之和等于 target, 加入res</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(tmp_list)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表元素之和大于 target，直接返回（剪枝）</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前列表元素之和小于 target，继续添加元素</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    _tmp_list = copy.deepcopy(tmp_list)</span><br><span class="line">                    _tmp_list.append(c)</span><br><span class="line">                    util(candidates[i:], cur_sum+c, _tmp_list)</span><br><span class="line">        </span><br><span class="line">        util(candidates, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="40-组合之和II"><a href="#40-组合之和II" class="headerlink" title="40. 组合之和II"></a>40. 组合之和II</h1><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1:</p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[[1,2,2],[5]]</code></pre><blockquote><p>思路:<br>与上一题相似, 多增加去重步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()  <span class="comment"># [1,1,2,5,6,]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(cur_sum, cur_list, candidates)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(cur_list)</span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> c == candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                    _cur_list = cur_list[:]</span><br><span class="line">                    _cur_list.append(c)</span><br><span class="line">                    back_track(cur_sum+c, _cur_list, candidates[i+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        back_track(<span class="number">0</span>, [], candidates)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;31~40&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2019年的总结</title>
    <link href="http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html</id>
    <published>2020-01-04T15:15:35.000Z</published>
    <updated>2020-03-03T15:28:58.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h1><p>转眼间，在北邮的研究生生涯已经过半，今年对我来说最最要的两件事：修满学分和开题，完成的都还算顺利。</p><p><strong>关于科研</strong>。从今年4月开始，和博士师兄进行科研，做三维网格模型和强化学习的结合，虽然最终实验效果没有预想中那样理想，但这个过程中收获编程经验和师兄的指导，对我来说都是宝贵的，因为从开始就意识到了导师可能放养，分给实验室其他导师，想做算法的话难度就很大，所以师兄算是我的一位导师了。</p><p><strong>关于编程</strong>。在和师兄做项目的这个阶段，一直是使用Python编程，这一年下来进步了很多，从一开始胡乱写代码，到现在能开始考虑代码的效率、整洁和可读性。在这之前看过一点数据结构，感觉很难就看不下去了，今年再看数据结构的时候，虽然还是很难，但有些东西是有些理解了，也算是种进步吧。最近还发现遗忘东西很快，学习也没有考研时的那种毅力了，所以搭建了博客，一方面是把学的东西记录下来，另一方面也希望借着写博客的名义，监督自己完成学习计划。</p><p><strong>关于未来就业</strong>。随着今年的秋招算法岗的火爆，劝退的趋势愈发猛烈，有朋友说工作是一定能找到的，也有朋友劝我做两手准备。其实面对算法和开发，当我问自己兴趣在哪的时候，并没有答案，反思了一下，发觉自己可能只是喜欢写代码，喜欢把代码变得整洁，喜欢debug后跑起来的结果，对于代码能做什么事反倒是没有太关注，而且现在在实验室里只是改别人的框架，套上自己的想法进行实验，还不知道真正与工业界的差别有多大，可能只有真正地工作上才会有答案。</p><!-- **关于校园生活**。对我来说研究生的三年是短暂而宝贵的，考研到北邮对我来说是来之不易的，在来到北邮后，遇见了很多厉害的人。有很多有才华的人、自信的人在这个校园发光发热。每次晚上回宿舍时总有一些实验室的灯还在亮着，咖啡店里无时不刻都有人在讨论着项目方案、代码和Presentation……之前听“比你优秀的人比你还努力”当作是个段子，没想到实际上这种人竟然这么多。总之，这个环境有一种让人催着自己不断努力的魔力，让我觉得这三年的时间是宝贵的、短暂的。 --><h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><ul><li>[√] 杭州</li><li>[√] 秦皇岛</li><li>[√] 大连</li><li>[√] 上海</li><li>[√] 南京</li></ul><h1 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h1><p>从2016年至今，和女朋友在一起有3年多了，心态也逐渐变得成熟，慢慢地学会了帮助对方调节情绪和压力，而且最近忽然觉得，其实所有情侣间所有的吵架都是两个人情绪管理能力不好的体现，如果有一方的情绪管理很强，那么争吵就无法引发，因为情绪管理的能力不仅体现在懂得调解自身的情绪，更体现在能够帮助他人疏解情绪。在知乎上看到，情商高的体现不是意味着会说好话、阿谀奉承，而是具备管理情绪的能力，正是这样，如果一个人具备强大的情绪管理能力，那么这个人的情商一定非常高。之前和女朋友关于毕业去哪个城市这个问题意见不同，现在我也明白了其中缘由，希望两个人都能顺利在沈阳找到一份合适的工作。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p><strong>有关坚持与时间</strong>。关于“坚持的意义”，最初的体会是从考研二战那年开始，然而当今年读到《暗时间》这本书，这种体会更加深刻。回顾过去，其实真正坚持下来的事情没有几件，比如大三时来北京实习做了一个月电气设计，学会了些CAD的快捷键和画图方法，当毕业面临就业时，却没坚持找一份电气设计，现在早就忘得一干二净。每一项坚持都需要时间上的投资，“<em>1万小时定律</em>”说的是想要成为一个领域的专家，需要付出大概1万小时的努力。不断地切换自己想从事的工作，每件事都没坚持下来，虽然美其名曰是不喜欢，但在一定程度上浪费了时间。时间的成本是极高的，就好比现在爆红的那些00后的歌手或者明星，哪一个不是从小就开始坚持自己热爱的事业。从读研开始，才真正意义上接触编程，今后还想靠它作为谋生手段，这就意味着在这件事上，需要比别人更多的时间以及坚持。这个过程一定很难，但更为重要的一句话是，<em>“种一棵树最好的时间是十年前，其次是现在”</em>。</p><p><strong>有关所谓的成功和失败</strong>。曾经对于成功和失败看得很重，一件事没有做好就会懊悔、消极，陷入心态崩了的情形。然而现在越来越觉得，失败是世界上的一种常态，成功才是真正的偶然，但这些偶然中不是超凡的天赋，就是“超凡”的努力。而且一件事的失败，如果不是外界的原因，就是自身的原因。如果是自身的原因，那就没有权利情绪消极，如果是外界的原因，那连情绪消极的意义都没有。</p><p><strong>有关“重复”</strong>。之前看过一个记录片，讲的是“重复”的重要性，里面举了教徒每天都要按时背诵经文的例子。仔细想来，学习的过程就是在不断的重复。上学的时候老师布置作业、学期考试，都是让学生不断的重复、加深印象，这种不停的重复，在我的理解中就是一种“背诵”，在脑海中不停的演练。小时候学理科，总有人说这些理科的东西不需要背，确实一些简单的原理不需要背，但有一些公式是肯定要背的，做题的过程就是在加深对公式适用场合的印象，我觉得也是一种背诵。“一万小时定律”只告诉我们要坚持一万小时，但没说一万小时里都要做什么，目前我能想到的答案就是重复。</p><!-- # 2020今年要做的事情大概有：帮助她顺利毕业、投一篇小论文、找一份在沈阳的工作、看一场演唱会、完成一两段旅行。 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学业&quot;&gt;&lt;a href=&quot;#学业&quot; class=&quot;headerlink&quot; title=&quot;学业&quot;&gt;&lt;/a&gt;学业&lt;/h1&gt;&lt;p&gt;转眼间，在北邮的研究生生涯已经过半，今年对我来说最最要的两件事：修满学分和开题，完成的都还算顺利。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于科研&lt;
      
    
    </summary>
    
    
      <category term="总结与随感" scheme="http://monteyang.cn/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="总结" scheme="http://monteyang.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21-30题</title>
    <link href="http://monteyang.cn/LeetCode-21-30%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-21-30%E9%A2%98.html</id>
    <published>2020-01-04T13:42:00.000Z</published>
    <updated>2020-02-18T15:22:56.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>21~30</code>题</p></blockquote><a id="more"></a><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        head = ListNode(<span class="string">"#"</span>)</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> (p2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p1) <span class="keyword">or</span> (p1 <span class="keyword">and</span> (p1.val &lt;= p2.val)):</span><br><span class="line">                cur.next = ListNode(p1.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> (p1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p2) <span class="keyword">or</span> (p2 <span class="keyword">and</span> (p2.val &lt; p1.val)):</span><br><span class="line">                cur.next = ListNode(p2.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></h2><h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><pre><code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><blockquote><p>思路:<br>回溯法,利用递归生成括号.</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">                           l0 r0</span></span><br><span class="line"><span class="string">                        /          \</span></span><br><span class="line"><span class="string">                       (          </span></span><br><span class="line"><span class="string">                    l1 r0           </span></span><br><span class="line"><span class="string">                    /   \        </span></span><br><span class="line"><span class="string">                  ((     ()         </span></span><br><span class="line"><span class="string">                l2 r0   l1 r1</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(cur_str, n_lb, n_rb)</span>:</span></span><br><span class="line">            <span class="comment"># 超出括号数量则终止</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n <span class="keyword">or</span> n_rb &gt; n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 左右括号数量均达到n,则添加到res</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb == n:</span><br><span class="line">                res.append(cur_str)</span><br><span class="line">            <span class="comment"># 左右括号数量相等时,当前string只能添加'(',剪枝?</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">            <span class="comment"># 左括号大于右括号时,当前string可以添加'('或')'</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">                util(cur_str+<span class="string">')'</span>, n_lb, n_rb+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 左括号小于右括号则返回</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &lt; n_rb:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        util(<span class="string">''</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><pre><code>输入:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><blockquote><p>思路:<br>先对所有链表结点中的value进行排序,然后根据排序后的value生成一个长链表.</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 特殊情况: lists为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对所有val进行排序</span></span><br><span class="line">        val_all = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    val_all.append(node.val)</span><br><span class="line">                    node = node.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val_all = sorted(val_all)</span><br><span class="line">        <span class="comment"># 生成整个链表</span></span><br><span class="line">        head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> val_all:</span><br><span class="line">            node.next = ListNode(v)</span><br><span class="line">            node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></h2><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><blockquote><p>思路:<br>两两交换结点:添加1个头和1个尾,以便交换中间的两个结点.</p></blockquote><h2 id="-3"><a href="#-3" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        p_head  -&gt;   1    -&gt;     2    -&gt;    3   -&gt;  4</span></span><br><span class="line"><span class="string">        (p)     -&gt;   q    -&gt;     r    -&gt;    s </span></span><br><span class="line"><span class="string">                          -&gt;    (p)   -&gt;    q   -&gt;  r </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置头结点,方便后续处理</span></span><br><span class="line">        p_head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        p_head.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如图设置p,q,r,s的指向</span></span><br><span class="line">        p = p_head</span><br><span class="line">        q = p.next</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:  <span class="comment"># 奇数个结点则跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 交换</span></span><br><span class="line">            s = r.next</span><br><span class="line">            r.next = q</span><br><span class="line">            q.next = s</span><br><span class="line">            p.next = r</span><br><span class="line">            <span class="comment"># 移动指针p的指向</span></span><br><span class="line">            p = p.next.next</span><br><span class="line">            q = p.next</span><br><span class="line">        <span class="comment"># 必须返回p_head.next, 不能返回head, 因为head已经在链表中被交换.</span></span><br><span class="line">        <span class="keyword">return</span> p_head.next</span><br></pre></td></tr></table></figure></h2><h1 id="k-个一组翻转链表"><a href="#k-个一组翻转链表" class="headerlink" title="k-个一组翻转链表"></a>k-个一组翻转链表</h1><p>TODO</p><hr><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><pre><code>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:</p><ol><li>利用快慢指针: </li><li>利用排好序的性质: 类似栈,相等则弹出</li></ol></blockquote><h2 id="-4"><a href="#-4" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        p = - float(<span class="string">"inf"</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 如果下一个数和当前指向的元素相等, 删除下一个数</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] == p:</span><br><span class="line">                    <span class="keyword">del</span> nums[i]</span><br><span class="line">                <span class="comment"># 如果不等, 保留</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p = nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure></h2><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p>给定一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地</strong>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><pre><code>给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:<br>快慢指针</p></blockquote><h2 id="-5"><a href="#-5" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果第i个元素等于目标值val, 跳过</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果第i个元素不等于目标值val, 从头依次添加到原list中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure></h2><h1 id="实现-str-str"><a href="#实现-str-str" class="headerlink" title="实现-str-str"></a>实现-str-str</h1><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2</code></pre><p>示例 2:</p><pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1</code></pre><p><strong>说明:</strong><br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)-len(needle)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>TODO: KMP</p><hr><h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>示例 1:</p><pre><code>输入: dividend = 10, divisor = 3输出: 3</code></pre><p>示例 2:</p><pre><code>输入: dividend = 7, divisor = -3输出: -2</code></pre><p>说明:</p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</li></ul><blockquote><p>思路:<br>倍增再相减,类似二分查找</p></blockquote><h2 id="-6"><a href="#-6" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(dividend, divisor)</span>:</span></span><br><span class="line">            <span class="string">""" 除数倍增(×2), 获取被除数与除数间最大的2次幂倍数 """</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> dividend &gt; divisor*i*<span class="number">2</span>:</span><br><span class="line">                    i *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="comment"># 获取结果的符号</span></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        dividend = abs(dividend)</span><br><span class="line">        divisor = abs(divisor)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            _j = util(dividend, divisor)</span><br><span class="line">            j += _j</span><br><span class="line">            dividend = dividend - _j*divisor</span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">if</span> sign*j &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> sign*j &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">                <span class="keyword">return</span> sign * j</span><br></pre></td></tr></table></figure></h2><h1 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h1><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><pre><code>输入：s = &quot;barfoothefoobarman&quot;,words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;wordgoodgoodgoodbestword&quot;,words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]</code></pre><blockquote><p>思路:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> res</span><br><span class="line">        len_sub_string = len(words[<span class="number">0</span>])  <span class="comment"># word字符串的长度</span></span><br><span class="line">        <span class="comment"># 用一个hash表对应word和word的个数</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table[w] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[w] = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 遍历所有元素的指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s) - len_sub_string*len(words) + <span class="number">1</span>:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># copy一个hash表作为临时</span></span><br><span class="line">            _hash_table = copy.deepcopy(hash_table)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 在当前指针i处遍历,如果hash表为空,则添加i</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _hash_table:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                <span class="keyword">if</span> s[j:j+len_sub_string] <span class="keyword">in</span> _hash_table:</span><br><span class="line">                    <span class="keyword">if</span> _hash_table[s[j:j+len_sub_string]] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">del</span> _hash_table[s[j:j+len_sub_string]]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        _hash_table[s[j:j+len_sub_string]] -= <span class="number">1</span></span><br><span class="line">                    j = j + len_sub_string</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>TODO: 时间复杂度</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;21~30&lt;/code&gt;题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11-20题</title>
    <link href="http://monteyang.cn/LeetCode-11-20%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-11-20%E9%A2%98.html</id>
    <published>2019-12-17T13:59:50.000Z</published>
    <updated>2020-02-18T15:22:56.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>11~20</code> 题</p></blockquote><a id="more"></a><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img data-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><ul><li>示例:<br>  输入: [1,8,6,2,5,4,8,3,7]<br>  输出: 49</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 1. 暴力法</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    def maxArea(self, height):</span></span><br><span class="line"><span class="string">        max_area = 0</span></span><br><span class="line"><span class="string">        for i in range(len(height)):</span></span><br><span class="line"><span class="string">            for j in range(i+1, len(height)):</span></span><br><span class="line"><span class="string">                max_area = max(min(height[i], height[j]) * (j - i), max_area)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return max_area</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 2. 双指针法</span></span><br><span class="line">    <span class="comment"># - 一般来说,距离最远的围成较大面积的可能性较大</span></span><br><span class="line">    <span class="comment"># - 两头各放一个指针</span></span><br><span class="line">    <span class="comment"># - 较短一侧的指针往里移动, 才可能使面积变大(虽然两指针距离变短,但是较短一侧的高度可能变大)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        pt_left = <span class="number">0</span></span><br><span class="line">        pt_right = len(height) - <span class="number">1</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 新算的面积 = min(height[pt_left], height[pt_right])*(pt_right - pt_left)</span></span><br><span class="line">            <span class="comment"># 最大面积 = max(新算的面积, 原来的最大面积)</span></span><br><span class="line">            max_area = max(min(height[pt_left], height[pt_right])*(pt_right - pt_left), max_area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选取较小一侧的指针,往内移动一个单位</span></span><br><span class="line">            <span class="keyword">if</span> height[pt_left] &lt; height[pt_right]:</span><br><span class="line">                pt_left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指针汇合时, 循环结束</span></span><br><span class="line">            <span class="keyword">if</span> pt_left == pt_right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><hr><h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><ul><li><p>示例 1:<br>  输入: 3<br>  输出: “III”</p></li><li><p>示例 2:<br>  输入: 4<br>  输出: “IV”</p></li><li><p>示例 3:<br>  输入: 9<br>  输出: “IX”</p></li><li><p>示例 4:<br>  输入: 58<br>  输出: “LVIII”<br>  解释: L = 50, V = 5, III = 3.</p></li><li><p>示例 5:<br>  输入: 1994<br>  输出: “MCMXCIV”<br>  解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        lut = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'I'</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">            <span class="number">1000</span>: <span class="string">'M'</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 将输入num除以lut的从大到小的key,进行取模. 模变成被除数继续迭代.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(lut.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            n, mod = divmod(num, i) </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += lut[i] * n</span><br><span class="line">                num = mod</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><p>示例 2:</p><pre><code>输入: &quot;IV&quot;输出: 4</code></pre><p>示例 3:</p><pre><code>输入: &quot;IX&quot;输出: 9</code></pre><p>示例 4:</p><pre><code>输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p>示例 5:</p><pre><code>输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        lut = &#123;<span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">               <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">               <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">               <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">               <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">               <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">               <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">               <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">               <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">               <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">               <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先判断当前输入的前两个字符是否是罗马数字,</span></span><br><span class="line">        <span class="comment"># if 是: 加</span></span><br><span class="line">        <span class="comment"># else: 将单个字符转化成数字, 加</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i:i+<span class="number">2</span>] <span class="keyword">in</span> &#123;<span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>&#125;:</span><br><span class="line">                res += lut[s[i:i+<span class="number">2</span>]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += lut[s[i]]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: <code>&quot;fl&quot;</code><br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: <code>&quot;&quot;</code><br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""获得 list of string 的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            strs (list): a list of string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: 公共自创</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        commom = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            commom = self.getCommonPrefix(commom, strs[i])</span><br><span class="line">            <span class="keyword">if</span> commom == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commom</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCommonPrefix</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""返回str1和str2的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            str1 (string): 第一个字符串</span></span><br><span class="line"><span class="string">            str2 (string): 第二个字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 公共字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; min(len(str1), len(str2)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] == str2[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str1[:i]</span><br></pre></td></tr></table></figure></h2><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1],[-1, -1, 2]]</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">""" 返回一组数中之和为0的三个数(list of lists).</span></span><br><span class="line"><span class="string">        解法: 排序 + 使用双指针</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (list): a list of nums</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            list: 每个元素都是3个数且3个数之和为0</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 如果不够3个元素, 则返回空</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums = sorted(nums)  <span class="comment"># [-4, -1, -1, 0, 1, 2, ]</span></span><br><span class="line">        <span class="comment"># 确定第一个元素, 第一层遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果所有元素都大于等于0, 则返回</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># !!! 去重方法: 排好序后,相等则跳过...</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 确定双指针, 一个最左(i+1), 一个最右[-1]</span></span><br><span class="line">            pt_left = i + <span class="number">1</span></span><br><span class="line">            pt_right = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 三数之和等于0, 添加至res列表, 左右指针都到下一个位置</span></span><br><span class="line">            <span class="comment"># 如果 三数之和大于0, 右指针往左一个单位, 整体变小</span></span><br><span class="line">            <span class="comment"># 如果 三数之和小于0, 左指针往右一个单位, 整体变大</span></span><br><span class="line">            <span class="keyword">while</span> pt_left &lt; pt_right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[pt_left] + nums[pt_right] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[pt_left], nums[pt_right]])</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[pt_left] + nums[pt_right] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><pre><code>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums)</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line"></span><br><span class="line">        min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 重复的则跳过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L = i + <span class="number">1</span></span><br><span class="line">            R = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                _sum = nums[i] + nums[L] + nums[R]</span><br><span class="line">                delta = _sum - target</span><br><span class="line">                <span class="comment"># 如果两数之差小于最小值,保存该sum为res</span></span><br><span class="line">                <span class="keyword">if</span> abs(delta) &lt; min_dist:</span><br><span class="line">                    res = _sum</span><br><span class="line">                    min_dist = abs(delta)</span><br><span class="line">                <span class="comment"># 三数之和大于target,</span></span><br><span class="line">                <span class="keyword">if</span> delta &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] == nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 三数之和小于target</span></span><br><span class="line">                <span class="keyword">elif</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> _sum</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例:</p><pre><code>输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].说明:</code></pre><p>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="-4"><a href="#-4" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="comment"># digits = "324"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        hashmap = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                   <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                   <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                   <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                   <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                   <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                   <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                   <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        res = [<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(res, digit)</span>:</span></span><br><span class="line">            res_tmp = []</span><br><span class="line">            <span class="comment"># 两个for循环进行排列组合</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> hashmap[digit]:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">                    r += s</span><br><span class="line">                    res_tmp.append(r)</span><br><span class="line">            <span class="keyword">return</span> res_tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            res = util(res, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><pre><code>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[[-1,  0, 0, 1],[-2, -1, 1, 2],[-2,  0, 0, 2]]</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">""" 在list of nums中,获取能够使得和为target的四元组.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (List[int]): 一组数.</span></span><br><span class="line"><span class="string">            target (int): list of lists, int.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[List[int]]: 所有和为target的四元组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 特殊情况, nums中少于4个数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 1. 排序</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-3</span>):</span><br><span class="line">            <span class="comment"># 避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)<span class="number">-2</span>):</span><br><span class="line">                <span class="comment"># 避免重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 双指针: L-左指针, R-右指针</span></span><br><span class="line">                L = j + <span class="number">1</span></span><br><span class="line">                R = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="comment"># (左指针向右移,右指针向左移)当左指针超过右指针时,break.</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="comment"># 如果四数之和等于target,则添加</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和小于target,则左指针向右移动</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和大于target,则右指针向左移动</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="19-删除链表的倒数第n个节点"><a href="#19-删除链表的倒数第n个节点" class="headerlink" title="19. 删除链表的倒数第n个节点"></a>19. 删除链表的倒数第n个节点</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><blockquote><p>思路:<br>将所有结点放进一个数组中,直接将数组中倒数第n+1个结点的next指针指向倒数第n-1个结点.</p></blockquote><h2 id="-6"><a href="#-6" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="comment"># 链表长度</span></span><br><span class="line">        arr = []</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            arr.append(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr):</span><br><span class="line">            head = arr[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node_to_del = arr[-n]</span><br><span class="line">        arr[-n<span class="number">-1</span>].next = node_to_del.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></h2><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><pre><code>输入: &quot;()&quot;输出: true</code></pre><p>示例 2:</p><pre><code>输入: &quot;()[]{}&quot;输出: true</code></pre><p>示例 3:</p><pre><code>输入: &quot;(]&quot;输出: false</code></pre><p>示例 4:</p><pre><code>输入: &quot;([)]&quot;输出: false</code></pre><p>示例 5:</p><pre><code>输入: &quot;{[]}&quot;输出: true</code></pre><blockquote><p>思路:<br>栈</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        lut = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'['</span>: <span class="string">']'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果输入的是左侧符号,加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> lut:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果输入的是右侧符号:</span></span><br><span class="line">            <span class="comment"># 如果栈中非空, 判断该符号是否与栈中最后一个符号匹配</span></span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">and</span> c <span class="keyword">in</span> lut.values():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> c == lut[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;11~20&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1-10题</title>
    <link href="http://monteyang.cn/LeetCode-1-10%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-1-10%E9%A2%98.html</id>
    <published>2019-12-17T13:47:05.000Z</published>
    <updated>2020-02-18T15:22:56.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>1~10</code> 题</p></blockquote><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><ul><li><p>示例:</p><p>  给定 nums = [2, 7, 11, 15], target = 9</p><p>  因为 nums[0] + nums[1] = 2 + 7 = 9<br>  所以返回 [0, 1]</p></li></ul><a id="more"></a><blockquote><p>思路:<br>在哈希表中反向存储[元素数值-&gt;元素索引],遍历一次实现O(n).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># 哈希表,反过来存 num -&gt; idx, 有可能同一num对应多个idx, 所以 &#123;12: [idx1, idx2, ...]&#125;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[n] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[n].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num_1, idx_1 <span class="keyword">in</span> hashmap.items():</span><br><span class="line">            <span class="comment"># num_2 = target - num_1 , 在hashmap中</span></span><br><span class="line">            <span class="keyword">if</span> target - num_1 <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># num_1 与 num_2 数值相等时</span></span><br><span class="line">                <span class="keyword">if</span> (target - num_1 == num_1):</span><br><span class="line">                    <span class="comment"># [注意] 如果找到的 num_2 其实是 num_1 自己, 跳过...</span></span><br><span class="line">                    <span class="keyword">if</span> (len(hashmap[num_1]) == <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                    <span class="keyword">if</span> len(hashmap[target-num_1]) &gt;= <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> hashmap[target-num_1][<span class="number">0</span>], hashmap[target-num_1][<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> idx_1[<span class="number">0</span>], hashmap[target-num_1][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><ul><li>示例：<br>  输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>  输出：7 -&gt; 0 -&gt; 8<br>  原因：342 + 465 = 807</li></ul><blockquote><p>思路:<br>每一个位相加时,都要考虑进位.</p></blockquote><h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        HeadNode = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = HeadNode</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历2个链表的同时进行计算,存入result链表</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum_cur = x + y + carry</span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sum_cur &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                sum_cur %= <span class="number">10</span></span><br><span class="line">            cur.next = ListNode(sum_cur)</span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">and</span> l1.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">and</span> l2.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># l1,l2都遍历完, 但是最后有进位时</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            cur.next = ListNode(carry)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HeadNode.next</span><br></pre></td></tr></table></figure></h2><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>Given a string, find the length of the longest substring without repeating characters.</p><ul><li><p>Example 1:<br>  Input: “abcabcbb”<br>  Output: 3<br>  Explanation: The answer is “abc”, with the length of 3. </p></li><li><p>Example 2:<br>  Input: “bbbbb”<br>  Output: 1<br>  Explanation: The answer is “b”, with the length of 1.</p></li><li><p>Example 3:<br>  Input: “pwwkew”<br>  Output: 3<br>  Explanation: The answer is “wke”, with the length of 3. </p><pre><code>          Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre></li></ul><blockquote><p>思路:<br>滑动窗口法:判断新的元素是否存在于已有的窗口内部.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        window = []</span><br><span class="line">        cur_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> window:</span><br><span class="line">                window = window[window.index(s[i])+<span class="number">1</span>:]</span><br><span class="line">            window.append(s[i])</span><br><span class="line">            cur_length = len(window)</span><br><span class="line">            <span class="keyword">if</span> cur_length &gt; max_length:</span><br><span class="line">                max_length = cur_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure><hr><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><ul><li><p>Example 1:<br>  nums1 = [1, 3]<br>  nums2 = [2]<br>  The median is 2.0</p></li><li><p>Example 2:<br>  nums1 = [1, 2]<br>  nums2 = [3, 4]<br>  The median is (2 + 3)/2 = 2.5</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(m+n)</span></span><br><span class="line"><span class="comment"># TODO O(log(m+n))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        length = len(nums1) + len(nums2)</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1+nums2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        m_idx = int(length/<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m_idx):</span><br><span class="line">            <span class="keyword">if</span> p2 &gt; len(nums2)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> p1 &gt; len(nums1)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 = p2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            median = (nums[<span class="number">-1</span>] + nums[<span class="number">-2</span>])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = nums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median</span><br></pre></td></tr></table></figure><hr><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><ul><li><p>示例 1：<br>  输入: “babad”<br>  输出: “bab”<br>  注意: “aba” 也是一个有效答案。</p></li><li><p>示例 2：<br>  输入: “cbbd”<br>  输出: “bb”</p></li></ul><blockquote><p>思路:<br>在每个索引处,从中心展开,获取最长的回文串.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = <span class="string">" "</span>.join(s)</span><br><span class="line">        longest_pali = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cent_idx <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            pali = self.get_longest_pali(s, cent_idx)</span><br><span class="line">            <span class="keyword">if</span> len(pali) &gt; len(longest_pali):</span><br><span class="line">                longest_pali = pali</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_pali</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_longest_pali</span><span class="params">(self, s, cent_idx)</span>:</span></span><br><span class="line">        <span class="string">"""返回字符串s中以索引cent_idx为中心的最长回文子串"""</span></span><br><span class="line">        pali = s[cent_idx]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            left_idx = cent_idx - i</span><br><span class="line">            right_idx = cent_idx + i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 超出范围,跳出</span></span><br><span class="line">            <span class="keyword">if</span> left_idx &lt; <span class="number">0</span> <span class="keyword">or</span> right_idx &gt;= len(s):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[left_idx] == s[right_idx]:</span><br><span class="line">                pali = s[left_idx] + pali + s[right_idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pali = pali.replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pali</span><br></pre></td></tr></table></figure><hr><h1 id="6-z-字形变换"><a href="#6-z-字形变换" class="headerlink" title="6. z-字形变换"></a>6. z-字形变换</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><ul><li><p>示例 1:<br>  输入: s = “LEETCODEISHIRING”, numRows = 3<br>  输出: “LCIRETOESIIGEDHN”</p></li><li><p>示例 2:<br>  输入: s = “LEETCODEISHIRING”, numRows = 4<br>  输出: “LDREOEIIECIHNTSG”<br>  解释:</p><pre><code>  L     D     R  E   O E   I I  E C   I H   N  T     S     G</code></pre><blockquote><p>思路:<br>用一个 List[string], 第n个元素存储第n行的字符.</p></blockquote></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numRows &lt; <span class="number">2</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历字符串</span></span><br><span class="line">        <span class="comment"># res[0]: Z的第一行</span></span><br><span class="line">        <span class="comment"># res[1]: Z的第二行</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            res[i] += c</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: order_flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i == numRows - <span class="number">1</span>: order_flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> order_flag:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        res_str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">            res_str += r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_str</span><br></pre></td></tr></table></figure></h2><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><ul><li>示例 1:<br>  输入: 123<br>  输出: 321</li><li>示例 2:<br>  输入: -123<br>  输出: -321</li><li>示例 3:<br>  输入: 120<br>  输出: 21<br>  注意:</li></ul><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        x_orig = x</span><br><span class="line">        x = abs(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            temp = x % <span class="number">10</span></span><br><span class="line">            x = (x - temp)/<span class="number">10</span></span><br><span class="line">            res = res*<span class="number">10</span> + temp</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x_orig &lt; <span class="number">0</span>: res = -res</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> res &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><hr><h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><ul><li>示例 1:<br>  输入: “42”<br>  输出: 42</li><li>示例 2:<br>  输入: “   -42”<br>  输出: -42<br>  解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</li><li>示例 3:<br>  输入: “4193 with words”<br>  输出: 4193<br>  解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</li><li>示例 4:<br>  输入: “words and 987”<br>  输出: 0<br>  解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。</li><li>示例 5:<br>  输入: “-91283472332”<br>  输出: -2147483648<br>  解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        flag_find_first = <span class="literal">True</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            asc = ord(c)</span><br><span class="line">            <span class="comment"># 找第一个符号, </span></span><br><span class="line">            <span class="keyword">if</span> flag_find_first:</span><br><span class="line">                <span class="comment"># 空字符, 跳过</span></span><br><span class="line">                <span class="keyword">if</span> asc == <span class="number">32</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 负号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">45</span>:</span><br><span class="line">                    sign = <span class="number">-1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 正号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">43</span>:</span><br><span class="line">                    sign = <span class="number">1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 数字字符</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    res = asc<span class="number">-48</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 非上述字符</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 已有第一个符号(正号或符号或数字)的前提下, 接下来只能是数字符号, 如果不是则break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    res = int(res*<span class="number">10</span> + (asc<span class="number">-48</span>))</span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> res &gt; (<span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>):</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">-1</span> <span class="keyword">and</span> res &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * res</span><br></pre></td></tr></table></figure></h2><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>示例 1:<br>  输入: 121<br>  输出: true</li><li>示例 2:<br>  输入: -121<br>  输出: false<br>  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li><li>示例 3:<br>  输入: 10<br>  输出: false<br>  解释: 从右向左读, 为 01 。因此它不是一个回文数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = str(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[-i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符</li><li><p><code>*</code> 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖<strong>整个</strong>字符串<code>s</code>的，而不是部分字符串。</p></li><li><p>说明:<br><code>s</code> 可能为空，且只包含从 a-z 的小写字母。<br><code>p</code> 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></li></ul><ul><li><p>示例 1:<br>  输入: s = “aa”, p = “a”<br>  输出: false<br>  解释: “a” 无法匹配 “aa” 整个字符串。</p></li><li><p>示例 2:<br>  输入: s = “aa”, p = “a<em>“<br>  输出: true<br>  解释: 因为 `</em>` 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p></li><li><p>示例 3:<br>  输入: s = “ab”, p = “.<em>“<br>  输出: true<br>  解释: `.</em><code>表示可匹配零个或多个（</code>*<code>）任意字符（</code>.`）。</p></li><li><p>示例 4:<br>  输入: s = “aab”, p = “c*a*b”<br>  输出: true<br>  解释: 因为 <code>*</code> 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p></li><li><p>示例 5:<br>  输入: s = “mississippi”, p = “mis*is*p*.”<br>  输出: false</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># 递归基: 都为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字符相互匹配</span></span><br><span class="line">        first_match = bool(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 若之后存在*  212 1* </span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;1~10&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;  给定 nums = [2, 7, 11, 15], target = 9&lt;/p&gt;
&lt;p&gt;  因为 nums[0] + nums[1] = 2 + 7 = 9&lt;br&gt;  所以返回 [0, 1]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python-关于正则表达式的总结</title>
    <link href="http://monteyang.cn/Python-%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/Python-%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html</id>
    <published>2019-12-16T14:08:42.000Z</published>
    <updated>2020-03-14T09:28:47.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><p>正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），用于字符串的<strong>匹配</strong>和<strong>提取</strong>等操作。正则表达式在所有编程语言中都是通用的。</p><!-- - 最常用的正则表达式| 正则表达式 | 功能                      || ---------- | ------------------------- || `.`        | 匹配任意字符,除换行符`\n` || `*`        | 将上一个字符重复0次或多次 || `+`        | 将上一个字符重复1次或多次 || `?`        | 将上一个字符重复0次或1次  || `\s`       | 匹配空白字符              || `\d`       | 匹配任意数字              | --><hr><h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><p>匹配单个字符</p><ul><li><code>.</code>    ： 匹配任意1个字符（除了\n）</li><li><code>[ ]</code>    ： 匹配[ ]中任意一个字符</li><li><code>\d</code>    ： 匹配数字，即0-9</li><li><code>\D</code>    ： 匹配非数字</li><li><code>\s</code>    ： 匹配空白，即 空格、tab键</li><li><code>\S</code>    ： 匹配非空白</li><li><code>\w</code>    ： 匹配单词字符，即a-z、A-Z、0-9、_</li><li><code>\W</code>    ： 匹配非单词字符</li></ul><p>匹配多个字符</p><ul><li><code>*</code>       ： 匹配前一个字符出现0次或无限次，即可有可无</li><li><code>+</code>       ： 匹配前一个字符出现1次或无限次，即至少有1次</li><li><code>?</code>       ： 匹配前一个字符出现1次或0次，即要么有1次，要么没有</li><li><code>{m}</code>     ： 匹配前一个字符出现m次</li><li><code>{m,n}</code>    ： 匹配前一个字符出现从m到n次</li></ul><p>匹配字符串首尾：</p><p>在正则表达式的首部添加<code>^</code>，意味着待匹配的字符串从首部就要和正则式匹配。类似的，正则式尾部添加<code>$</code>，表示待匹配的字符串从尾部需和正则式匹配。</p><ul><li><code>^</code>：匹配字符串的起始</li><li><code>$</code>：匹配字符串的末尾</li></ul><blockquote><p>常用的正则表达式：<a href="https://c.runoob.com/front-end/854" target="_blank" rel="external nofollow noopener noreferrer">https://c.runoob.com/front-end/854</a></p></blockquote><hr><h1 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h1><p>利用分组, 可以提取字符串中想要的指定内容。用括号<code>()</code>括起来的正则表达式表示一个分组，通过<code>group()</code>函数可获取分组中的字符串。例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配电话号码, 匹配模式中有两个分组：(\d&#123;3&#125;)、(\d&#123;3,8&#125;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)  <span class="comment"># 用group函数可以提取匹配的部分</span></span><br><span class="line"><span class="string">'010-12345'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)  <span class="comment"># group(1)表示第一个分组</span></span><br><span class="line"><span class="string">'010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)  <span class="comment"># group(2)表示第一个分组</span></span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure><p>如果想判断字符串中<strong>是否具有规律相同的多个子串</strong>时, 可以采用分组：</p><p>例如，正则表达式 <code>&lt;(\w*)&gt;.*&lt;(/\1)&gt;</code> 可以匹配 <code>&lt;h1&gt;fadsfas&lt;/h1&gt;</code>，不能匹配 <code>&lt;h1&gt;fadsfas&lt;/h2&gt;</code>。</p><p>当分组个数过多时，可以给分组起别名，在同一个正则表达式中重复引用该分组。</p><ul><li>分组起别名：<code>(?P&lt;name&gt;___)</code> 其中<code>___</code>填写分组内的正则式</li><li>引用别名为name的分组：<code>(?P=name)</code></li></ul><hr><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>在Python中，re模块已为我们实现了正则表达式的相关操作:</p><ul><li><code>re.match()</code>： 从头开始匹配，可以利用分组获得我们想要的子串。用法见上文。</li><li><code>re.search()</code>： 无需从头开始匹配，只返回<strong>匹配的第一个子字符串</strong>。</li><li><code>re.findall()</code>： 找到字符串中<strong>所有匹配的字符串</strong>，与<code>search()</code>不同，<code>findall()</code>直接返回一个list。</li><li><code>re.sub()</code>： 利用正则表达式将匹配到的字符串<strong>批量替换</strong>。</li><li><code>re.split()</code>：利用正则表达式<strong>分割字符串</strong>，返回一个list。</li></ul><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.search()</span></span><br><span class="line">In [<span class="number">7</span>]: ret = re.search(<span class="string">r"hello"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">8</span>]: ret.group()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.findall()</span></span><br><span class="line">In [<span class="number">9</span>]: ret = re.findall(<span class="string">r"hello"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">10</span>]: print(ret)</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'hello'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.sub()</span></span><br><span class="line">In [<span class="number">15</span>]: ret = re.sub(<span class="string">r"hello"</span>,<span class="string">"bye"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">16</span>]: ret</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'bye world! bye world!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.split()</span></span><br><span class="line">In [<span class="number">12</span>]: ret = re.split(<span class="string">r":| "</span>,<span class="string">"hello:YMN 25 shenyang"</span>)  <span class="comment"># 按:或空格分割字符串</span></span><br><span class="line">In [<span class="number">13</span>]: ret</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="string">'hello'</span>, <span class="string">'YMN'</span>, <span class="string">'25'</span>, <span class="string">'shenyang'</span>]</span><br></pre></td></tr></table></figure></p><hr><h1 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是正则表达式？&quot;&gt;&lt;a href=&quot;#什么是正则表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式？&quot;&gt;&lt;/a&gt;什么是正则表达式？&lt;/h1&gt;&lt;p&gt;正则表达式（regular expression）描述了一种字符串匹配的模式（pat
      
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-多任务的实现</title>
    <link href="http://monteyang.cn/Python-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.html"/>
    <id>http://monteyang.cn/Python-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.html</id>
    <published>2019-12-16T14:00:42.000Z</published>
    <updated>2020-02-29T08:19:00.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Python 中多任务的实现方式：进程、线程、协程</p></blockquote><h1 id="多任务的实现方式"><a href="#多任务的实现方式" class="headerlink" title="多任务的实现方式"></a>多任务的实现方式</h1><ul><li>多进程</li><li>多线程</li><li>多进程+多线程</li><li>协程（Python中）</li></ul><hr><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a><code>Process</code></h2><p>Python中，使用<code>multiprocessing</code>模块实现多进程。<br>其中<code>Process</code>是一个进程类，可实例化一个进程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())  <span class="comment"># 打印当前进程 pid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个进程，注意传入的参数为一个元组，当只有一个参数时，写成(arg,)</span></span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()  <span class="comment"># join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</span></span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string">Parent process 928.</span></span><br><span class="line"><span class="string">Child process will start.</span></span><br><span class="line"><span class="string">Run child process test (929)...</span></span><br><span class="line"><span class="string">Process end.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>当启动大量子进程时，为了防止系统资源占用过高，需采用进程池的方式，循环利用进程实现多任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"></span><br><span class="line">    p = Pool(<span class="number">4</span>)  <span class="comment"># 创建进程池，参数为进程池中允许存在进程的最多个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))  <span class="comment"># 注意 apply_async：异步非阻塞</span></span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parent process 669.</span></span><br><span class="line"><span class="string">Waiting for all subprocesses done...</span></span><br><span class="line"><span class="string">Run task 0 (671)...</span></span><br><span class="line"><span class="string">Run task 1 (672)...</span></span><br><span class="line"><span class="string">Run task 2 (673)...</span></span><br><span class="line"><span class="string">Run task 3 (674)...</span></span><br><span class="line"><span class="string">Task 2 runs 0.14 seconds.</span></span><br><span class="line"><span class="string">Run task 4 (673)...</span></span><br><span class="line"><span class="string">Task 1 runs 0.27 seconds.</span></span><br><span class="line"><span class="string">Task 3 runs 0.86 seconds.</span></span><br><span class="line"><span class="string">Task 0 runs 1.41 seconds.</span></span><br><span class="line"><span class="string">Task 4 runs 1.91 seconds.</span></span><br><span class="line"><span class="string">All subprocesses done.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>join()方法会等待所有子进程执行完毕，再执行下面的代码。</p><p>调用join()之前必须先调用close()。</p><p>调用close()之后就不能继续在进程池中添加新的<code>Process</code>。</p><p>由于创建进程池对象时传进的参数为4，因此task 0，1，2，3立刻执行，task 4等待前面某个task完成后才执行，最多同时执行4个进程。</p><p>Pool的默认大小是CPU的核数。</p><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程是操作系统直接支持的执行单元。</p><p>Python中，由于存在GIL锁：Global Interpreter Lock，任何线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，因此<strong>多线程在Python中只能交替执行</strong>，并不能加快效率。</p><h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><p>Threading模块可实现Python中的多线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">thread MainThread is running...</span></span><br><span class="line"><span class="string">thread LoopThread is running...</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 1</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 2</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 4</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 5</span></span><br><span class="line"><span class="string">thread LoopThread ended.</span></span><br><span class="line"><span class="string">thread MainThread ended.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程。<br>名字仅仅用来显示，没有其他意义。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>多线程中，所有变量都由所有线程共享，因此多个线程同时对一个变量进行修改，容易造成混乱。</p><p>Python中threading模块的Lock类，可以给线程中的部分代码加锁，加锁部分运行时，其中的变量不会被其他线程更改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>利用了程序中的延时时间，实际上还是单线程，但是不断的切换所执行的代码块。`</p><p>Python中可以使用 <code>gevent</code> 模块实现协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打个补丁：将程序中的延时代码，换为gevent中的</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continue_work</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(continue_work, <span class="string">'work_1'</span>)  <span class="comment"># (函数名, 传入函数的参数)</span></span><br><span class="line">    gevent.spawn(continue_work, <span class="string">'work_2'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h1 id="进程、线程、协程对比"><a href="#进程、线程、协程对比" class="headerlink" title="进程、线程、协程对比"></a>进程、线程、协程对比</h1><ul><li>进程是资源分配的单位，线程是操作系统调度的单位</li><li>进程切换时，需要创建一份资源，效率较低</li><li>线程切换需要的资源少，但效率一般</li><li>协程切换任务效率高，利用了线程延时等待的时间（因此，<strong>在实际处理时率先考虑使用协程</strong>实现多任务）</li><li>多线程和多进程有可能是并行的，但协程一定是并发的</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>廖雪峰的官方网站：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064" target="_blank" rel="external nofollow noopener noreferrer">https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于 Python 中多任务的实现方式：进程、线程、协程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;多任务的实现方式&quot;&gt;&lt;a href=&quot;#多任务的实现方式&quot; class=&quot;headerlink&quot; title=&quot;多任务的实现方式&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-可迭代对象、迭代器、生成器</title>
    <link href="http://monteyang.cn/Python--%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8.html"/>
    <id>http://monteyang.cn/Python--%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8.html</id>
    <published>2019-12-16T13:43:51.000Z</published>
    <updated>2020-03-14T13:36:14.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可迭代-Iterable"><a href="#可迭代-Iterable" class="headerlink" title="可迭代(Iterable)"></a>可迭代(Iterable)</h1><p>我们知道，在Python中一切皆为对象。其中<strong>可以用<code>for</code>循环遍历的，即内部有<code>__iter__()</code>方法的对象，都是可迭代的对象</strong>。</p><p><strong><code>for</code>循环的本质</strong>： 使用for循环实际上干了两件事，首先调用<code>__iter__()</code>返回一个对象，该对象需要有<code>__next__()</code>方法，然后再循环调用该对象的<code>__next__()</code>方法不断获取下一个值。</p><p>常见的可迭代对象包括：</p><ul><li>集合数据类型：如 <code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等</li><li>迭代器 Iterator</li></ul><p>可以用<code>isinstance()</code>函数判断对象是否可迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><p><strong>可以被 <code>next()</code> 函数调用，并不断返回下一个值的对象</strong>都称为迭代器，也就意味着这种对象中需要有<code>__next__()</code>方法的实现。迭代器的特点是内存消耗少。其中：</p><ul><li>生成器 Generator 是一种迭代器。</li><li>list、dict、str虽然是可迭代对象，却不是迭代器，可以使用<code>iter()</code>函数，把list、dict、str等可迭代对象变成迭代器。</li></ul><p><strong>可迭代对象和迭代器的关系</strong>：<br>可迭代对象中包含<code>__iter__()</code>方法的实现，经过<code>iter()</code>函数调用后，返回一个迭代器，而迭代器中有<code>__next__()</code>方法的实现。</p><p>可以用<code>isinstance()</code>函数判断对象是否为迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h1><p>生成器属于迭代器的一种，因此也可以被<code>next()</code>函数调用。</p><p>生成器可以分为两种：</p><ol><li>形如<code>( i for i in range(10))</code> 的生成器</li><li>带<code>yield</code>关键字的生成器函数</li></ol><p>生成器函数的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; num:</span><br><span class="line">        ret = <span class="keyword">yield</span> a</span><br><span class="line">        current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj = fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;可迭代-Iterable&quot;&gt;&lt;a href=&quot;#可迭代-Iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代(Iterable)&quot;&gt;&lt;/a&gt;可迭代(Iterable)&lt;/h1&gt;&lt;p&gt;我们知道，在Python中一切皆为对象。其中&lt;stron
      
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-Matplotlib简单小结</title>
    <link href="http://monteyang.cn/Python-Matplotlib%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93.html"/>
    <id>http://monteyang.cn/Python-Matplotlib%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93.html</id>
    <published>2019-12-16T09:28:00.000Z</published>
    <updated>2020-03-01T18:14:14.800Z</updated>
    
    <content type="html"><![CDATA[<p>matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。</p><h2 id="1-绘制图片"><a href="#1-绘制图片" class="headerlink" title="1. 绘制图片"></a>1. 绘制图片</h2><h3 id="1-1-设置图片大小、分辨率"><a href="#1-1-设置图片大小、分辨率" class="headerlink" title="1.1 设置图片大小、分辨率"></a>1.1 设置图片大小、分辨率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用的导入方式</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置图片大小, dpi是图片分辨率默认是100</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">2</span>, <span class="number">26</span>, <span class="number">2</span>)</span><br><span class="line">y = np.random.randn(<span class="number">12</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xticks(x)</span><br><span class="line"><span class="comment"># 调整x轴上的刻度，当刻度太密集时使用列表的步长（列表间隔）来解决，matplotlib会自动帮我们对应</span></span><br><span class="line"><span class="comment"># plt.xticks(x[::2])</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="1-2-调整轴上的刻度"><a href="#1-2-调整轴上的刻度" class="headerlink" title="1.2 调整轴上的刻度"></a>1.2 调整轴上的刻度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_ticks = [<span class="string">"第&#123;&#125;个"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.xticks(x, x_ticks, rotation=<span class="number">90</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>plt.xticks() 中的两组数据长度务必相同</p><h3 id="1-3-设置中文显示"><a href="#1-3-设置中文显示" class="headerlink" title="1.3 设置中文显示"></a>1.3 设置中文显示</h3><p>matplotlib默认不支持中文，通过matplotlib.rc可以修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line">front = &#123;<span class="string">"family"</span>: <span class="string">"Microsoft Yahei"</span>,</span><br><span class="line"><span class="string">"size"</span>: <span class="string">"10"</span>&#125;</span><br><span class="line">matplotlib.rc(<span class="string">"front"</span>, **font)</span><br></pre></td></tr></table></figure></p><h3 id="1-4-添加描述信息"><a href="#1-4-添加描述信息" class="headerlink" title="1.4 添加描述信息"></a>1.4 添加描述信息</h3><p>可添加坐标轴含义，图像标题等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">"x轴含义"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y轴含义"</span>)</span><br><span class="line">plt.title(<span class="string">"标题"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="1-5-保存图片"><a href="#1-5-保存图片" class="headerlink" title="1.5 保存图片"></a>1.5 保存图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">"./fig.png"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-常用统计图"><a href="#2-常用统计图" class="headerlink" title="2. 常用统计图"></a>2. 常用统计图</h2><h3 id="2-1-折线图"><a href="#2-1-折线图" class="headerlink" title="2.1 折线图"></a>2.1 <strong>折线图</strong></h3><blockquote><p>以折线表示统计量的增减变化。<br>特点：反映事物的变化情况。<br><img data-src="https://img-blog.csdnimg.cn/2019010513092169.png" alt="折线图"></p></blockquote><h3 id="2-2-直方图"><a href="#2-2-直方图" class="headerlink" title="2.2 直方图"></a>2.2 <strong>直方图</strong></h3><blockquote><p>由一系列高度不等的纵向条纹或线段表示<strong>数据分布的情况</strong>。  一般用横轴表示数据范围，纵轴表示分布情况。<br>特点：绘制 <strong>连续</strong> 的数据，展示一组或者多组数据的分布状况。<br><img data-src="https://img-blog.csdnimg.cn/20190105131003368.png" alt="在这里插入图片描述"></p></blockquote><h3 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 <strong>条形图</strong></h3><blockquote><p>排列<strong>在工作表的列或行中的数据可以绘制到条形图中</strong>。<br>特点：绘制 <strong>离散</strong> 的数据，能够看出各个标签对应的数据大小，比较数据之间的差别。<br><img data-src="https://img-blog.csdnimg.cn/20190105131158885.png" alt="在这里插入图片描述"></p></blockquote><h3 id="2-4-散点图"><a href="#2-4-散点图" class="headerlink" title="2.4 散点图"></a>2.4 <strong>散点图</strong></h3><blockquote><p>用两组数据构成多个坐标点，考察坐标点的分布,判断两变量 之间是否存在某种关联或总结坐标点的分布模式。<br>特点：判断变量之间是否存在数量关联趋势，显示数据的分布规律。<br><img data-src="https://img-blog.csdnimg.cn/20190105131546443.png" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制折线图，x为横坐标，y为纵坐标。</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 绘制直方图，x为需要被分组的量，bins为组数。</span></span><br><span class="line">plt.hist(x, bins)</span><br><span class="line"><span class="comment"># 绘制条形图，x为序列，height为序列的“高度”。</span></span><br><span class="line">plt.bar(x, height)</span><br><span class="line"><span class="comment"># 绘制散点图，(x,y)为点的坐标。</span></span><br><span class="line">plt.scatter(x, y)</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。&lt;/p&gt;
&lt;h2 id=&quot;1-绘制图片&quot;&gt;&lt;a href=&quot;#1-绘制图片&quot; class=&quot;headerlink&quot; title=&quot;1. 绘制图片&quot;&gt;&lt;/a&gt;1. 绘制图片&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-7.策略梯度算法</title>
    <link href="http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-7.%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95.html"/>
    <id>http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-7.%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95.html</id>
    <published>2019-12-16T02:14:42.000Z</published>
    <updated>2020-03-11T13:29:04.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="强化学习方法的分类"><a href="#强化学习方法的分类" class="headerlink" title="强化学习方法的分类"></a>强化学习方法的分类</h2><p>强化学习方法可以分为：基于值函数的方法、基于策略的方法和Actor-Critic。</p><ul><li>基于值函数的方法： 用<strong>值函数</strong>进行策略评价+策略优化，用值函数导出策略</li><li>基于策略的方法： 直接学习<strong>策略</strong></li><li>Actor-Critic： 学习<strong>值函数 + 策略</strong></li></ul><p>之前的强化学习方法都是基于值函数的方法，在值函数近似中，我们使用带参数w的函数去近似值函数，如下：</p><p><img data-src="../images/RL-策略梯度-值函数近似.png" alt></p><p>在基于值函数的方法中，策略是从值函数中导出的</p><ul><li>使用贪婪的方法导出<strong>最优策略</strong>（最终收敛得到的策略）</li><li>使用 $\epsilon$-贪婪方法导出<strong>行为策略</strong>（智能体真正做的策略）</li></ul><p>而基于策略的方法，直接将策略进行参数化。</p><h2 id="基于值函数的方法的局限性"><a href="#基于值函数的方法的局限性" class="headerlink" title="基于值函数的方法的局限性"></a>基于值函数的方法的局限性</h2><ul><li>针对确定性策略</li><li>存在策略退化： 收敛后，若存在误差，则很容易因为微小的值函数差，发生策略退化现象</li><li>难以处理高维度的状态/动作空间<ul><li>不能处理连续的状态/动作空间</li></ul></li><li>收敛速度慢： 反复进行策略迭代（策略评价+策略提升），速度较慢</li></ul><h2 id="策略梯度算法的优缺点"><a href="#策略梯度算法的优缺点" class="headerlink" title="策略梯度算法的优缺点"></a>策略梯度算法的优缺点</h2><p>策略梯度算法，也就是基于策略的方法，具有的优缺点：</p><p><strong>优点：</strong></p><ul><li>更好的收敛性</li><li>能够有效地处理高维和连续的动作空间</li><li>能够学到随机策略</li><li>不会导致策略退化</li></ul><p><strong>缺点：</strong></p><ul><li>更容易收敛到局部最优值</li><li>难以评价一个策略，而且评价的<strong>方差较大</strong></li></ul><h2 id="策略模型的建模方式"><a href="#策略模型的建模方式" class="headerlink" title="策略模型的建模方式"></a>策略模型的建模方式</h2><p><img data-src="../images/RL-策略梯度算法-建模方式.png" alt></p><p>左侧2个是值函数方法，右侧2个是基于策略的方法。</p><h1 id="策略梯度算法"><a href="#策略梯度算法" class="headerlink" title="策略梯度算法"></a>策略梯度算法</h1><h2 id="策略梯度目标函数"><a href="#策略梯度目标函数" class="headerlink" title="策略梯度目标函数"></a>策略梯度目标函数</h2><p>在策略梯度算法中，我们用一个参数 θ 建模策略 $π_θ(s,a)$，如何寻找最优的参数 θ?</p><p>值函数近似时，优化的目标是使值函数的输出接近目标值。那么，如何不利用值函数，直接评价一个策略 $π_θ$ 的好坏？</p><h2 id="策略梯度的推导"><a href="#策略梯度的推导" class="headerlink" title="策略梯度的推导"></a>策略梯度的推导</h2><p>用 $τ$ 表示每次仿真的状态-行为序列 $S_0,A_0,… ,S_T,A_T$，每一个轨迹代表了强化学习的一个样本。轨迹的回报：</p><p><img data-src="../images/RL-策略梯度-轨迹回报值.png" alt></p><p>用 $P(τ; θ)$ 表示轨迹 $τ$ 出现的概率, 强化学习的<strong>目标函数</strong>可表示为</p><p><img data-src="../images/RL-策略梯度-目标函数.png" alt></p><blockquote><p>对所有条轨迹进行累加: 轨迹的回报值 * 该轨迹出现的概率</p></blockquote><p>强化学习的目标是最大化整个过程的奖励，也就是最大化$U(\theta)$</p><p><img data-src="../images/RL-策略梯度-目标.png" alt></p><p>在上式中，不同的策略只是影响了不同轨迹出现的概率。</p><p>如何求解 $∇_θU(θ)$?</p><ul><li>$P(τ; θ)$ 未知</li><li>无法用一个可微分的数学模型直接表达 $U(θ)$</li></ul><p>策略梯度解决的问题是，即使未知 $U(θ)$ 的具体形式，也能求其梯度。</p><p>从似然率的角度：</p><p><img data-src="../images/RL-策略梯度-似然率.png" alt></p><p>为什么要推导成这样的形式？</p><ul><li>$P(τ|θ)$ 可以通过 $π(a|s)$ 的模型表达 (后面会证明)</li><li>$R(τ)$ 可以通过采样的方式估计</li><li>期望符号 E 可以通过经验平均去估算</li></ul><p>利用当前策略 $π_θ$ <strong>采样 m 条轨迹，使用经验平均来估计梯度</strong>（MC形式）：</p><script type="math/tex; mode=display">\bigtriangledown_\theta U(\theta) \approx \frac{1}{m} \sum_{i=1}^{m} \bigtriangledown_\theta \log \mathbb{P}(\tau_i ; \theta) R(\tau_i)</script><p><img data-src="../images/RL-策略梯度-理解.png" alt></p><ul><li>$∇_θ \log \mathbb{P} (τ; θ)$ 是轨迹 $τ$ 的概率随参数 $θ$ 变化最陡的方向<ul><li>沿正方向，轨迹出现的概率会变大</li><li>沿负方向，轨迹出现的概率会变小</li></ul></li><li>$R(τ)$ 控制了参数更新的方向和步长，正负决定了方向，大小决定了增大 (减小) 的幅度</li></ul><p>在策略梯度算法中，</p><ul><li>增大了高回报轨迹出现的概率，回报值越大增加越多</li><li>减少了低回报轨迹出现的概率，回报值越小减少越多</li></ul><p>注意到似然率梯度只是改变轨迹出现的概率，而没有尝试去改变轨迹</p><p>轨迹 $\tau$ 出现的概率 $\mathbb{P} (τ; θ)$ 是未知的，根据马尔科夫链：</p><p><img data-src="../images/RL-策略梯度-马尔可夫链.png" alt></p><p>由于状态转移概率 $P(s_{t+1}^{(i)} |s_t^{(i)}, a_t^{(i)})$ 中不包含参数 θ，因此求导的过程可以消掉，所以：</p><p><img data-src="../images/RL-策略梯度-求导.png" alt></p><p>因此，综上可得，我们可以在仅有可微分的策略模型 πθ 的情况下，求得 $∇_θU(θ)$</p><script type="math/tex; mode=display">\hat{\eta} =∇_\theta U(\theta) \approx \frac{1}{m} \sum_{i=1}^{m} ∇_\theta \log \mathbb{P}(\tau_i ; \theta) R(\tau_i)</script><p>其中，</p><p><img data-src="../images/RL-策略梯度-求导2.png" alt></p><p>$\hat{\eta}$ 是 $∇_θU(θ)$ 的无偏估计</p><script type="math/tex; mode=display">E[\hat{\eta}]=∇_θU(\theta)</script><h2 id="弥补策略梯度的缺陷"><a href="#弥补策略梯度的缺陷" class="headerlink" title="弥补策略梯度的缺陷"></a>弥补策略梯度的缺陷</h2><ul><li>方差大</li><li>如果所有的 R(τ) 都是正的，那么所有轨迹出现的概率都会增加</li></ul><p>我们可以通过以下方法减小方差：</p><ul><li>引入基线 (baseline)</li><li>修改回报函数</li><li>Actor-Critic 方法</li><li>优势函数</li></ul><h3 id="引入基线"><a href="#引入基线" class="headerlink" title="引入基线"></a>引入基线</h3><p>引入基线 b ，不影响策略梯度</p><script type="math/tex; mode=display">∇_\theta U(\theta) \approx \frac{1}{m} \sum_{i=1}^{m} ∇_\theta \log \mathbb{P}(\tau_i ; \theta) R(\tau_i)=\frac{1}{m} \sum_{i=1}^{m} ∇_\theta \log \mathbb{P}(\tau_i ; \theta) (R(\tau_i)-b)</script><p><img data-src="../images/RL-策略梯度-基线.png" alt></p><p>由上式可知，这是因为对基线求期望值，结果会抵消为0。</p><p>选择基线的方法：</p><ol><li>选择回报值函数的期望值</li></ol><p><img data-src="../images/RL-策略梯度-基线1.png" alt></p><ol><li>最小方差</li></ol><p><img data-src="../images/RL-策略梯度-基线2.png" alt></p><h3 id="修改回报值函数"><a href="#修改回报值函数" class="headerlink" title="修改回报值函数"></a>修改回报值函数</h3><p>在当前的估计值值，对回报值 $R(\tau)$ 进行修改。</p><p><img data-src="../images/RL-策略梯度-修改回报值函数1.png" alt></p><p>由于将来的动作不依赖过去的奖励，因此我们可以修改回报值来降低方差。</p><p><img data-src="../images/RL-策略梯度-修改回报值函数2.png" alt></p><h1 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor-Critic"></a>Actor-Critic</h1><h2 id="MC-策略梯度-REINFORCE"><a href="#MC-策略梯度-REINFORCE" class="headerlink" title="MC 策略梯度 (REINFORCE)"></a>MC 策略梯度 (REINFORCE)</h2><ul><li>使用梯度上升算法更新参数 θ</li><li>使用<strong>采样回报值</strong> $g_t$ 估计真实回报值</li></ul><p><img data-src="../images/RL-策略梯度-REINFORCE.png" alt></p><blockquote><p>梯度上升：采用梯度上升是因为在策略梯度算法中，要最大化目标函数。<br><strong>采样回报值的方差很大</strong></p></blockquote><p><img data-src="../images/RL-策略梯度-REINFORCE2.png" alt></p><h2 id="使用-Critic-函数减小方差"><a href="#使用-Critic-函数减小方差" class="headerlink" title="使用 Critic 函数减小方差"></a>使用 Critic 函数减小方差</h2><p>REINFORCE中的采样回报值$g_t$ 方差很大，<br>我们可以使用critic函数来估计回报值减小方差</p><p><img data-src="../images/RL-策略梯度-Q函数.png" alt></p><blockquote><p>要注意的是：Actor-Critic 中的 Critic 只是为了减小策略梯度算法中估计<strong>回报值</strong>的方差。<strong>真正做决策的是 Actor</strong>（策略梯度算法）。</p></blockquote><p>Actor-Critic 算法维持两个参数：</p><ul><li>Critic 更新 Q 函数的参数 w</li><li>Actor 使用 Critic 的方向更新策略参数 θ</li></ul><p>将回报值替换为Q函数，近似策略梯度：</p><p><img data-src="../images/RL-策略梯度-回报值Q.png" alt></p><h2 id="使用优势函数减小误差"><a href="#使用优势函数减小误差" class="headerlink" title="使用优势函数减小误差"></a>使用优势函数减小误差</h2><p>优势函数：<br><img data-src="../images/RL-策略梯度-优势函数.png" alt></p><p>表示在当前状态下，每个动作相对于平均情况，能创造多少优势。</p><p>即通过 V 函数估计基线，用 Q 函数估计回报函数。</p><p><img data-src="../images/RL-策略梯度-优势函数2.png" alt></p><p>近似策略梯度</p><p><img data-src="../images/RL-策略梯度-优势函数3.png" alt></p><h2 id="使用-TD-误差替代优势函数"><a href="#使用-TD-误差替代优势函数" class="headerlink" title="使用 TD 误差替代优势函数"></a>使用 TD 误差替代优势函数</h2><p>对于真实的值函数 $V^{π_θ}(s)， TD 误差为</p><p><img data-src="../images/RL-策略梯度-TD误差.png" alt></p><p>TD 误差是优势函数的无偏估计</p><p><img data-src="../images/RL-策略梯度-TD误差2.png" alt></p><p>使用 TD 误差来计算策略梯度</p><p><img data-src="../images/RL-策略梯度-TD误差3.png" alt></p><h1 id="策略梯度多种形式的总结"><a href="#策略梯度多种形式的总结" class="headerlink" title="策略梯度多种形式的总结"></a>策略梯度多种形式的总结</h1><p><img data-src="../images/RL-策略梯度-多种形式总结.png" alt></p><blockquote><p>其中 Advantage Actor-Critic 为 A2C 算法。<br>又由于TD误差是 优势函数 A的无偏估计，所以 TD Actor-Critic 也是 A2C，实际中的 A2C 也是用 TD Actor-Critic。</p></blockquote><p>该式中有两部分：</p><ul><li>求梯度的部分（∇）：控制着策略更新的<strong>方向</strong></li><li>$g_t$ 及其变种：控制着策略更新的<strong>步长</strong>（重要）</li></ul><p>Critic 使用了策略评价 (MC 或 TD) 来估计 $Q_π(s, a); A_π(s, a)$ 或<br>$V_π(s)$</p><h1 id="A2C-算法"><a href="#A2C-算法" class="headerlink" title="A2C 算法"></a>A2C 算法</h1><p><img data-src="../images/RL-策略梯度-A2C.png" alt></p><ol><li>通过在当前状态s下，执行动作a，获得奖励r、并到达下一个状态s’，</li><li>此时计算 TD 误差，</li><li>再根据 TD 误差 更新 Critic 和 Actor。</li></ol><blockquote><p>A2C 中为了满足样本独立同分布，常常使用多进程的思路。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;h2 id=&quot;强化学习方法的分类&quot;&gt;&lt;a href=&quot;#强化学习方法的分类&quot; class=&quot;headerlink&quot; title=&quot;强化学习方法的
      
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-6.值函数近似</title>
    <link href="http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-6.%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC.html"/>
    <id>http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-6.%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC.html</id>
    <published>2019-12-16T02:13:42.000Z</published>
    <updated>2020-03-11T13:19:49.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="值函数近似的引出"><a href="#值函数近似的引出" class="headerlink" title="值函数近似的引出"></a>值函数近似的引出</h1><p>之前的方法都是基于值函数的方法，通过求解最优值函数，来求解出最优的策略。而且之前的方法都是<strong>基于表格</strong>的。</p><p><img data-src="../images/RL-值函数近似-表格法.png" alt></p><p>以上表格中，有3个动作和3种状态，表格大小为3×3。表格中某一项的更新不会影响其他项的更新。</p><p>然而，当状态和动作数量增多时，表格会迅速变大。</p><p>比如，我们常见的大规模状态的问题有：</p><ul><li>围棋：$10^{170}$种状态</li><li>机器人控制及无人机控制：连续状态</li><li>图像状态：$256^{像素点数}$种状态</li></ul><p>当表格遇到大规模状态的强化学习问题时，会导致：</p><ul><li>表格变得极大，需要很大的内存空间</li><li>每次只更新表格中的一个值，学习太缓慢</li></ul><p>因此，为解决大规模MDPs，引入函数近似的概念。我们可以利用含参数w（也就是神经网络中的参数w）的函数，来近似v函数和q函数：</p><p><img data-src="../images/RL-函数近似.png" alt></p><p>利用函数近似的方法：</p><ul><li>可以从已经经历过的状态推广到未见的状态</li><li>可以使用 MC 或者 TD 更新参数 w</li></ul><h1 id="值函数近似的类型"><a href="#值函数近似的类型" class="headerlink" title="值函数近似的类型"></a>值函数近似的类型</h1><p><img data-src="../images/RL-值函数近似的类型.png" alt></p><p>第三种只适用于离散的动作，输出的是动作的概率分布。</p><p>目标：寻找参数向量 $w$，以最小化近似值函数 $\hat{v}(s, w)$ 和真实的值<br>函数 $v_π(s)$ 之间的均方误差 (mean-squared error, MSE)</p><p><img data-src="../images/RL-值函数近似-MSE.png" alt></p><p>梯度下降算法会寻找局部最小值，w的变化量为：</p><p><img data-src="../images/RL-值函数近似-参数w.png" alt></p><p>随机梯度下降算法会对梯度进行采样</p><p><img data-src="../images/RL-值函数近似-随机梯度w.png" alt></p><h1 id="值函数近似下的增量式评价算法"><a href="#值函数近似下的增量式评价算法" class="headerlink" title="值函数近似下的增量式评价算法"></a>值函数近似下的增量式评价算法</h1><p>在 RL 环境中，并不知道真实的值函数 $v_π(s)$，只有奖励值。<br>可以用<strong>目标值</strong>代替真实的值函数。</p><p>关于目标值，有以下几种讨论：</p><h2 id="值函数近似下的-MC"><a href="#值函数近似下的-MC" class="headerlink" title="值函数近似下的 $MC$"></a>值函数近似下的 $MC$</h2><p>对于 $MC$，目标值是回报值 $G_t$，回报值 $G_t$ 是真实值函数 $v_π(S_t)$ 的无偏估计，构建训练数据：</p><script type="math/tex; mode=display">⟨S_1,G_1⟩,⟨S_2,G_2⟩,· · · ,⟨S_T,G_T⟩</script><p>参数w更新：</p><p><img data-src="../images/RL-值函数近似-MC.png" alt></p><h2 id="值函数近似下的-TD"><a href="#值函数近似下的-TD" class="headerlink" title="值函数近似下的 $TD$"></a>值函数近似下的 $TD$</h2><p>对于 $TD(0)$，目标值是 TD 目标值 $R_{t+1} + γv(S_{t+1}, w)$，TD目标值是真实值函数 $v_π(S_t)$ 的有偏估计，构建训练数据：</p><script type="math/tex; mode=display">⟨S_{1}, R_2 + γ\hat{v}(S_2, w)⟩, ⟨S_{2}, R_3 + γ\hat{v}(S_3, w)⟩, · · · , ⟨S_{T−1}, R_T⟩</script><p>参数w更新：</p><p><img data-src="../images/RL-值函数近似-TD0.png" alt></p><h2 id="值函数近似下的-TD-lambda"><a href="#值函数近似下的-TD-lambda" class="headerlink" title="值函数近似下的 $TD(\lambda)$"></a>值函数近似下的 $TD(\lambda)$</h2><p>对于 $TD(λ)$，目标值是 $λ$ 回报值 $G^λ_t$，$λ$ 回报值 $G^λ_t$ 也是真实值函数 $v_π(s)$ 的有偏估计</p><p><img data-src="../images/RL-值函数近似-TDlambda.png" alt></p><h1 id="值函数近似下的增量式优化算法"><a href="#值函数近似下的增量式优化算法" class="headerlink" title="值函数近似下的增量式优化算法"></a>值函数近似下的增量式优化算法</h1><p>优化算法中选用的是Q函数，和v函数类似。</p><ul><li>对于 MC，目标值即回报值 $G_t$</li></ul><p><img data-src="../images/RL-值函数近似-策略优化MC.png" alt></p><ul><li>对于 TD(0)，目标值是 TD 目标值 $R_{t+1} + γQ(S_{t+1}, A_{t+1})$</li></ul><p><img data-src="../images/RL-值函数近似-策略优化TD.png" alt></p><ul><li>对于TD(λ)，目标值是针对 Q 的 λ 回报值</li></ul><p><img data-src="../images/RL-值函数近似-策略优化TDlambda.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;值函数近似的引出&quot;&gt;&lt;a href=&quot;#值函数近似的引出&quot; class=&quot;headerlink&quot; title=&quot;值函数近似的引出&quot;&gt;&lt;/a&gt;值函数近似的引出&lt;/h1&gt;&lt;p&gt;之前的方法都是基于值函数的方法，通过求解最优值函数，来求解出最优的策略。而且之前的方法都是&lt;
      
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>强化学习-5.无模型方法2-时间差分</title>
    <link href="http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-5.%E6%97%A0%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%952-%E6%97%B6%E9%97%B4%E5%B7%AE%E5%88%86.html"/>
    <id>http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-5.%E6%97%A0%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%952-%E6%97%B6%E9%97%B4%E5%B7%AE%E5%88%86.html</id>
    <published>2019-12-16T02:12:42.000Z</published>
    <updated>2020-03-11T13:19:52.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间差分方法简介"><a href="#时间差分方法简介" class="headerlink" title="时间差分方法简介"></a>时间差分方法简介</h1><ul><li>是强化学习中最为核心的想法，混合了DP和MC<ul><li>和 MC 类似， TD 也从历史经验中学习</li><li>和 DP 类似，使用后继状态的值函数更新当前状态的值函数</li></ul></li></ul><ul><li>属于无模型方法<ul><li>未知 P，R，需要智能体与环境进行交互，样本备份，需要充分的探索…</li></ul></li></ul><ul><li>同时利用了采样和贝尔曼方程</li></ul><ul><li>可以从不完整的片段中学习（通过<strong>自举法</strong>）<ul><li>可同时应用于片段性任务和连续性任务</li></ul></li></ul><ul><li><strong>通过估计来更新估计</strong></li></ul><blockquote><p><strong>自举法</strong><br>(bootstrapping) 又名拔靴法、自助法。通过对样本进行<strong>重采样</strong>得到的估计总体的方法。<br>重采样：对样本里的数据再采样一次。<br>强化学习的 MC 中，一条轨迹是一个样本。TD 中，把一条轨迹采样成小片段，再对片段进行采样，所以属于自举法。</p></blockquote><h1 id="时间差分评价"><a href="#时间差分评价" class="headerlink" title="时间差分评价"></a>时间差分评价</h1><p><strong>目的</strong>：给定策略 $π$，求其对应的值函数 $v_π$</p><blockquote><p>对比之前的蒙特卡洛算法。</p><ul><li>增量蒙特卡洛算法<ul><li>用实际回报值$G_t$去更新值函数 $V(S_t)$<br><img data-src="../images/RL-TD-MC更新值函数.png" alt></li></ul></li></ul></blockquote><h2 id="时间差分评价算法"><a href="#时间差分评价算法" class="headerlink" title="时间差分评价算法"></a>时间差分评价算法</h2><p>时间差分算法 (Temporal-difference， TD)中，<strong>使用估计的回报值 $R_{t+1} + γV(S_{t+1})$ 去更新值函数 $V(S_t)$ (TD(0))</strong></p><p><img data-src="../images/RL-TD更新值函数.png" alt></p><p>其中：</p><ul><li>$R_{t+1} + \gamma V(S_{t+1})$ 称为 TD 目标</li><li>$\delta_t = R_{t+1} + \gamma V(S_{t+1}) − V(S_t)$ 称为 TD 误差</li><li>$\alpha$ 在0~1之间</li></ul><p>时间差分策略评价算法</p><p><img data-src="../images/RL-时间差分-算法.png" alt></p><h2 id="评价算法对比：-TD-和-DP"><a href="#评价算法对比：-TD-和-DP" class="headerlink" title="评价算法对比： TD 和 DP"></a>评价算法对比： TD 和 DP</h2><p>DP中， 利用了贝尔曼方程去解强化学习问题</p><p><img data-src="../images/RL-时间差分-DP.png" alt></p><p><img data-src="../images/RL-时间差分-DP图.png" alt></p><p>而 TD 中，也利用了贝尔曼方程，但做了以下改动：</p><ul><li><p>全宽备份 $\rightarrow$ 样本备份： 并去掉了期望符号<br><img data-src="../images/RL-时间差分-对比DP.png" alt></p></li><li><p>增加了学习率<br><img data-src="../images/RL-时间差分-对比DP2.png" alt></p></li></ul><p>采样多的时候，收敛后，时间差分评价算法满足贝尔曼方程</p><p><img data-src="../images/RL-时间差分-对比DP3.png" alt></p><p>整体看来，在时间差分评价算法中，是利用TD目标和当前值函数的差来指导学习，所以称作时间差分</p><p><img data-src="../images/RL-时间差分-TD图.png" alt></p><h2 id="评价算法对比：-TD-和-MC"><a href="#评价算法对比：-TD-和-MC" class="headerlink" title="评价算法对比： TD 和 MC"></a>评价算法对比： TD 和 MC</h2><p>在 MC 中，考虑的是整条轨迹。</p><p><img data-src="../images/RL-时间差分-MC图.png" alt></p><ul><li>TD 在每一步之后都能在线学习； MC 必须等待回报值得到之后才能学习</li><li>TD 利用了马尔科夫性； MC 没有利用马尔科夫性</li><li>MC 有高方差，零偏差； TD 有低方差，和一些偏差</li></ul><p><img data-src="../images/RL-时间差分-备份图.png" alt></p><h2 id="ML-和-RL-中的偏差-方差权衡"><a href="#ML-和-RL-中的偏差-方差权衡" class="headerlink" title="ML 和 RL 中的偏差/方差权衡"></a>ML 和 RL 中的偏差/方差权衡</h2><h3 id="ML-中的偏差和方差的trade-off"><a href="#ML-中的偏差和方差的trade-off" class="headerlink" title="ML 中的偏差和方差的trade-off"></a>ML 中的偏差和方差的trade-off</h3><p>在监督学习中，偏差/方差有另外的理解——<strong>欠拟合</strong>和<strong>过拟合</strong></p><ul><li>偏差大 (欠拟合): 预测值和样本之间的差</li><li>方差大 (过拟合): 样本值之间的方差, 学出的模型泛化能力差</li></ul><p>方差大意味着样本的置信度较差</p><p>机器学习方法都会在偏差和方差之间做 trade-off</p><p><img data-src="../images/RL-时间差分-偏差和方差.png" alt></p><h3 id="RL-中的偏差和方差的trade-off"><a href="#RL-中的偏差和方差的trade-off" class="headerlink" title="RL 中的偏差和方差的trade-off"></a>RL 中的偏差和方差的trade-off</h3><ul><li>回报值 $G_t = R_{t+1} + \gamma R_{t+2} + … + {\gamma}^{T-t-1}R_T$ 是值函数 $v_\pi(S_t)$ 的无偏估计</li><li>真实的 TD 目标值 $R_{t+1} + γv_π(S_{t+1})$ 是值函数 $v_π(S_t)$ 的无偏估计</li><li>使用的 TD 目标值 $R_{t+1} + γV_π(S_{t+1})$ 是值函数 $v_π(S_t)$ 的有偏估计</li><li>TD 目标值的方差要远小于回报值<ul><li>回报值依赖于很多随机变量 $A_{t},S_{t+1},R_{t+1},A_{t+1},S_{t+2},R_{t+2},· · ·$</li><li>TD 目标值仅仅依赖于一个随机序列 $A_t,S_{t+1},R_{t+1}$</li></ul></li></ul><h1 id="时间差分优化"><a href="#时间差分优化" class="headerlink" title="时间差分优化"></a>时间差分优化</h1><ul><li>广义策略迭代<ul><li>策略评价: TD 策略评价， $Q = q_π$</li><li>策略提升: $\epsilon$-贪婪策略提升</li></ul></li><li>TD 优化相比 MC 优化有几点好处<ul><li>低方差</li><li>在线更新 (online)</li><li>不完整序列</li></ul></li></ul><h2 id="在策略-TD-优化——Sarsa"><a href="#在策略-TD-优化——Sarsa" class="headerlink" title="在策略 TD 优化——Sarsa"></a>在策略 TD 优化——Sarsa</h2><p><img data-src="../images/RL-时间差分-SARSA.png" alt></p><p><img data-src="../images/RL-时间差分-sarsa公式.png" alt></p><p>值迭代</p><p>为什么是<strong>在策略</strong>？</p><p>执行的动作 A 是来自当前 Q 值下的 $\epsilon$-贪婪策略，构建 TD 目标值是的动作 A′ 是来自当前 Q 值下的 $\epsilon$-贪婪策略，这两者是同一个策略。</p><h2 id="离策略-TD-优化——Q学习"><a href="#离策略-TD-优化——Q学习" class="headerlink" title="离策略 TD 优化——Q学习"></a>离策略 TD 优化——Q学习</h2><p><img data-src="../images/RL-时间差分-Q学习.png" alt></p><p><img data-src="../images/RL-时间差分-Q学习流程.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间差分方法简介&quot;&gt;&lt;a href=&quot;#时间差分方法简介&quot; class=&quot;headerlink&quot; title=&quot;时间差分方法简介&quot;&gt;&lt;/a&gt;时间差分方法简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;是强化学习中最为核心的想法，混合了DP和MC&lt;ul&gt;
&lt;li&gt;和 MC 类似， 
      
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
