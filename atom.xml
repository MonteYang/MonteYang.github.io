<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MonteYang&#39;s Blog</title>
  
  <subtitle>朝着咸鱼的反方向努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monteyang.cn/"/>
  <updated>2020-02-13T04:42:02.576Z</updated>
  <id>http://monteyang.cn/</id>
  
  <author>
    <name>Monte Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-正则表达式</title>
    <link href="http://monteyang.cn/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>http://monteyang.cn/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</id>
    <published>2020-02-12T07:51:08.000Z</published>
    <updated>2020-02-13T04:42:02.576Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），用于字符串的匹配和提取等操作。</p><p>正则表达式的匹配模式在任意编程语言中都是通用的。</p><blockquote><p>常用的正则表达式：<a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">https://c.runoob.com/front-end/854</a></p></blockquote><a id="more"></a><ul><li>最常用的正则表达式</li></ul><div class="table-container"><table><thead><tr><th>正则表达式</th><th>功能</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意字符,除换行符<code>\n</code></td></tr><tr><td><code>*</code></td><td>将上一个字符重复0次或多次</td></tr><tr><td><code>+</code></td><td>将上一个字符重复1次或多次</td></tr><tr><td><code>?</code></td><td>将上一个字符重复0次或1次</td></tr><tr><td><code>\s</code></td><td>匹配空白字符</td></tr><tr><td><code>\d</code></td><td>匹配任意数字</td></tr></tbody></table></div><hr><h1 id="匹配字符串首尾"><a href="#匹配字符串首尾" class="headerlink" title="匹配字符串首尾"></a>匹配字符串首尾</h1><p>在正则表达式的首部添加<code>^</code>，意味着待匹配的字符串从首部就要和正则式匹配。类似的，正则式尾部添加<code>$</code>，表示待匹配的字符串从尾部需和正则式匹配。</p><ul><li><code>^</code>：匹配字符串的起始</li><li><code>$</code>：匹配字符串的末尾</li></ul><hr><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>利用分组, 可以提取字符串中你想要的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)  <span class="comment"># 匹配电话号码, 用括号`()`括起来的正则表达式表示一个分组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)  <span class="comment"># 用group函数可以提取匹配的部分</span></span><br><span class="line"><span class="string">'010-12345'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)  <span class="comment"># group(1)表示第一个分组</span></span><br><span class="line"><span class="string">'010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)  <span class="comment"># group(2)表示第一个分组</span></span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure><ul><li>用括号<code>()</code>括起来的正则表达式表示一个分组</li></ul><p>想判断字符串中具有一致规律的多个子串时, 可以采用分组：</p><ul><li>例如，正则表达式 <code>&lt;(\w*)&gt;.*&lt;(/\1)&gt;</code> 可以匹配 <code>&lt;h1&gt;fadsfas&lt;\h1&gt;</code>，不能匹配 <code>&lt;h1&gt;fadsfas&lt;\h2&gt;</code>。</li></ul><p>当分组个数过多时，可以给分组起别名，在同一个正则表达式中重复引用该分组。</p><ul><li>分组起别名：<code>(?P&lt;name&gt;___)</code> 其中<code>___</code>填写分组内的正则式</li><li>引用别名为name的分组：<code>(?P=name)</code></li></ul><hr><h1 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h1><ul><li><code>re.match()</code>： 从头开始匹配，可以利用分组获得我们想要的子串。用法见上文。</li><li><code>re.search()</code>： 无需从头开始匹配，只返回匹配的第一个子串。</li><li><code>re.findall()</code>： 找到字符串中所有匹配的元素，直接返回一个包含这些元素的list。</li><li><code>re.sub()</code>： 批量替换。</li><li><code>re.split()</code>：分割字符串。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），用于字符串的匹配和提取等操作。&lt;/p&gt;
&lt;p&gt;正则表达式的匹配模式在任意编程语言中都是通用的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常用的正则表达式：&lt;a href=&quot;https://c.runoob.com/front-end/854&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://c.runoob.com/front-end/854&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-多任务的实现：进程、线程、协程</title>
    <link href="http://monteyang.cn/Python-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.html"/>
    <id>http://monteyang.cn/Python-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.html</id>
    <published>2020-02-12T04:48:21.000Z</published>
    <updated>2020-02-16T15:58:01.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多任务的实现方式"><a href="#多任务的实现方式" class="headerlink" title="多任务的实现方式"></a>多任务的实现方式</h1><ul><li>多进程</li><li>多线程</li><li>多进程+多线程</li><li>协程（Python中）</li></ul><a id="more"></a><hr><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a><code>Process</code></h2><p>Python中，使用<code>multiprocessing</code>模块实现多进程。<br>其中<code>Process</code>是一个进程类，可实例化一个进程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())  <span class="comment"># 打印当前进程 pid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个进程，注意传入的参数为一个元组，当只有一个参数时，写成(arg,)</span></span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()  <span class="comment"># join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</span></span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string">Parent process 928.</span></span><br><span class="line"><span class="string">Child process will start.</span></span><br><span class="line"><span class="string">Run child process test (929)...</span></span><br><span class="line"><span class="string">Process end.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>当启动大量子进程时，为了防止系统资源占用过高，需采用进程池的方式，循环利用进程实现多任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"></span><br><span class="line">    p = Pool(<span class="number">4</span>)  <span class="comment"># 创建进程池，参数为进程池中允许存在进程的最多个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))  <span class="comment"># 注意 apply_async：异步非阻塞</span></span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parent process 669.</span></span><br><span class="line"><span class="string">Waiting for all subprocesses done...</span></span><br><span class="line"><span class="string">Run task 0 (671)...</span></span><br><span class="line"><span class="string">Run task 1 (672)...</span></span><br><span class="line"><span class="string">Run task 2 (673)...</span></span><br><span class="line"><span class="string">Run task 3 (674)...</span></span><br><span class="line"><span class="string">Task 2 runs 0.14 seconds.</span></span><br><span class="line"><span class="string">Run task 4 (673)...</span></span><br><span class="line"><span class="string">Task 1 runs 0.27 seconds.</span></span><br><span class="line"><span class="string">Task 3 runs 0.86 seconds.</span></span><br><span class="line"><span class="string">Task 0 runs 1.41 seconds.</span></span><br><span class="line"><span class="string">Task 4 runs 1.91 seconds.</span></span><br><span class="line"><span class="string">All subprocesses done.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>join()方法会等待所有子进程执行完毕，再执行下面的代码。</p><p>调用join()之前必须先调用close()。</p><p>调用close()之后就不能继续在进程池中添加新的<code>Process</code>。</p><p>由于创建进程池对象时传进的参数为4，因此task 0，1，2，3立刻执行，task 4等待前面某个task完成后才执行，最多同时执行4个进程。</p><p>Pool的默认大小是CPU的核数。</p><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程是操作系统直接支持的执行单元。</p><p>Python中，由于存在GIL锁：Global Interpreter Lock，任何线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，因此<strong>多线程在Python中只能交替执行</strong>，并不能加快效率。</p><h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><p>Threading模块可实现Python中的多线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">thread MainThread is running...</span></span><br><span class="line"><span class="string">thread LoopThread is running...</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 1</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 2</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 4</span></span><br><span class="line"><span class="string">thread LoopThread &gt;&gt;&gt; 5</span></span><br><span class="line"><span class="string">thread LoopThread ended.</span></span><br><span class="line"><span class="string">thread MainThread ended.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程。<br>名字仅仅用来显示，没有其他意义。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>多线程中，所有变量都由所有线程共享，因此多个线程同时对一个变量进行修改，容易造成混乱。</p><p>Python中threading模块的Lock类，可以给线程中的部分代码加锁，加锁部分运行时，其中的变量不会被其他线程更改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>利用了程序中的延时时间，实际上还是单线程，但是不断的切换所执行的代码块。`</p><p>Python中可以使用 <code>gevent</code> 模块实现协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打个补丁：将程序中的延时代码，换为gevent中的</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continue_work</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(continue_work, <span class="string">'work_1'</span>)  <span class="comment"># (函数名, 传入函数的参数)</span></span><br><span class="line">    gevent.spawn(continue_work, <span class="string">'work_2'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h1 id="进程、线程、协程对比"><a href="#进程、线程、协程对比" class="headerlink" title="进程、线程、协程对比"></a>进程、线程、协程对比</h1><ul><li>进程是资源分配的单位，线程是操作系统调度的单位</li><li>进程切换时，需要创建一份资源，效率较低</li><li>线程切换需要的资源少，但效率一般</li><li>协程切换任务效率高，利用了线程延时等待的时间（因此，<strong>在实际处理时率先考虑使用协程</strong>实现多任务）</li><li>多线程和多进程有可能是并行的，但协程一定是并发的</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>廖雪峰的官方网站：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多任务的实现方式&quot;&gt;&lt;a href=&quot;#多任务的实现方式&quot; class=&quot;headerlink&quot; title=&quot;多任务的实现方式&quot;&gt;&lt;/a&gt;多任务的实现方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;多进程&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;多进程+多线程&lt;/li&gt;
&lt;li&gt;协程（Python中）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Bag of Tricks for Image Classification with Convolutional Neural Networks</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Bag%20of%20Tricks%20for%20Image%20Classification%20with%20Convolutional%20Neural%20Networks.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Bag%20of%20Tricks%20for%20Image%20Classification%20with%20Convolutional%20Neural%20Networks.html</id>
    <published>2020-02-11T07:45:42.000Z</published>
    <updated>2020-02-12T08:59:25.720Z</updated>
    
    <content type="html"><![CDATA[<p>《<a href="https://arxiv.org/abs/1812.01187" target="_blank" rel="noopener">Bag of Tricks for Image Classification with Convolutional Neural Networks</a>》论文阅读</p><a id="more"></a><blockquote><p><strong>文章目录</strong>:</p><ul><li><a href="#abstract">Abstract</a></li><li><a href="#1-introduction">1. Introduction</a><ul><li><a href="#%e6%96%87%e7%ab%a0%e7%bb%93%e6%9e%84">文章结构</a></li></ul></li><li><a href="#2-training-procedures-%e5%9f%ba%e5%87%86%e7%9a%84%e8%ae%ad%e7%bb%83%e8%bf%87%e7%a8%8b">2. Training Procedures (基准的训练过程)</a><ul><li><a href="#21-baseline-training-procedure">2.1 Baseline Training Procedure</a></li><li><a href="#22-experiment-results">2.2  Experiment Results</a></li></ul></li><li><a href="#3-efficient-training-%e8%ae%ad%e7%bb%83%e6%95%88%e7%8e%87">3. Efficient Training (训练效率)</a><ul><li><a href="#31-large-batch-training-%e9%92%88%e5%af%b9batch%e5%92%8clearning-rate">3.1 Large-batch training (针对Batch和learning rate)</a><ul><li><a href="#1-linear-scaling-learning-rate-lr%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%9a%8fbatch-size-%e7%ba%bf%e6%80%a7%e5%a2%9e%e5%8a%a0">1.  Linear scaling learning rate (lr的初始化随batch size 线性增加)</a></li><li><a href="#2-learning-rate-warmup-%e8%ae%ad%e7%bb%83%e6%9c%9f%e9%97%b4lr%e9%80%90%e6%b8%90%e5%a2%9e%e5%8a%a0%e5%88%b0%e5%88%9d%e5%a7%8b%e5%80%bc">2. Learning rate warmup (训练期间,lr逐渐增加到初始值)</a></li><li><a href="#3-zero-mathsemanticsmrowmi%ce%b3mimrowannotation-encoding%22applicationx-tex%22gammaannotationsemanticsmath%ce%b3-%e9%92%88%e5%af%b9residual-block%e4%b8%ad%e7%9a%84bn%e5%b1%82%e5%88%9d%e5%a7%8b%e5%8c%96">3. Zero $\gamma$ (针对residual block中的BN层初始化)</a></li><li><a href="#4-no-bias-decay">4. No bias decay</a></li></ul></li><li><a href="#32-low-precision-training-gpu%e4%bd%8e%e7%b2%be%e5%ba%a6">3.2. Low-precision training (GPU低精度)</a></li></ul></li><li><a href="#4-model-tweaks-%e6%a8%a1%e5%9e%8b%e8%b0%83%e6%95%b4">4. Model Tweaks (模型调整)</a><ul><li><a href="#41-%e4%bb%8b%e7%bb%8dresnet%e7%bd%91%e7%bb%9c%e7%bb%93%e6%9e%84">4.1 介绍ResNet网络结构</a></li><li><a href="#42-resnet%e7%9a%84%e8%b0%83%e6%95%b4">4.2 ResNet的调整</a></li></ul></li><li><a href="#5-%e8%ae%ad%e7%bb%83%e6%94%b9%e8%bf%9b">5. 训练改进</a><ul><li><a href="#51-cos%e5%ad%a6%e4%b9%a0%e7%8e%87%e8%a1%b0%e5%87%8f-cosine-learning-rate-decay">5.1. cos学习率衰减  (Cosine Learning Rate Decay)</a></li><li><a href="#52-%e6%a0%87%e7%ad%be%e5%b9%b3%e6%bb%91-label-smoothing">5.2. 标签平滑 (Label Smoothing)</a></li><li><a href="#53-%e7%9f%a5%e8%af%86%e8%92%b8%e9%a6%8f-knowledge-distillation">5.3 知识蒸馏 (Knowledge Distillation)</a></li><li><a href="#54-%e6%b7%b7%e5%90%88%e8%ae%ad%e7%bb%83-mixup-training">5.4 混合训练 (Mixup Training)</a></li></ul></li><li><a href="#6-%e8%bf%81%e7%a7%bb%e5%ad%a6%e4%b9%a0">6. 迁移学习</a><ul><li><a href="#%e8%af%ad%e4%b9%89%e5%88%86%e5%89%b2">语义分割</a></li></ul></li></ul></blockquote><hr><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>本文整理了CNN的一些tricks.</p><hr><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><ul><li><p>网络结构发展: AlexNet, VGG, NiN, Inception, ResNet, DenseNet, NASNet.</p></li><li><p>提升训练效果的技巧:</p><ul><li><strong>损失函数</strong></li><li><strong>数据预处理</strong></li><li><strong>优化方法</strong></li></ul></li><li><p>次要的 tricks:</p><ul><li><strong>修改卷积层的 stride</strong></li><li><strong>调整 learning rate</strong></li></ul></li></ul><ul><li>这些 tricks 不仅可以用在分类任务,也可以应用于目标检测和语义分割任务中.</li></ul><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><ul><li>Section 2: 设置一个训练的 baseline</li><li>Section 3: 讨论几种 tricks</li><li>Section 4: review 三种 ResNet 网络结构,提出一种新的网络结构</li><li>Section 5: 额外的训练改进</li><li>Section 6: 迁移学习</li></ul><hr><h1 id="2-Training-Procedures-基准的训练过程"><a href="#2-Training-Procedures-基准的训练过程" class="headerlink" title="2. Training Procedures (基准的训练过程)"></a>2. Training Procedures (基准的训练过程)</h1><h2 id="2-1-Baseline-Training-Procedure"><a href="#2-1-Baseline-Training-Procedure" class="headerlink" title="2.1 Baseline Training Procedure"></a>2.1 Baseline Training Procedure</h2><ol><li>Randomly sample an image and decode it into 32-bit floating point raw pixel values in [0; 255].</li><li>Randomly crop a rectangular region whose aspect ratio is randomly sampled in [3/4, 4/3] and area randomly sampled in [8%; 100%], then resize the cropped region into a <strong>224-by-224</strong> <strong>square image</strong>.</li><li><strong>Flip</strong> horizontally with 0.5 probability.</li><li><strong>Scale hue</strong>, <strong>saturation</strong>, and <strong>brightness</strong> with coefficients uniformly drawn from [0.6, 1.4].</li><li>Add PCA noise with a coefficient sampled from a normal distribution N(0, 0.1)</li><li>Normalize RGB channels by subtracting 123.68, 116.779, 103.939 and dividing by 58.393, 57.12, 57.375, respectively.</li></ol><ul><li><p>未做额外的随机数据增强处理</p></li><li><p>初始化</p><ul><li>网络权重W初始化: <strong>Xavier</strong> algorithm<ul><li>In particular, we set the parameter to random values uniformly drawn from [−a; a], where a = p6=(din + dout). Here din and dout are the input and output channel sizes, respectively.</li></ul></li><li>Bias 初始化: All <strong>biases are initialized to 0.</strong></li><li>BN 层初始化: For <strong>batch normalization</strong> layers, <strong>γ vectors are initialized to 1 and β vectors to 0</strong>.</li></ul></li><li><p>优化</p><ul><li><strong>Nesterov Accelerated Gradient (NAG) descent</strong></li><li>Each model is trained for 120 epochs on 8 Nvidia V100 GPUs with a total <strong>batch size of 256</strong>.</li><li>The <strong>learning rate</strong> is initialized to <strong>0.1</strong> and <strong>divided by 10 at the 30th, 60th, and 90th epochs.</strong></li></ul></li></ul><h2 id="2-2-Experiment-Results"><a href="#2-2-Experiment-Results" class="headerlink" title="2.2  Experiment Results"></a>2.2  Experiment Results</h2><ul><li>论文的 baseline 与 reference 之间的对比</li></ul><hr><h1 id="3-Efficient-Training-训练效率"><a href="#3-Efficient-Training-训练效率" class="headerlink" title="3. Efficient Training (训练效率)"></a>3. Efficient Training (训练效率)</h1><h2 id="3-1-Large-batch-training-针对Batch和learning-rate"><a href="#3-1-Large-batch-training-针对Batch和learning-rate" class="headerlink" title="3.1 Large-batch training (针对Batch和learning rate)"></a>3.1 Large-batch training (针对Batch和learning rate)</h2><ul><li>增大 batch size, 导致<ul><li>使训练过程变慢</li><li>对于非凸问题, 收敛速率降低</li><li>换言之, 对于相同的epoch, 选择大的batch size所得到验证集准确率低于小的batch size所得到的验证集准确率</li></ul></li></ul><h3 id="1-Linear-scaling-learning-rate-lr的初始化随batch-size-线性增加"><a href="#1-Linear-scaling-learning-rate-lr的初始化随batch-size-线性增加" class="headerlink" title="1.  Linear scaling learning rate (lr的初始化随batch size 线性增加)"></a>1.  Linear scaling learning rate (lr的初始化随batch size 线性增加)</h3><blockquote><p>当 batch size 增加时, 使 learning rate 的初始值相应增加</p></blockquote><ul><li><p>a large batch size reduces the noise in the gradient, so we may increase the learning rate to make a larger progress along the opposite of the gradient direction.<br>(<strong>大的 batch size 降低了梯度的噪声, 所以我们需要增大 learning rate, 以更大的步长朝着梯度的反方向前进</strong>).</p></li><li><p>例子</p><ul><li>if we follow He et al. [9] to choose 0.1 as the initial learning rate for <strong>batch size 256</strong>, then when <strong>changing to a larger batch</strong> <strong>size b</strong>, we will <strong>increase the initial learning rate</strong> to <strong>0.1 × b/256</strong>.</li></ul></li></ul><h3 id="2-Learning-rate-warmup-训练期间-lr逐渐增加到初始值"><a href="#2-Learning-rate-warmup-训练期间-lr逐渐增加到初始值" class="headerlink" title="2. Learning rate warmup (训练期间,lr逐渐增加到初始值)"></a>2. Learning rate warmup (训练期间,lr逐渐增加到初始值)</h3><blockquote><p>lr 由 0 初始化, 线性增长到 initial value.</p></blockquote><p>在训练初期,所有参数都是随机初始化,所以此时离最终的结果还很远.此时,用一个很大的lr会导致数值不稳定.<br>因此,<strong>在warmup策略中,采用线性增长的lr,初期时lr值很小,随着数值稳定时,采用大的lr.</strong></p><ul><li><strong>lr 从 0 线性增长到初始化值</strong></li><li>Goyal et al. [7] proposes a gradual warmup strategy that increases the learning rate from 0 to the initial learning rate linearly.</li><li>In other words, assume we will use the first m batches (e.g. 5 data epochs) to warm up, and the <strong>initial learning rate is η</strong>, then <strong>at batch i, 1 ≤ i ≤ m</strong>, we will set the learning rate to be <strong>iη=m</strong></li></ul><h3 id="3-Zero-gamma-针对residual-block中的BN层初始化"><a href="#3-Zero-gamma-针对residual-block中的BN层初始化" class="headerlink" title="3. Zero $\gamma$ (针对residual block中的BN层初始化)"></a>3. Zero $\gamma$ (针对residual block中的BN层初始化)</h3><blockquote><p>将residual block的最后一层(BN)中的 gamma 值以 0 初始化.</p></blockquote><p><strong>ResNet网络由多个residual block组成, 每个block有几个卷积层. 注意每个 block 的最后一层都是 BN 层.</strong></p><p>给定 <code>input x</code>, 假定 <code>block(x)</code>是这个block的输出,则这个 residual block 的输出是 <code>x + block(x)</code> .</p><ul><li><strong>在 zero gamma 策略中, 我们将所有 BN 层的 gamma 以 <code>0</code> 初始化.</strong></li></ul><p>这就导致了所有 residual block 的输出直接返回了输入, 即 <code>return = x + block(x) = x + 0 = x</code> , 使得 residual block 在初期很容易进行训练.</p><h3 id="4-No-bias-decay"><a href="#4-No-bias-decay" class="headerlink" title="4. No bias decay"></a>4. No bias decay</h3><blockquote><p>不对任何层的 bias 使用正则化 decay.</p></blockquote><p>weight decay 一般应用于所有的 learnable param 包括 weights 和 bias.</p><ul><li>不对任何层的 bias 使用正则化<ul><li>Conv层</li><li>FC层</li><li>BN层</li></ul></li></ul><blockquote><p>以上所述针对于 batch size 小于 2K 的情况.<br>TODO 分层自适应学习率,针对大规模batch情况.<br>Note that LARS [4] offers layer-wise adaptive learning rate and is reported to be effective for extremely large batch sizes (beyond 16K).</p></blockquote><h2 id="3-2-Low-precision-training-GPU低精度"><a href="#3-2-Low-precision-training-GPU低精度" class="headerlink" title="3.2. Low-precision training (GPU低精度)"></a>3.2. Low-precision training (GPU低精度)</h2><p>GPU切换成FP16模式: 只适用于好的GPU如V100, 暂时不用考虑.</p><hr><h1 id="4-Model-Tweaks-模型调整"><a href="#4-Model-Tweaks-模型调整" class="headerlink" title="4. Model Tweaks (模型调整)"></a>4. Model Tweaks (模型调整)</h1><h2 id="4-1-介绍ResNet网络结构"><a href="#4-1-介绍ResNet网络结构" class="headerlink" title="4.1 介绍ResNet网络结构"></a>4.1 介绍ResNet网络结构</h2><p>略</p><h2 id="4-2-ResNet的调整"><a href="#4-2-ResNet的调整" class="headerlink" title="4.2 ResNet的调整"></a>4.2 ResNet的调整</h2><ol><li><p>ResNet-B<br>TODO ??</p></li><li><p>ResNet-C - 将输入第一个conv层的7x7改成3x3<br>such as SENet [12], PSPNet [31], DeepLabV3 [1], and ShuffleNetV2 [21]</p></li><li><p>ResNet-D - 在shortcut路径上,添加一个AvgPool层</p></li></ol><hr><h1 id="5-训练改进"><a href="#5-训练改进" class="headerlink" title="5. 训练改进"></a>5. 训练改进</h1><h2 id="5-1-cos学习率衰减-Cosine-Learning-Rate-Decay"><a href="#5-1-cos学习率衰减-Cosine-Learning-Rate-Decay" class="headerlink" title="5.1. cos学习率衰减  (Cosine Learning Rate Decay)"></a>5.1. cos学习率衰减  (Cosine Learning Rate Decay)</h2><p>学习率的调整在训练过程中至关重要.</p><ul><li>step decay - 每隔30 epochs,降低0.1</li><li>cosine decay<ul><li>根据当前的batch数来调整学习率</li><li>Assume the total number of batches is T (the warmup stage is ignored), then at batch t, the learning rate $lr$ is computed as:</li><li>$lr=\frac{1}{2}(1+cos(\frac{t\pi}{T}))$</li></ul></li><li>曲线形状为cos曲线0~$\pi$的部分<ul><li>学习率开始时下降的缓慢</li><li>中间类似线性下降</li><li>最后下降的缓慢</li></ul></li></ul><h2 id="5-2-标签平滑-Label-Smoothing"><a href="#5-2-标签平滑-Label-Smoothing" class="headerlink" title="5.2. 标签平滑 (Label Smoothing)"></a>5.2. 标签平滑 (Label Smoothing)</h2><h2 id="5-3-知识蒸馏-Knowledge-Distillation"><a href="#5-3-知识蒸馏-Knowledge-Distillation" class="headerlink" title="5.3 知识蒸馏 (Knowledge Distillation)"></a>5.3 知识蒸馏 (Knowledge Distillation)</h2><h2 id="5-4-混合训练-Mixup-Training"><a href="#5-4-混合训练-Mixup-Training" class="headerlink" title="5.4 混合训练 (Mixup Training)"></a>5.4 混合训练 (Mixup Training)</h2><hr><h1 id="6-迁移学习"><a href="#6-迁移学习" class="headerlink" title="6. 迁移学习"></a>6. 迁移学习</h1><h2 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h2><div class="table-container"><table><thead><tr><th>trick</th><th>work?</th></tr></thead><tbody><tr><td><strong>cos学习率下降</strong></td><td><strong>yes</strong></td></tr><tr><td>标签平滑</td><td>no</td></tr><tr><td>蒸馏</td><td>no</td></tr></tbody></table></div><p>因为[标签平滑\知识蒸馏\混合]模糊了像素级别的信息,可能会降低整体的准确率.</p><blockquote><ul><li>TODO: 了解网络结构 SE-ResNeXt-50, SE代表什么? 与ResNet的联系?</li><li>TODO: 用于处理大规模batch情况: LARS [4] offers layer-wise adaptive learning rate</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《&lt;a href=&quot;https://arxiv.org/abs/1812.01187&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bag of Tricks for Image Classification with Convolutional Neural Networks&lt;/a&gt;》论文阅读&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-41-50题</title>
    <link href="http://monteyang.cn/LeetCode-41-50%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-41-50%E9%A2%98.html</id>
    <published>2020-02-11T05:24:11.000Z</published>
    <updated>2020-02-16T16:06:22.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>41~50</code> 题</p></blockquote><a id="more"></a><h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><pre><code>输入: [1,2,0]输出: 3</code></pre><p>示例 2:</p><pre><code>输入: [3,4,-1,1]输出: 2</code></pre><p>示例 3:</p><pre><code>输入: [7,8,9,11,12]输出: 1</code></pre><p>说明:</p><ul><li>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _nums = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n &gt; len(nums):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _nums[n<span class="number">-1</span>] = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(_nums):</span><br><span class="line">            <span class="keyword">if</span> num != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        water_sum = <span class="number">0</span></span><br><span class="line">        left_max_height = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历从 idx=1 到 idx=leng(height)-2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(height) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 求左边最高的墙高</span></span><br><span class="line">            left_max_height = height[i - <span class="number">1</span>] \</span><br><span class="line">                 <span class="keyword">if</span> height[i - <span class="number">1</span>] &gt; left_max_height <span class="keyword">else</span> left_max_height</span><br><span class="line">            <span class="comment"># 求右边最高的墙高</span></span><br><span class="line">            right_max_height = <span class="number">0</span></span><br><span class="line">            right_max_height = max(height[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 当前列可容纳的水量</span></span><br><span class="line">            water = max(min(left_max_height, right_max_height) - height[i], <span class="number">0</span>)</span><br><span class="line">            water_sum += water</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water_sum</span><br></pre></td></tr></table></figure><hr><h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><ul><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            self._dict.update(&#123;str(i): i&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 使num1为长度较小的</span></span><br><span class="line">        <span class="keyword">if</span> len(num1) &gt; len(num2):</span><br><span class="line">            num1, num2 = num2, num1</span><br><span class="line">        num2 = self.str2int(num2)</span><br><span class="line">        <span class="comment"># 将num1的每一位与num2相乘</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num1)+<span class="number">1</span>):</span><br><span class="line">            res += self._dict[num1[-i]] * num2 * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""将str类型转化为int类型"""</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)+<span class="number">1</span>):</span><br><span class="line">            ret += self._dict[num[-i]] * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h1 id="44-TODO"><a href="#44-TODO" class="headerlink" title="44. TODO"></a>44. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="45-TODO"><a href="#45-TODO" class="headerlink" title="45. TODO"></a>45. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="46-TODO"><a href="#46-TODO" class="headerlink" title="46. TODO"></a>46. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="47-TODO"><a href="#47-TODO" class="headerlink" title="47. TODO"></a>47. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="48-TODO"><a href="#48-TODO" class="headerlink" title="48. TODO"></a>48. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="49-TODO"><a href="#49-TODO" class="headerlink" title="49. TODO"></a>49. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="50-TODO"><a href="#50-TODO" class="headerlink" title="50. TODO"></a>50. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;41~50&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/Coding/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Reinforcement Learning-马尔可夫决策过程</title>
    <link href="http://monteyang.cn/Reinforcement-Learning-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.html"/>
    <id>http://monteyang.cn/Reinforcement-Learning-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B.html</id>
    <published>2020-02-09T15:15:16.000Z</published>
    <updated>2020-02-17T17:19:57.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>马尔可夫决策过程（Markov Decision Processes, MDPs）是对强化学习问题的数学描述。</p><ul><li>要求环境是<strong>全观测</strong>的。</li></ul><a id="more"></a><hr><h1 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h1><blockquote><p>“只要知道现在，将来和过去是条件独立的，可以抛去过去所有的信息。”</p></blockquote><p>定义：如果在t时刻的状态$S_t$满足下式，则这个状态被称为<strong>马尔科夫状态</strong>，即该状态满足马尔科夫性</p><script type="math/tex; mode=display">P[S_{t+1}|S_{t}] = P[S_{t+1}|S_1, ..., S_t]</script><p>注：</p><ul><li>状态$S_t$包含了所有历史相关信息，即之前的信息都可以在该状态上体现出来</li><li>所以要求环境是全观测的，(如果是部分观测的话，状态信息有缺失)。</li><li><strong>是否满足马尔可夫性与状态的定义息息相关</strong></li></ul><p>例子：</p><ul><li>下棋</li><li>俄罗斯方块</li></ul><p>有了马尔可夫状态之后：</p><ul><li>定义状态转移矩阵</li><li>忽略时间的影响</li></ul><hr><h1 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h1><p>状态转移概率指从一个马尔可夫状态 s 跳转到后继状态 (successor<br>state) s′ 的概率。</p><script type="math/tex; mode=display">\mathcal{P} _ {ss^{'}} = \mathbb{P} [S_{t+1} = s^{'} | S_t = s]</script><p>若状态是<strong>离散</strong>的（有限个）：<br>所有的状态组成行，所有后继状态组成列，得到状态转移矩阵</p><script type="math/tex; mode=display">\mathcal{P} =\begin{bmatrix}\mathcal{P} _ {11} & ... & \mathcal{P} _ {1n} \\... & ... & ... \\\mathcal{P} _ {n1} & ... & \mathcal{P} _ {nn}  \\\end{bmatrix}</script><ul><li>$n$为状态个数</li><li>每行元素相加为1</li></ul><p>若状态是<strong>连续</strong>的，即无限个状态，适合用本节最上式的函数形式表示。</p><ul><li>此时，$\int_{s’}\mathcal{P}(s’|s)=1$</li></ul><hr><h1 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个马尔可夫过程 (Markov process, MP) 是一个无记忆的随机过程，即一些马尔可夫状态的序列。</p><p>马尔可夫过程可由一个二元组来定义 $<S,\mathcal{P}>$</p><ul><li>$S$：代表状态集合</li><li>$\mathcal{P}$：代表状态转移矩阵</li></ul><blockquote><p>通常假设$\mathcal{P}$是存在且稳定的<br>当$\mathcal{P}$不稳定时，采用在线学习、快速学习等方法</p></blockquote><h2 id="马尔可夫过程的例子"><a href="#马尔可夫过程的例子" class="headerlink" title="马尔可夫过程的例子"></a>马尔可夫过程的例子</h2><p><img data-src="/images/RL-马尔可夫例子.png" alt="马尔可夫链"></p><ul><li>马尔可夫过程中的终止状态有2种：<ul><li>时间终止</li><li>状态终止</li></ul></li></ul><h2 id="片段（Episode）"><a href="#片段（Episode）" class="headerlink" title="片段（Episode）"></a>片段（Episode）</h2><p>定义： 强化学习中，从初始状态 $S_1$ 到终止状态 $S_T$ 的序列过程。</p><script type="math/tex; mode=display">S_1, S_2, ..., S_T</script><hr><h1 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在马尔可夫过程的基础上，<strong>在转移关系中赋予不同的奖励值</strong>，即得到马尔可夫奖励过程。</p><p>马尔可夫奖励 (Markov Reward Process, MRP) 过程由一个四元组组成 $⟨S, \mathcal{P}, \mathcal{R}, γ⟩$</p><ul><li>S：状态集合</li><li>$\mathcal{P}$：状态转移矩阵</li><li>$\mathcal{R}$：奖励函数， $\mathcal{R}(s)$ 描述了在状态 s 的奖励，$\mathcal{R}(s) = E [\mathcal{R}_{t+1}|S_t = s]$</li><li>$γ$：衰减因子</li></ul><h2 id="回报值"><a href="#回报值" class="headerlink" title="回报值"></a>回报值</h2><ul><li>奖励值：对一个<strong>状态</strong>的评价</li><li>回报值：对一个<strong>片段</strong>的评价</li></ul><p>回报值（return $G_t$）是从时间t处开始的累积衰减奖励</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + ...</script><h2 id="MRPs中的值函数"><a href="#MRPs中的值函数" class="headerlink" title="MRPs中的值函数"></a>MRPs中的值函数</h2><blockquote><p>为什么要值函数？<br>回报值是一个片段的结果，存在很大的样本偏差<br>回报值的角标是 t，值函数关注的是状态 s</p></blockquote><p>一个 MRP 的值函数如下定义</p><script type="math/tex; mode=display">v(s) = \mathbb{E}[G_t|S_t = s]</script><p>这里的值函数针对的是状态 s，所以称为<strong>状态值函数</strong>，又称 V 函数</p><h2 id="MRPs中的贝尔曼方程（重点）"><a href="#MRPs中的贝尔曼方程（重点）" class="headerlink" title="MRPs中的贝尔曼方程（重点）"></a>MRPs中的贝尔曼方程（重点）</h2><script type="math/tex; mode=display">\begin{aligned}v(s)&=\mathbb{E}[G_t|S_t=s] \\ &=\mathbb{E}[ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + .. S_t=s] \\ &=\mathbb{E}[ R_{t+1} + \gamma G_{t+1} | S_t=s ] \\ &=\mathbb{E}[ R_{t+1} + \gamma v(S_{t+1}) | S_t=s ]\end{aligned}</script><p>当前状态的值函数包括两部分：</p><ul><li>第一项：瞬时奖励 $R_{t+1}$</li><li>第二项：后继状态 $S_{t+1}$ 的值函数乘衰减系数</li></ul><p>如果已知转移矩阵 $P$，那么</p><script type="math/tex; mode=display">\begin{aligned} v(s) &= \mathbb{E} [R_{t+1} + γv(S_{t+1}) | S_t = s] \\    &= \mathbb{E} [Rt+1jSt = s] + γ \mathbb{E}[v(S_{t+1})|S_t = s] \\&= \mathcal{R}(s) + γ ∑\mathcal{P}_{ss^′}v(s^′)\end{aligned}</script><p>矩阵-向量形式为：</p><script type="math/tex; mode=display">v = \mathcal{R} + \gamma \mathcal{P} v</script><p><img data-src="/images/RL-MRPs贝尔曼方程.png" alt=""></p><p>本质上是一个线性方程，可以直接解：</p><p><img data-src="/images/RL-MRP解贝尔曼.png" alt=""></p><p>直接求解只适用于小型MRPs：</p><ul><li>计算复杂度$O(n^3)$</li><li>要求已知 $\mathcal{P}$</li></ul><hr><h1 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h1><p>在 MRP 中引入决策即得到了马尔可夫决策过程（Markov Decision Processes, MDPs）</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一个马尔可夫决策过程 (MDPs) 由一个五元组构成 $⟨S, \mathcal{A}, \mathcal{P}, \mathcal{R}, γ⟩$</p><ul><li>$\mathcal{A}$ ： 动作的集合</li><li><p>$\mathcal{P}$ ： 状态转移矩阵，</p><script type="math/tex; mode=display">\mathcal{P}_{ss^{'}}^{a} = \mathbb{P}[ S_{t+1}=s' | S_t=s, A_{t}=a]</script></li><li><p>$\mathcal{R}(s,a)$：奖励函数， 表示在状态s做动作a的奖励。$\mathcal{R}(s) = E [\mathcal{R}_{t+1}|S_t = s]$</p></li></ul><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>在 MDPs 中，一个策略 (Policy)π 是在给定状态下的动作的概率分布</p><script type="math/tex; mode=display">\pi(a | s) = \mathbb{P}[ A_t = a | S_t = s ]</script><p><img data-src="/images/RL-MDP策略分布.png" alt=""></p><ul><li>策略是时间稳定的，只与s有关，与时间t无关</li><li>是RL问题的终极目标</li><li>如果分布是 one-hot 的，那么为确定性策略，否则为随机策略</li></ul><p><img data-src="/images/RL-确定性策略.png" alt=""></p><h2 id="MDPs与MRPs之间的关系"><a href="#MDPs与MRPs之间的关系" class="headerlink" title="MDPs与MRPs之间的关系"></a>MDPs与MRPs之间的关系</h2><p>如果MDP问题给定策略$\pi$，则会退化成MRP问题。</p><h2 id="MDPs中的值函数"><a href="#MDPs中的值函数" class="headerlink" title="MDPs中的值函数"></a>MDPs中的值函数</h2><ol><li><p>状态值函数（V函数）</p><ul><li>定义：从状态s开始，使用策略$\pi$得到的期望回报值</li></ul><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}_\pi[G_t|S_t = s]</script></li></ol><ol><li><p>状态动作值函数（Q函数）</p><ul><li><p>定义：MDPs 中的状态动作值函数是从状态 s 开始，执行动作 a， <strong>然后</strong>使用策略 π 得到的期望回报值</p><blockquote><p>动作a不一定来自于策略 $\pi$，实际上是做完动作 a之后，才遵循策略 $\pi$ 进行动作选择</p></blockquote><script type="math/tex; mode=display">q_{\pi}(s, a) = \mathbb{E}_\pi[ G_t | S_t = s, A_t = a ]</script></li></ul></li></ol><h2 id="贝尔曼期望方程"><a href="#贝尔曼期望方程" class="headerlink" title="贝尔曼期望方程"></a>贝尔曼期望方程</h2><p>和 MRP 相似， MDPs 中的值函数也能分解成<strong>瞬时奖励</strong>和<strong>后继状态的值函数</strong>两部分</p><script type="math/tex; mode=display">v_ \pi(s)=\mathbb{E}_ \pi [ R_{t+1} + \gamma v_ \pi(S_{t+1}) | S_t=s ]</script><script type="math/tex; mode=display">q_ \pi(s,a)=\mathbb{E}_ \pi [ R_{t+1} + \gamma q_ \pi(S_{t+1}, A_{t+1}) | S_t=s, A_t=a]</script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;马尔可夫决策过程（Markov Decision Processes, MDPs）是对强化学习问题的数学描述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求环境是&lt;strong&gt;全观测&lt;/strong&gt;的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Reinforcement Learning" scheme="http://monteyang.cn/categories/Reinforcement-Learning/"/>
    
    
      <category term="Reinforcement Learning" scheme="http://monteyang.cn/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-PointNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html</id>
    <published>2020-01-09T06:56:01.000Z</published>
    <updated>2020-02-12T08:59:25.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation"><a href="#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation" class="headerlink" title="PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation"></a>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</h2><ul><li>关键词: point cloud, deep learning</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>直接对点云进行学习 =&gt; 实现分类/分割</li></ul><ul><li>针对点云的深度学习算法需满足的特性:<ul><li><strong>无序性</strong>: 所有点无次序</li><li><strong>点与点之间的关系</strong>: 点与neighbor之间存在局部的结构关系</li><li><strong>变换下的不变性</strong>: 旋转/平移等不改变点云模型的整体类别和局部分割类别</li></ul></li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>提取点云的全局/局部特征<ul><li>全局特征: 表示形状类别的特征</li><li>局部特征: 每个点的特征</li></ul></li></ul><ul><li>T-Net: 将所有点对齐到一个规范空间中</li><li>用<strong>对称函数</strong> MaxPooling: 解决点云的无序性</li><li>对于Segmentation: 局部特征 + 全局特征 (Aggregation)</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/PointNet-Network.png" alt="Network" title="PointNet"></p><ul><li>输入的点数为 n</li><li>global feature 维度1024不是对应点数,而是模型整体的特征</li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>3D分类: ModelNet40</li><li>3D部件分割: ShapeNet的子集(16类)</li><li>3D场景分割: I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,M. Fischer, and S. Savarese. 3d semantic parsing of large-scale indoor spaces.</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>数据预处理<ul><li>在Mesh的表面均匀采样1024个点</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>3D 分类:<ul><li>accuracy</li></ul></li><li>3D 分割:<ul><li>mIoU</li></ul></li></ul><h3 id="4-Disadvantages"><a href="#4-Disadvantages" class="headerlink" title="4. Disadvantages"></a>4. Disadvantages</h3><p>未充分挖掘局部结构特征</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot;&gt;&lt;a href=&quot;#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&quot;&gt;&lt;/a&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: point cloud, deep learning&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-VoxNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html</id>
    <published>2020-01-09T06:38:39.000Z</published>
    <updated>2020-02-12T08:59:25.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition"><a href="#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition" class="headerlink" title="VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition"></a>VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition</h2><ul><li>关键词: voxel, 3D deep learning</li><li>会议: IROS</li><li>源码: official √<ul><li><a href="https://github.com/MonteYang/VoxNet.pytorch" target="_blank" rel="noopener">我的复现: by PyTorch</a></li></ul></li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><p>针对Voxel的3d物体识别/分类</p><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><p>将在视频领域取得一定效果的3D CNN用于Voxel的特征提取</p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/3-VoxNet-Network.png" alt="" title="VoxNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>3种数据集:</p><ul><li>LiDAR data - Sydney Urban Objects</li><li>CAD data - ModelNet</li><li>RGBD data - NYUv2</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO:</p><h3 id="4-Advantages"><a href="#4-Advantages" class="headerlink" title="4. Advantages"></a>4. Advantages</h3><ul><li>表现性能超过了之前的 ShapeNet</li><li>参数比 ShapeNet 少一些  <blockquote><p>ShapeNet is a relatively large architecture, with over 12.4 million parameters, while VoxNet has less than 1 million.</p></blockquote></li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>计算性能受Voxel的分辨率限制: 当Voxel分辨率过高时,内存占用过高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot;&gt;&lt;a href=&quot;#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot; class=&quot;headerlink&quot; title=&quot;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&quot;&gt;&lt;/a&gt;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: voxel, 3D deep learning&lt;/li&gt;
&lt;li&gt;会议: IROS&lt;/li&gt;
&lt;li&gt;源码: official √&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MonteYang/VoxNet.pytorch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的复现: by PyTorch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Voxel" scheme="http://monteyang.cn/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Ciss-Net</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html</id>
    <published>2020-01-09T06:28:22.000Z</published>
    <updated>2020-02-12T08:59:25.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context-Reinforced-Semantic-Segmentation"><a href="#Context-Reinforced-Semantic-Segmentation" class="headerlink" title="Context-Reinforced Semantic Segmentation"></a><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf" target="_blank" rel="noopener">Context-Reinforced Semantic Segmentation</a></h2><ul><li>关键词: reinforcement learning, image segmentation, context</li><li>会议: CVPR 2019</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>Context(上下文信息)在语义分割中至关重要, 挖掘图像中上下文信息</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>使用分割后的图片 p-maps 作为上下文信息的来源</li><li>该项工作提出Context-Net -&gt; 更好的挖掘上下文信息</li><li>将上下文信息的学习过程定义为马尔科夫决策问题(MDP), 使用强化学习方法进行优化</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/CissNet-Network.png" alt="Ciss_Net"></p><ul><li>Environment: <code>p-map</code></li><li>Agent: <code>Context Net</code><ul><li>State: $\{Y_I\}$</li><li>Action: $\{B_I\}$</li></ul></li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>ADE20K</li><li>Cityscapes</li><li>Pascal Context</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO</p><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><!-- ### 4. Advantages ### 5. Disadvantages -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context-Reinforced-Semantic-Segmentation&quot;&gt;&lt;a href=&quot;#Context-Reinforced-Semantic-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;Context-Reinforced Semantic Segmentation&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Context-Reinforced Semantic Segmentation&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: reinforcement learning, image segmentation, context&lt;/li&gt;
&lt;li&gt;会议: CVPR 2019&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Reinforcement Learning" scheme="http://monteyang.cn/tags/Reinforcement-Learning/"/>
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="image segmentation" scheme="http://monteyang.cn/tags/image-segmentation/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-MeshNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html</id>
    <published>2020-01-09T03:18:28.000Z</published>
    <updated>2020-02-12T11:19:25.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation"><a href="#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation" class="headerlink" title="MeshNet: Mesh Neural Network for 3D Shape Representation"></a>MeshNet: Mesh Neural Network for 3D Shape Representation</h2><ul><li>关键词: Mesh, 3D shape classification/retrieval</li><li>会议: AAAI 2018</li><li>源码: √</li></ul><a id="more"></a><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>PoinNet</li><li>KC-Net</li></ul><blockquote><p>Related Work:</p><ul><li>Mesh Feature Extraction</li><li>Deep Learning Methods for 3D Shape Representation<ul><li>voxel-based</li><li>view-based</li><li>point-based</li><li>fusion method</li></ul></li></ul></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h3><ul><li>直接对 Mesh 进行形状表示的学习</li><li>应用于 3D shape classification/retrieval</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>将一个face视作一个单元</li><li><p>face的特征分为:</p><ul><li><strong>空间特征</strong></li><li><strong>结构特征</strong></li></ul></li><li><p>针对<strong>空间特征</strong>和<strong>结构特征</strong>分别提出:</p><ul><li>Spatial Descriptor<ul><li>面的中心点作为输入</li><li>采用与point cloud类似的处理方法</li></ul></li><li>Structural Descriptor<ul><li><strong>face rotate convolution</strong></li><li><strong>face kernel correlation</strong></li></ul></li></ul></li><li><p>整合空间特征和结构特征: 提出 Mesh Convolution</p></li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/MeshNet-Network.png" alt="MeshNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>ModelNet40</p><ul><li>for 3D classification/retrieval</li><li>40类别</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>Mesh模型需先简化至<strong>不多于1024个面</strong>(以面为单位,类似PointNet中以点为单位)</li><li>由于Mesh的面数不恒定, 随机选取填满1024个面 for batch training</li><li>数据增强: 所有点按高斯分布进行随机平移: N(0, 0.01)</li><li>for Classification:<ul><li>global features 后添加 MLP(512, 256, 40): 40表示40个类别</li><li>MLP的最后两层添加dropout层: drop概率为0.5</li></ul></li><li>for Retrieval:<ul><li>global features 直接计算 L2 距离</li></ul></li><li>训练时的超参数:<ul><li>SGD optimizer</li><li>initial learning rate 0.01</li><li>momentum 0.9</li><li>weight decay 0.0005</li><li>batch size 64.</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>Classification: Accuracy</li><li>Retrieval: mAP</li></ul><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><p>TODO:</p><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><p><img data-src="/images/MeshNet-exp-results.png" alt="实验结果" title="ModelNet实验结果"><br>&lt;!— ### 4. Advantages</p><ul><li>将point的方法应用于Mesh的特征提取(空间提取, KC)</li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>空间特征提取 不仅考虑面的中心点, 可以加入中心点周围的三个点的信息, 可能会有所提升.</li><li>当前面和周围三个面可能会有相似的特征.可否进行替换 —&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot;&gt;&lt;a href=&quot;#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot; class=&quot;headerlink&quot; title=&quot;MeshNet: Mesh Neural Network for 3D Shape Representation&quot;&gt;&lt;/a&gt;MeshNet: Mesh Neural Network for 3D Shape Representation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: Mesh, 3D shape classification/retrieval&lt;/li&gt;
&lt;li&gt;会议: AAAI 2018&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Mesh" scheme="http://monteyang.cn/tags/Mesh/"/>
    
  </entry>
  
  <entry>
    <title>Paper Reading Plan</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html</id>
    <published>2020-01-09T03:02:40.000Z</published>
    <updated>2020-02-12T09:05:18.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h2><ul><li>[x] AlexNet</li><li>[x] VGGNet</li><li>[x] ResNet</li><li>[x] InceptionNet</li><li>[ ] DenseNet</li><li>[ ] SENet</li></ul><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><ul><li>[x] MeshNet</li><li>[ ] MeshCNN</li></ul><h2 id="Voxel"><a href="#Voxel" class="headerlink" title="Voxel"></a>Voxel</h2><ul><li>[ ] 3D ShapeNet</li><li>[ ] VoxNet</li><li>[ ] OctNet</li><li>[ ] FPNN</li><li>[ ] O-CNN</li></ul><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>[X] PointNet</li><li>[x] PointNet++</li><li>[x] KC-Net</li><li>[ ] PointSIFT</li><li>[ ] Point-Voxel</li><li>[ ] PointGrid</li></ul><h2 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h2><ul><li>[ ] DeepSDF</li></ul><h2 id="Reinfocement-Learning"><a href="#Reinfocement-Learning" class="headerlink" title="Reinfocement Learning"></a>Reinfocement Learning</h2><ul><li>[ ] DDPG</li><li>[ ] MADDPG</li></ul><h2 id="CNN-basic"><a href="#CNN-basic" class="headerlink" title="CNN-basic"></a>CNN-basic</h2><ul><li>[x] Tricks-of-CNN</li></ul><h2 id="Image-Segmentation"><a href="#Image-Segmentation" class="headerlink" title="Image Segmentation"></a>Image Segmentation</h2><ul><li>[ ] FCN</li><li>[ ] U-Net</li><li>[ ] SegNet</li><li>[ ] DeepLab系列</li><li>[ ] Fully Convolutional DenseNet</li><li>[ ] E-Net</li><li>[ ] Link-Net</li><li>[ ] Mask R-CNN</li><li>[ ] PSPNet</li><li>[ ] RefineNet</li><li>[ ] HR-Net</li><li>[ ] Ciss-Net</li></ul><!-- ---- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation-CVPR2017-论文链接-tensorflow代码-pytorch代码- PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space-NIPS2017-论文链接-tensorflow代码-pytorch代码- Escape from Cells: Deep Kd-Networks for the Recognition of 3D Point Cloud Models-ICCV2017-论文链接-pytorch代码- KCNet: Mining Point Cloud Local Structures by Kernel Correlation and Graph Pooling-CVPR2018-论文链接-caffe代码-pytorch代码- Pointwise Convolutional Neural Networks-CVPR2018-论文链接-tensorflow代码- SO-Net: Self-Organizing Network for Point Cloud Analysis-CVPR2018-论文链接-pytorch代码- Recurrent Slice Networks for 3D Segmentation of Point Clouds-CVPR2018-论文链接-pytorch代码- SPLATNet: Sparse Lattice Networks for Point Cloud Processing-CVPR2018-l论文链接-caffe代码-pytorch代码- Large-scale Point Cloud Semantic Segmentation with Superpoint Graphs-CVPR2018-论文链接-pytorch代码- Dynamic Graph CNN for Learning on Point Cloud-arxiv2018-论文链接-代码链接- Local Spectral Graph Convolution for Point Set Feature Learning-ECCV2018-论文链接-tensorflow代码- SpiderCNN: Deep Learning on Point Sets with Parameterized Convolutional Filters-ECCV2018-论文链接-tensorflow代码- Point Convolutional Neural Networks by Extension Operators-SIGGRAPH 2018-论文链接-tensorflow代码- PointCNN: Convolution On X-Transformed Points-NeurIPS 2018-论文链接-tensorflow代码-mxnet代码-pytorch代码- PointSIFT: A SIFT-like Network Module for 3D Point Cloud Semantic Segmentation-arxiv2018-论文链接-tensorflow代码-pytorch代码- PointConv: Deep Convolutional Networks on 3D Point Clouds-arxiv2018-论文链接- Adversarial Autoencoders for Generating 3D Point Clouds-arxiv2018-论文链接- Modeling Local Geometric Structure of 3D Point Clouds using Geo-CNN-论文链接- Supervised Fitting of Geometric Primitives to 3D Point Clouds-CVPR2019-l论文链接-tensorflow代码- Multi-view Point Cloud Registration with Adaptive Convergence Threshold and its Application on 3D Model Retrieval-论文链接- Iterative Transformer Network for 3D Point Cloud-arxiv2018-论文链接- DeepMapping: Unsupervised Map Estimation From Multiple Point Clouds-arxiv2018-论文链接- CAPNet: Continuous Approximation Projection For 3D Point Cloud Reconstruction Using 2D Supervision-论文链接-AAAI2019-代码链接- Increasing the Capability of Neural Networks for Surface Reconstruction from Noisy Point Clouds-arxiv2018-论文链接- Topology-Aware Surface Reconstruction for Point Clouds-arxiv2018-论文链接- Nesti-Net: Normal Estimation for Unstructured 3D Point Clouds using Convolutional Neural Networks-arxiv2018-论文链接- Inferring Point Clouds from Single Monocular Images by Depth Intermediation-arxiv2018-论文链接- Learning Saliency Maps for Adversarial Point-Cloud Generation-arxiv2019-论文链接- A Graph-CNN for 3D Point Cloud Classification- ICASSP 2018-论文链接-tensorflow代码- GSPN: Generative Shape Proposal Network for 3D Instance Segmentation in Point Cloud-arxiv2018-论文链接- PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud-arxiv2018-论文链接- Deep RBFNet: Point Cloud Feature Learning using Radial Basis Functions-arxiv2018-论文链接- IPOD: Intensive Point-based Object Detector for Point Cloud-arxiv2018-论文链接- PointPillars: Fast Encoders for Object Detection from Point Clouds-arxiv2018-论文链接- 3D Point Cloud Learning for Large-scale Environment Analysis and Place Recognition-arxiv2018-论文链接- 3D Point Cloud Denoising via Bipartite Graph Approximation and Reweighted Graph Laplacian-arxiv2018-论文链接- Casualty Detection from 3D Point Cloud Data for Autonomous Ground Mobile Rescue Robots-SSRR)2018-论文链接- Deflecting 3D Adversarial Point Clouds Through Outlier-Guided Removal-arxiv2018-论文链接- Machine learning enables polymer cloud-point engineering via inverse design-arxiv2018-论文链接- 3D Convolution on RGB-D Point Clouds for Accurate Model-free Object Pose Estimation-arxiv2018-论文链接- Feature Preserving and Uniformity-controllable Point Cloud Simplification on Graph-arxiv2018-论文链接- GeoNet: Deep Geodesic Networks for Point Cloud Analysis-CVPR2019-论文链接- POINTCLEANNET: Learning to Denoise and Remove Outliers from Dense Point Clouds-arxiv2018-论文链接-pytorch代码- Generic Primitive Detection in Point Clouds Using Novel Minimal Quadric Fits-T-PAMI2019-论文链接- Fast 3D Line Segment Detection From Unorganized Point Cloud-arxiv2019-论文链接- Extending Adversarial Attacks and Defenses to Deep 3D Point Cloud Classifiers-arxiv2019-论文链接-tensorflow代码- Skeletonisation Algorithms for Unorganised Point Clouds with Theoretical Guarantees-arxiv2019-论文链接- Automatic normal orientation in point clouds of building interiors-arxiv2019-论文链接- Fitting 3D Shapes from Partial and Noisy Point Clouds with Evolutionary Computing-arxiv2019-论文链接- Context Prediction for Unsupervised Deep Learning on Point Clouds-arxiv2019-论文链接- Dense 3D Point Cloud Reconstruction Using a Deep Pyramid Network-WACV 2019-论文链接- Points2Pix: 3D Point-Cloud to Image Translation using conditional Generative Adversarial Networks-arxiv2019-l论文链接- NeuralSampler: Euclidean Point Cloud Auto-Encoder and Sampler-arxiv2019-l论文链接- Embedded Delaunay triangulations for point clouds of surfaces in-arxiv2019-l论文链接- 3D point cloud registration with shape constraint-ICIP 2017-论文链接- Occupancy-map-based rate distortion optimization for video-based point cloud compression-arxiv2019-论文链接- 3D Graph Embedding Learning with a Structure-aware Loss Function for Point Cloud Semantic Instance Segmentation-arxiv2019-论文链接- PIXOR: Real-time 3D Object Detection from Point Clouds- CVPR2018-论文链接-pytorch代码- Multi-view Incremental Segmentation of 3D Point Clouds for Mobile Robots-arxiv2019-论文链接- Point cloud denoising based on tensor Tucker decomposition-CVPR2019-l论文链接- Associatively Segmenting Instances and Semantics in Point Clouds-CVPR2019-论文链接- Zero-shot Learning of 3D Point Cloud Objects-MVA2019-论文链接- Octree guided CNN with Spherical Kernels for 3D Point Clouds-arxiv2019-论文链接- Real-time Multiple People Hand Localization in 4D Point Clouds-arxiv2019-论文链接- Variational Graph Methods for Efficient Point Cloud Sparsification-arxiv2019-代码链接- HoloCast: Graph Signal Processing for Graceful Point Cloud Delivery-arxiv2019-论文链接- Fast Registration for cross-source point clouds by using weak regional affinity and pixel-wise refinement-ICME 2019-论文链接- PointNetLK: Robust & Efficient Point Cloud Registration using PointNet-arxiv2019-论文链接- Neural Style Transfer for Point Clouds-arxiv2019-论文链接- OREOS: Oriented Recognition of 3D Point Clouds in Outdoor Scenarios-arxiv2019-论文链接- Learning Convolutional Transforms for Lossy Point Cloud Geometry Compression-arxiv2019-论文链接- Monocular 3D Object Detection with Pseudo-LiDAR Point Cloud-论文链接-arxiv2019- FVNet: 3D Front-View Proposal Generation for Real-Time Object Detection from Point Clouds-论文链接-arxiv2019- Unpaired Point Cloud Completion on Real Scans using Adversarial Training-论文链接-arxiv2019- USIP: Unsupervised Stable Interest Point Detection from 3D Point Clouds-论文链接-arxiv2019-代码链接- MortonNet: Self-Supervised Learning of Local Features in 3D Point Clouds-论文链接-arxiv2019- Discrete Rotation Equivariance for Point Cloud Recognition-论文链接-ICRA 2019-代码链接- JSIS3D: Joint Semantic-Instance Segmentation of 3D Point Clouds with Multi-Task Pointwise Networks and Multi-Value Conditional Random Fields-论文链接-CVPR 2019(oral)-代码链接- DeepPoint3D: Learning Discriminative Local Descriptors using Deep Metric Learning on 3D Point Clouds-论文链接-arxiv2019- A Dataset for Semantic Segmentation of Point Cloud Sequences-论文链接-arxiv2019- Point Cloud Oversegmentation with Graph-Structured Deep Metric Learning-论文链接-CVPR2019- Generalizing discrete convolutions for unstructured point clouds-论文链接-arxiv2019- 3D Point Cloud Denoising via Deep Neural Network based Local Surface Estimation-论文链接-arxiv2019- Complexer-YOLO: Real-Time 3D Object Detection and Tracking on Semantic Point Clouds-论文链接-arxiv2019- Total Denoising: Unsupervised Learning of 3D Point Cloud Cleaning-论文链接-arxiv2019- 3D Object Recognition with Ensemble Learning — A Study of Point Cloud-Based Deep Learning Models-论文链接-arxiv2019- Deep Hough Voting for 3D Object Detection in Point Clouds-论文链接-arxiv2019- 2D3D-MatchNet: Learning to Match Keypoints Across 2D Image and 3D Point Cloud-论文链接-arxiv2019- PCAN: 3D Attention Map Learning Using Contextual Information for Point Cloud Based Retrieval-论文链接-CVPR2019- Graph-based Inpainting for 3D Dynamic Point Clouds-论文链接-arxiv2019- 3D Dynamic Point Cloud Denoising via Spatio-temporal Graph Modeling-论文链接-arxiv2019- RL-GAN-Net: A Reinforcement Learning Agent Controlled GAN Network for Real-Time Point Cloud Shape Completion-论文链接-cvpr2019-代码链接- Unsupervised Feature Learning for Point Cloud by Contrasting and Clustering With Graph Convolutional Neural Network-论文链接-arxiv2019- Loop-Closure Detection Based on 3D Point Cloud Learning for Self-Driving Industry Vehicles-论文链接-arxiv2019- Oriented Point Sampling for Plane Detection in Unorganized Point Clouds-论文链接-ICRA2019- Deep Closest Point: Learning Representations for Point Cloud Registration-论文链接-arxiv2019- Deep AutoEncoder-based Lossy Geometry Compression for Point Clouds-论文链接-arxiv2019- DeepICP: An End-to-End Deep Neural Network for 3D Point Cloud Registration-论文链接-arxiv2019- Deep Unsupervised Learning of 3D Point Clouds via Graph Topology Inference and Filtering-论文链接-arxiv2019- Cooper: Cooperative Perception for Connected Autonomous Vehicles based on 3D Point Clouds-论文链接 -ICDCS 2019- 3D Point Cloud Generative Adversarial Network Based on Tree Structured Graph Convolutions-论文链接-arxiv2019- SAWNet: A Spatially Aware Deep Neural Network for 3D Point Cloud Processing-论文链接-arxiv2019- A Two-stage Classification Method for High-dimensional Data and Point Clouds-论文链接-arxiv2019- GAPNet: Graph Attention based Point Neural Network for Exploiting Local Feature of Point Cloud-论文链接-arxiv2019- RIU-Net: Embarrassingly simple semantic segmentation of 3D LiDAR point cloud-论文链接-arxiv2019- Domain Adaptation for Vehicle Detection from Bird’s Eye View LiDAR Point Cloud Data-论文链接-Under review for IEEE SMC 2019- Robust Point Cloud Based Reconstruction of Large-Scale Outdoor Scenes-论文链接-CVPR2019- Efficient Curvature Estimation for Oriented Point Clouds-论文链接-arxiv2019- Leveraging binding-site structure for drug discovery with point-cloud methods-论文链接-arxiv2019- NPTC-net: Narrow-Band Parallel Transport Convolutional Neural Network on Point Clouds-论文链接-arxiv2019- Partial Computing Offloading Assisted Cloud Point Registration in Multi-robot SLAM-论文链接-arxiv2019- Point Clouds Learning with Attention-based Graph Convolution Networks-论文链接-arxiv2019- Learning Object Bounding Boxes for 3D Instance Segmentation on Point Clouds-论文链接-arxiv2019- Direct structural analysis of domains defined by point clouds-论文链接-arxiv2019- Learning Shape Representation on Sparse Point Clouds for Volumetric Image Segmentation-论文链接-MICCAI 2019 --><!--Templete---分界线---## 文章信息- 标题:- 关键词:- 会议:- 源码: √## 相关文章:> Related Work:## Note### 1. Plroblem### 2. Method#### Network Structure### 3. Experiment#### 3.1 Dataset#### 3.2 Implemention#### 3.3 Metric#### 3.4 Ablation Study#### 3.5 Result<!--### 4. Advantages### 5. Disadvantages-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Neural-Network&quot;&gt;&lt;a href=&quot;#Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Neural Network&quot;&gt;&lt;/a&gt;Neural Network&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[x] AlexNet&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="计划" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="paper reading plan" scheme="http://monteyang.cn/tags/paper-reading-plan/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31-40题</title>
    <link href="http://monteyang.cn/LeetCode-31-40%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-31-40%E9%A2%98.html</id>
    <published>2020-01-08T02:56:02.000Z</published>
    <updated>2020-02-16T16:04:32.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>31~40</code> 题</p></blockquote><a id="more"></a><hr><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><blockquote><p>思路:<br>字典序算法</p><ol><li>从右往左, 找出第一个小于右邻的数 <code>list[x]</code>;</li><li>从右往左, 找出第一个比 <code>list[x]</code> 大的数 <code>list[y]</code>;</li><li>交换 <code>list[x]</code> 和 <code>list[y]</code>;</li><li>将 <code>list[x]</code> 后面的序列从小到大排序. </li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在下一个更大的字典序(即当前序列为最大的字典序), 则将序列转为最小字典序</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">-1</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                y = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 3, 4</span></span><br><span class="line">        nums[x], nums[y] = nums[y], nums[x]</span><br><span class="line">        nums[x+<span class="number">1</span>:] = sorted(nums[x+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><blockquote><p>思路:</p><ol><li>用栈实现括号匹配</li><li>用数组保存一个有效括号的索引值</li><li>对所有索引值进行排序</li><li>找出连续索引长度中的最长长度</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># ()()()(()()()(()))</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        idxs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># 如果栈为空时</span></span><br><span class="line">            <span class="keyword">if</span> stack == []:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 如果栈非空时</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    idxs.append(i)</span><br><span class="line">                    idxs.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line"></span><br><span class="line">        idxs.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> idxs: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(idxs)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> idxs[j+<span class="number">1</span>] - idxs[j] == <span class="number">1</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> max_length &lt; length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(length, max_length)</span><br></pre></td></tr></table></figure><hr><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p><p>示例 1:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums = [4,5,6,7,0,1,2]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 找出最小值的索引</span></span><br><span class="line">        min_idx = self.search_min_idx(nums)</span><br><span class="line">        <span class="keyword">if</span> min_idx != <span class="number">0</span>:</span><br><span class="line">            nums = nums[min_idx:] + nums[:min_idx]</span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        tmp_idx = self.bin_search(nums, target)</span><br><span class="line">        <span class="keyword">if</span> tmp_idx == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> (tmp_idx + min_idx) % len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_min_idx</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> </span></span><br><span class="line">        <span class="keyword">return</span> nums.index(min(nums))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        二分查找法:</span></span><br><span class="line"><span class="string">            - 如果nums中存在目标值, 则返回该值的index;</span></span><br><span class="line"><span class="string">            - 如果nums中不存在目标值, 则返回 -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h1 id="34-TODO"><a href="#34-TODO" class="headerlink" title="34. TODO"></a>34. TODO</h1><hr><h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><pre><code>输入: [1,3,5,6], 5输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [1,3,5,6], 2输出: 1</code></pre><p>示例 3:</p><pre><code>输入: [1,3,5,6], 7输出: 4</code></pre><p>示例 4:</p><pre><code>输入: [1,3,5,6], 0输出: 0</code></pre><blockquote><p><strong>思路</strong></p><ol><li>扫一次, 若当前值小于 <code>target</code>, 则跳过; 若当前值大于等于 <code>target</code>, 则返回当前索引</li><li>若所有元素都小于 <code>target</code>, 则返回<code>(最大索引+1)</code></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><hr><h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1:</p><pre><code>输入:[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true</code></pre><p>示例 2:</p><pre><code>输入:[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。    但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><pre><code>一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。给定数独永远是 9x9 形式的。</code></pre><blockquote><p><strong>思路</strong></p><ol><li>数独板块中共有 <strong>9行 \ 9列 \ 9个小块</strong>, <strong>每行 \ 每列 \ 每个小块</strong> 都建立一个 hash map, 用来记录该<strong>行\列\小块</strong>中数字对应的个数</li><li>遍历所有 9*9 个元素:<ol><li>一旦 hash map 中存在大于1个的元素, 则不满足数独条件, 返回 <code>false</code>;</li><li>如果遍历结束后, 都未出现 <code>false</code>, 则满足数独条件.</li></ol></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        small_box = [[&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]  <span class="comment"># 3*3个 small box</span></span><br><span class="line">        row = [&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 9行</span></span><br><span class="line">        colum = copy.deepcopy(row)  <span class="comment"># 9列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx_row, r <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> idx_colum, num <span class="keyword">in</span> enumerate(r):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">'.'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前元素为 num, 判断该元素属于哪个small_box</span></span><br><span class="line">                <span class="comment"># 如果对应的small box中没有该数, 设置hash中的key的value为1</span></span><br><span class="line">                <span class="comment"># 如果对应的small box已存在该数, 则返回错误</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>]:</span><br><span class="line">                    small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前row中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> row[idx_row]:</span><br><span class="line">                    row[idx_row][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前列中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> colum[idx_colum]:</span><br><span class="line">                    colum[idx_colum][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="37-TODO"><a href="#37-TODO" class="headerlink" title="37. TODO"></a>37. TODO</h1><hr><h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221</li></ol><p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>示例 1:</p><pre><code>输入: 1输出: &quot;1&quot;解释：这是一个基本样例。</code></pre><p>示例 2:</p><pre><code>输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre><blockquote><p>思路：<br>迭代求解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        s = <span class="string">'1*'</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            s = self.util(s)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">""" 输入s, 返回s的下一个外观数列, 注意s的最后一个字符是'*'.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            s (string): 以 * 结尾的字符串</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 下一个外观数列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (str(cnt) + s[i - <span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        s = res + <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><hr><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><pre><code>所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><pre><code>输入: candidates = [2,3,6,7], target = 7,所求解集为:[⁠ [7],⁠ [2,2,3]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,3,5], target = 8,所求解集为:[[2,2,2,2],[2,3,3],[3,5]]</code></pre><blockquote><p>思路: 回溯法 + 利用树的数据结构判断</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        candidates.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(candidates, cur_sum, tmp_list)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> candidates == []: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表之和等于 target, 加入res</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(tmp_list)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表元素之和大于 target，直接返回（剪枝）</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前列表元素之和小于 target，继续添加元素</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    _tmp_list = copy.deepcopy(tmp_list)</span><br><span class="line">                    _tmp_list.append(c)</span><br><span class="line">                    util(candidates[i:], cur_sum+c, _tmp_list)</span><br><span class="line">        </span><br><span class="line">        util(candidates, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="40-组合之和II"><a href="#40-组合之和II" class="headerlink" title="40. 组合之和II"></a>40. 组合之和II</h1><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1:</p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[[1,2,2],[5]]</code></pre><blockquote><p>思路:<br>与上一题相似, 多增加去重步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()  <span class="comment"># [1,1,2,5,6,]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(cur_sum, cur_list, candidates)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(cur_list)</span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> c == candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                    _cur_list = cur_list[:]</span><br><span class="line">                    _cur_list.append(c)</span><br><span class="line">                    back_track(cur_sum+c, _cur_list, candidates[i+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        back_track(<span class="number">0</span>, [], candidates)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;31~40&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/Coding/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2019年的总结</title>
    <link href="http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html</id>
    <published>2020-01-04T15:15:35.000Z</published>
    <updated>2020-02-16T16:03:05.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="校园"><a href="#校园" class="headerlink" title="校园"></a>校园</h2><ul><li><p>研究生生涯已经过半，终于把除了毕业论文之外的学分修满(.);</p></li><li><p>从19年4月开始和师兄进行科研，虽然最终实验效果没有想象中的理想，但过程中收获师兄的指导和编程经验难能宝贵；</p></li><li><p>记得18年，某位前辈说想搞编程一定要学好数据结构，今年终于在Coding和做Leetcode过程中，对数据结构有些理解；</p></li><li><p>开题过程还算顺利，有幸能做自己感兴趣的3D deeplearning相关的题目；</p></li><li><p>年底建了个博客，是因为记性太差了，想在上面记录些东西。</p></li></ul><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><ul><li>[X] 杭州</li><li>[X] 秦皇岛</li><li>[X] 大连</li><li>[X] 上海</li><li>[X] 南京</li></ul><p>算下来也走了不少地方。身为一个东北人，印象最深的还是南方城市的人们都非常遵守交通规则，旅行这一路貌似没怎么听过鸣笛声，而且抢道超车的现象少一些…</p><p>感觉旅行就是换一个地方逛一逛、瞧一瞧、吃一吃，顺便假装体会下当地的风土人情。</p><p>希望家乡沈阳越来越好。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><ul><li><p>在一起3年多了，自己的心态也成熟一些，最近发现情商高不等于会说好话哄对方开心，而是管理情绪的能力；</p></li><li><p>个人不太向往轰轰烈烈的感情，有个小窝能安逸生活即可；</p></li><li><p>虽然个人没有远大的追求，但也会尽力去满足对方对感情的期待；</p></li><li><p>渐渐发现家庭感的缺失，或许该适当地调整人生中的重要性排序。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>关于电影</p><p>  今年几乎每周都去看一次电影，好片烂片的基本没什么感觉。。印象最深的还是《海贼王》，最动然的是乌索普的坚持。因为现在已经很明白，失败是一种平常，成功才是偶然。</p></li><li><p>关于书</p><ul><li><p>惭愧，今年只看过一本书《暗时间》。对自己的影响实在太大，让我明白坚持做一件事的意义和如何更好的坚持；</p></li><li><p>之前买了很多技术类的书，后来发现根本没啥用，碰到问题都Google了。准备今年把这些书全卖了，如果真的需要，不如搞个PDF省心省力。</p></li></ul></li></ul><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>2020，做个平凡快乐的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;校园&quot;&gt;&lt;a href=&quot;#校园&quot; class=&quot;headerlink&quot; title=&quot;校园&quot;&gt;&lt;/a&gt;校园&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;研究生生涯已经过半，终于把除了毕业论文之外的学分修满(.);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从19年4月开始和师兄进行
      
    
    </summary>
    
    
      <category term="总结与随感" scheme="http://monteyang.cn/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="总结" scheme="http://monteyang.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21-30题</title>
    <link href="http://monteyang.cn/LeetCode-21-30%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-21-30%E9%A2%98.html</id>
    <published>2020-01-04T13:42:00.000Z</published>
    <updated>2020-02-16T16:05:22.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>21~30</code>题</p></blockquote><a id="more"></a><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        head = ListNode(<span class="string">"#"</span>)</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> (p2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p1) <span class="keyword">or</span> (p1 <span class="keyword">and</span> (p1.val &lt;= p2.val)):</span><br><span class="line">                cur.next = ListNode(p1.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> (p1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p2) <span class="keyword">or</span> (p2 <span class="keyword">and</span> (p2.val &lt; p1.val)):</span><br><span class="line">                cur.next = ListNode(p2.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></h2><h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><pre><code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><blockquote><p>思路:<br>回溯法,利用递归生成括号.</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">                           l0 r0</span></span><br><span class="line"><span class="string">                        /          \</span></span><br><span class="line"><span class="string">                       (          </span></span><br><span class="line"><span class="string">                    l1 r0           </span></span><br><span class="line"><span class="string">                    /   \        </span></span><br><span class="line"><span class="string">                  ((     ()         </span></span><br><span class="line"><span class="string">                l2 r0   l1 r1</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(cur_str, n_lb, n_rb)</span>:</span></span><br><span class="line">            <span class="comment"># 超出括号数量则终止</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n <span class="keyword">or</span> n_rb &gt; n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 左右括号数量均达到n,则添加到res</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb == n:</span><br><span class="line">                res.append(cur_str)</span><br><span class="line">            <span class="comment"># 左右括号数量相等时,当前string只能添加'(',剪枝?</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">            <span class="comment"># 左括号大于右括号时,当前string可以添加'('或')'</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">                util(cur_str+<span class="string">')'</span>, n_lb, n_rb+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 左括号小于右括号则返回</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &lt; n_rb:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        util(<span class="string">''</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><pre><code>输入:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><blockquote><p>思路:<br>先对所有链表结点中的value进行排序,然后根据排序后的value生成一个长链表.</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 特殊情况: lists为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对所有val进行排序</span></span><br><span class="line">        val_all = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    val_all.append(node.val)</span><br><span class="line">                    node = node.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val_all = sorted(val_all)</span><br><span class="line">        <span class="comment"># 生成整个链表</span></span><br><span class="line">        head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> val_all:</span><br><span class="line">            node.next = ListNode(v)</span><br><span class="line">            node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></h2><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><blockquote><p>思路:<br>两两交换结点:添加1个头和1个尾,以便交换中间的两个结点.</p></blockquote><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        p_head  -&gt;   1    -&gt;     2    -&gt;    3   -&gt;  4</span></span><br><span class="line"><span class="string">        (p)     -&gt;   q    -&gt;     r    -&gt;    s </span></span><br><span class="line"><span class="string">                          -&gt;    (p)   -&gt;    q   -&gt;  r </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置头结点,方便后续处理</span></span><br><span class="line">        p_head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        p_head.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如图设置p,q,r,s的指向</span></span><br><span class="line">        p = p_head</span><br><span class="line">        q = p.next</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:  <span class="comment"># 奇数个结点则跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 交换</span></span><br><span class="line">            s = r.next</span><br><span class="line">            r.next = q</span><br><span class="line">            q.next = s</span><br><span class="line">            p.next = r</span><br><span class="line">            <span class="comment"># 移动指针p的指向</span></span><br><span class="line">            p = p.next.next</span><br><span class="line">            q = p.next</span><br><span class="line">        <span class="comment"># 必须返回p_head.next, 不能返回head, 因为head已经在链表中被交换.</span></span><br><span class="line">        <span class="keyword">return</span> p_head.next</span><br></pre></td></tr></table></figure></h2><h1 id="k-个一组翻转链表"><a href="#k-个一组翻转链表" class="headerlink" title="k-个一组翻转链表"></a>k-个一组翻转链表</h1><p>TODO</p><hr><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><pre><code>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:</p><ol><li>利用快慢指针: </li><li>利用排好序的性质: 类似栈,相等则弹出</li></ol></blockquote><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        p = - float(<span class="string">"inf"</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 如果下一个数和当前指向的元素相等, 删除下一个数</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] == p:</span><br><span class="line">                    <span class="keyword">del</span> nums[i]</span><br><span class="line">                <span class="comment"># 如果不等, 保留</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p = nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure></h2><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p>给定一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地</strong>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><pre><code>给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:<br>快慢指针</p></blockquote><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果第i个元素等于目标值val, 跳过</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果第i个元素不等于目标值val, 从头依次添加到原list中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure></h2><h1 id="实现-str-str"><a href="#实现-str-str" class="headerlink" title="实现-str-str"></a>实现-str-str</h1><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2</code></pre><p>示例 2:</p><pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1</code></pre><p><strong>说明:</strong><br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)-len(needle)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>TODO: KMP</p><hr><h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>示例 1:</p><pre><code>输入: dividend = 10, divisor = 3输出: 3</code></pre><p>示例 2:</p><pre><code>输入: dividend = 7, divisor = -3输出: -2</code></pre><p>说明:</p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</li></ul><blockquote><p>思路:<br>倍增再相减,类似二分查找</p></blockquote><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(dividend, divisor)</span>:</span></span><br><span class="line">            <span class="string">""" 除数倍增(×2), 获取被除数与除数间最大的2次幂倍数 """</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> dividend &gt; divisor*i*<span class="number">2</span>:</span><br><span class="line">                    i *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="comment"># 获取结果的符号</span></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        dividend = abs(dividend)</span><br><span class="line">        divisor = abs(divisor)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            _j = util(dividend, divisor)</span><br><span class="line">            j += _j</span><br><span class="line">            dividend = dividend - _j*divisor</span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">if</span> sign*j &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> sign*j &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">                <span class="keyword">return</span> sign * j</span><br></pre></td></tr></table></figure></h2><h1 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h1><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><pre><code>输入：s = &quot;barfoothefoobarman&quot;,words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;wordgoodgoodgoodbestword&quot;,words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]</code></pre><blockquote><p>思路:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> res</span><br><span class="line">        len_sub_string = len(words[<span class="number">0</span>])  <span class="comment"># word字符串的长度</span></span><br><span class="line">        <span class="comment"># 用一个hash表对应word和word的个数</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table[w] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[w] = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 遍历所有元素的指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s) - len_sub_string*len(words) + <span class="number">1</span>:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># copy一个hash表作为临时</span></span><br><span class="line">            _hash_table = copy.deepcopy(hash_table)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 在当前指针i处遍历,如果hash表为空,则添加i</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _hash_table:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                <span class="keyword">if</span> s[j:j+len_sub_string] <span class="keyword">in</span> _hash_table:</span><br><span class="line">                    <span class="keyword">if</span> _hash_table[s[j:j+len_sub_string]] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">del</span> _hash_table[s[j:j+len_sub_string]]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        _hash_table[s[j:j+len_sub_string]] -= <span class="number">1</span></span><br><span class="line">                    j = j + len_sub_string</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>TODO: 时间复杂度</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;21~30&lt;/code&gt;题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/Coding/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11-20题</title>
    <link href="http://monteyang.cn/LeetCode-11-20%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-11-20%E9%A2%98.html</id>
    <published>2019-12-17T13:59:50.000Z</published>
    <updated>2020-02-16T16:04:26.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>11~20</code> 题</p></blockquote><a id="more"></a><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img data-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><ul><li>示例:<br>  输入: [1,8,6,2,5,4,8,3,7]<br>  输出: 49</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 1. 暴力法</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    def maxArea(self, height):</span></span><br><span class="line"><span class="string">        max_area = 0</span></span><br><span class="line"><span class="string">        for i in range(len(height)):</span></span><br><span class="line"><span class="string">            for j in range(i+1, len(height)):</span></span><br><span class="line"><span class="string">                max_area = max(min(height[i], height[j]) * (j - i), max_area)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return max_area</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 2. 双指针法</span></span><br><span class="line">    <span class="comment"># - 一般来说,距离最远的围成较大面积的可能性较大</span></span><br><span class="line">    <span class="comment"># - 两头各放一个指针</span></span><br><span class="line">    <span class="comment"># - 较短一侧的指针往里移动, 才可能使面积变大(虽然两指针距离变短,但是较短一侧的高度可能变大)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        pt_left = <span class="number">0</span></span><br><span class="line">        pt_right = len(height) - <span class="number">1</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 新算的面积 = min(height[pt_left], height[pt_right])*(pt_right - pt_left)</span></span><br><span class="line">            <span class="comment"># 最大面积 = max(新算的面积, 原来的最大面积)</span></span><br><span class="line">            max_area = max(min(height[pt_left], height[pt_right])*(pt_right - pt_left), max_area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选取较小一侧的指针,往内移动一个单位</span></span><br><span class="line">            <span class="keyword">if</span> height[pt_left] &lt; height[pt_right]:</span><br><span class="line">                pt_left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指针汇合时, 循环结束</span></span><br><span class="line">            <span class="keyword">if</span> pt_left == pt_right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><hr><h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><ul><li><p>示例 1:<br>  输入: 3<br>  输出: “III”</p></li><li><p>示例 2:<br>  输入: 4<br>  输出: “IV”</p></li><li><p>示例 3:<br>  输入: 9<br>  输出: “IX”</p></li><li><p>示例 4:<br>  输入: 58<br>  输出: “LVIII”<br>  解释: L = 50, V = 5, III = 3.</p></li><li><p>示例 5:<br>  输入: 1994<br>  输出: “MCMXCIV”<br>  解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        lut = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'I'</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">            <span class="number">1000</span>: <span class="string">'M'</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 将输入num除以lut的从大到小的key,进行取模. 模变成被除数继续迭代.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(lut.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            n, mod = divmod(num, i) </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += lut[i] * n</span><br><span class="line">                num = mod</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><p>示例 2:</p><pre><code>输入: &quot;IV&quot;输出: 4</code></pre><p>示例 3:</p><pre><code>输入: &quot;IX&quot;输出: 9</code></pre><p>示例 4:</p><pre><code>输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p>示例 5:</p><pre><code>输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        lut = &#123;<span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">               <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">               <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">               <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">               <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">               <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">               <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">               <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">               <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">               <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">               <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先判断当前输入的前两个字符是否是罗马数字,</span></span><br><span class="line">        <span class="comment"># if 是: 加</span></span><br><span class="line">        <span class="comment"># else: 将单个字符转化成数字, 加</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i:i+<span class="number">2</span>] <span class="keyword">in</span> &#123;<span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>&#125;:</span><br><span class="line">                res += lut[s[i:i+<span class="number">2</span>]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += lut[s[i]]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: <code>&quot;fl&quot;</code><br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: <code>&quot;&quot;</code><br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""获得 list of string 的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            strs (list): a list of string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: 公共自创</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        commom = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            commom = self.getCommonPrefix(commom, strs[i])</span><br><span class="line">            <span class="keyword">if</span> commom == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commom</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCommonPrefix</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""返回str1和str2的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            str1 (string): 第一个字符串</span></span><br><span class="line"><span class="string">            str2 (string): 第二个字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 公共字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; min(len(str1), len(str2)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] == str2[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str1[:i]</span><br></pre></td></tr></table></figure></h2><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1],[-1, -1, 2]]</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">""" 返回一组数中之和为0的三个数(list of lists).</span></span><br><span class="line"><span class="string">        解法: 排序 + 使用双指针</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (list): a list of nums</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            list: 每个元素都是3个数且3个数之和为0</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 如果不够3个元素, 则返回空</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums = sorted(nums)  <span class="comment"># [-4, -1, -1, 0, 1, 2, ]</span></span><br><span class="line">        <span class="comment"># 确定第一个元素, 第一层遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果所有元素都大于等于0, 则返回</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># !!! 去重方法: 排好序后,相等则跳过...</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 确定双指针, 一个最左(i+1), 一个最右[-1]</span></span><br><span class="line">            pt_left = i + <span class="number">1</span></span><br><span class="line">            pt_right = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 三数之和等于0, 添加至res列表, 左右指针都到下一个位置</span></span><br><span class="line">            <span class="comment"># 如果 三数之和大于0, 右指针往左一个单位, 整体变小</span></span><br><span class="line">            <span class="comment"># 如果 三数之和小于0, 左指针往右一个单位, 整体变大</span></span><br><span class="line">            <span class="keyword">while</span> pt_left &lt; pt_right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[pt_left] + nums[pt_right] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[pt_left], nums[pt_right]])</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[pt_left] + nums[pt_right] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><pre><code>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums)</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line"></span><br><span class="line">        min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 重复的则跳过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L = i + <span class="number">1</span></span><br><span class="line">            R = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                _sum = nums[i] + nums[L] + nums[R]</span><br><span class="line">                delta = _sum - target</span><br><span class="line">                <span class="comment"># 如果两数之差小于最小值,保存该sum为res</span></span><br><span class="line">                <span class="keyword">if</span> abs(delta) &lt; min_dist:</span><br><span class="line">                    res = _sum</span><br><span class="line">                    min_dist = abs(delta)</span><br><span class="line">                <span class="comment"># 三数之和大于target,</span></span><br><span class="line">                <span class="keyword">if</span> delta &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] == nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 三数之和小于target</span></span><br><span class="line">                <span class="keyword">elif</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> _sum</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例:</p><pre><code>输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].说明:</code></pre><p>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="comment"># digits = "324"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        hashmap = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                   <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                   <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                   <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                   <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                   <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                   <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                   <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        res = [<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(res, digit)</span>:</span></span><br><span class="line">            res_tmp = []</span><br><span class="line">            <span class="comment"># 两个for循环进行排列组合</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> hashmap[digit]:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">                    r += s</span><br><span class="line">                    res_tmp.append(r)</span><br><span class="line">            <span class="keyword">return</span> res_tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            res = util(res, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><pre><code>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[[-1,  0, 0, 1],[-2, -1, 1, 2],[-2,  0, 0, 2]]</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">""" 在list of nums中,获取能够使得和为target的四元组.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (List[int]): 一组数.</span></span><br><span class="line"><span class="string">            target (int): list of lists, int.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[List[int]]: 所有和为target的四元组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 特殊情况, nums中少于4个数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 1. 排序</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-3</span>):</span><br><span class="line">            <span class="comment"># 避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)<span class="number">-2</span>):</span><br><span class="line">                <span class="comment"># 避免重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 双指针: L-左指针, R-右指针</span></span><br><span class="line">                L = j + <span class="number">1</span></span><br><span class="line">                R = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="comment"># (左指针向右移,右指针向左移)当左指针超过右指针时,break.</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="comment"># 如果四数之和等于target,则添加</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和小于target,则左指针向右移动</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和大于target,则右指针向左移动</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></h2><h1 id="19-删除链表的倒数第n个节点"><a href="#19-删除链表的倒数第n个节点" class="headerlink" title="19. 删除链表的倒数第n个节点"></a>19. 删除链表的倒数第n个节点</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><blockquote><p>思路:<br>将所有结点放进一个数组中,直接将数组中倒数第n+1个结点的next指针指向倒数第n-1个结点.</p></blockquote><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="comment"># 链表长度</span></span><br><span class="line">        arr = []</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            arr.append(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr):</span><br><span class="line">            head = arr[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node_to_del = arr[-n]</span><br><span class="line">        arr[-n<span class="number">-1</span>].next = node_to_del.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></h2><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><pre><code>输入: &quot;()&quot;输出: true</code></pre><p>示例 2:</p><pre><code>输入: &quot;()[]{}&quot;输出: true</code></pre><p>示例 3:</p><pre><code>输入: &quot;(]&quot;输出: false</code></pre><p>示例 4:</p><pre><code>输入: &quot;([)]&quot;输出: false</code></pre><p>示例 5:</p><pre><code>输入: &quot;{[]}&quot;输出: true</code></pre><blockquote><p>思路:<br>栈</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        lut = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'['</span>: <span class="string">']'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果输入的是左侧符号,加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> lut:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果输入的是右侧符号:</span></span><br><span class="line">            <span class="comment"># 如果栈中非空, 判断该符号是否与栈中最后一个符号匹配</span></span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">and</span> c <span class="keyword">in</span> lut.values():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> c == lut[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;11~20&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/Coding/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1-10题</title>
    <link href="http://monteyang.cn/LeetCode-1-10%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-1-10%E9%A2%98.html</id>
    <published>2019-12-17T13:47:05.000Z</published>
    <updated>2020-02-16T16:04:53.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>1~10</code> 题</p></blockquote><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><ul><li><p>示例:</p><p>  给定 nums = [2, 7, 11, 15], target = 9</p><p>  因为 nums[0] + nums[1] = 2 + 7 = 9<br>  所以返回 [0, 1]</p></li></ul><a id="more"></a><blockquote><p>思路:<br>在哈希表中反向存储[元素数值-&gt;元素索引],遍历一次实现O(n).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># 哈希表,反过来存 num -&gt; idx, 有可能同一num对应多个idx, 所以 &#123;12: [idx1, idx2, ...]&#125;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[n] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[n].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num_1, idx_1 <span class="keyword">in</span> hashmap.items():</span><br><span class="line">            <span class="comment"># num_2 = target - num_1 , 在hashmap中</span></span><br><span class="line">            <span class="keyword">if</span> target - num_1 <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># num_1 与 num_2 数值相等时</span></span><br><span class="line">                <span class="keyword">if</span> (target - num_1 == num_1):</span><br><span class="line">                    <span class="comment"># [注意] 如果找到的 num_2 其实是 num_1 自己, 跳过...</span></span><br><span class="line">                    <span class="keyword">if</span> (len(hashmap[num_1]) == <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                    <span class="keyword">if</span> len(hashmap[target-num_1]) &gt;= <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> hashmap[target-num_1][<span class="number">0</span>], hashmap[target-num_1][<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> idx_1[<span class="number">0</span>], hashmap[target-num_1][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><ul><li>示例：<br>  输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>  输出：7 -&gt; 0 -&gt; 8<br>  原因：342 + 465 = 807</li></ul><blockquote><p>思路:<br>每一个位相加时,都要考虑进位.</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        HeadNode = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = HeadNode</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历2个链表的同时进行计算,存入result链表</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum_cur = x + y + carry</span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sum_cur &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                sum_cur %= <span class="number">10</span></span><br><span class="line">            cur.next = ListNode(sum_cur)</span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">and</span> l1.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">and</span> l2.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># l1,l2都遍历完, 但是最后有进位时</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            cur.next = ListNode(carry)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HeadNode.next</span><br></pre></td></tr></table></figure></h2><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>Given a string, find the length of the longest substring without repeating characters.</p><ul><li><p>Example 1:<br>  Input: “abcabcbb”<br>  Output: 3<br>  Explanation: The answer is “abc”, with the length of 3. </p></li><li><p>Example 2:<br>  Input: “bbbbb”<br>  Output: 1<br>  Explanation: The answer is “b”, with the length of 1.</p></li><li><p>Example 3:<br>  Input: “pwwkew”<br>  Output: 3<br>  Explanation: The answer is “wke”, with the length of 3. </p><pre><code>          Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre></li></ul><blockquote><p>思路:<br>滑动窗口法:判断新的元素是否存在于已有的窗口内部.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        window = []</span><br><span class="line">        cur_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> window:</span><br><span class="line">                window = window[window.index(s[i])+<span class="number">1</span>:]</span><br><span class="line">            window.append(s[i])</span><br><span class="line">            cur_length = len(window)</span><br><span class="line">            <span class="keyword">if</span> cur_length &gt; max_length:</span><br><span class="line">                max_length = cur_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure><hr><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><ul><li><p>Example 1:<br>  nums1 = [1, 3]<br>  nums2 = [2]<br>  The median is 2.0</p></li><li><p>Example 2:<br>  nums1 = [1, 2]<br>  nums2 = [3, 4]<br>  The median is (2 + 3)/2 = 2.5</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(m+n)</span></span><br><span class="line"><span class="comment"># TODO O(log(m+n))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        length = len(nums1) + len(nums2)</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1+nums2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        m_idx = int(length/<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m_idx):</span><br><span class="line">            <span class="keyword">if</span> p2 &gt; len(nums2)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> p1 &gt; len(nums1)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 = p2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            median = (nums[<span class="number">-1</span>] + nums[<span class="number">-2</span>])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = nums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median</span><br></pre></td></tr></table></figure><hr><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><ul><li><p>示例 1：<br>  输入: “babad”<br>  输出: “bab”<br>  注意: “aba” 也是一个有效答案。</p></li><li><p>示例 2：<br>  输入: “cbbd”<br>  输出: “bb”</p></li></ul><blockquote><p>思路:<br>在每个索引处,从中心展开,获取最长的回文串.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = <span class="string">" "</span>.join(s)</span><br><span class="line">        longest_pali = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cent_idx <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            pali = self.get_longest_pali(s, cent_idx)</span><br><span class="line">            <span class="keyword">if</span> len(pali) &gt; len(longest_pali):</span><br><span class="line">                longest_pali = pali</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_pali</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_longest_pali</span><span class="params">(self, s, cent_idx)</span>:</span></span><br><span class="line">        <span class="string">"""返回字符串s中以索引cent_idx为中心的最长回文子串"""</span></span><br><span class="line">        pali = s[cent_idx]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            left_idx = cent_idx - i</span><br><span class="line">            right_idx = cent_idx + i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 超出范围,跳出</span></span><br><span class="line">            <span class="keyword">if</span> left_idx &lt; <span class="number">0</span> <span class="keyword">or</span> right_idx &gt;= len(s):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[left_idx] == s[right_idx]:</span><br><span class="line">                pali = s[left_idx] + pali + s[right_idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pali = pali.replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pali</span><br></pre></td></tr></table></figure><hr><h1 id="6-z-字形变换"><a href="#6-z-字形变换" class="headerlink" title="6. z-字形变换"></a>6. z-字形变换</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><ul><li><p>示例 1:<br>  输入: s = “LEETCODEISHIRING”, numRows = 3<br>  输出: “LCIRETOESIIGEDHN”</p></li><li><p>示例 2:<br>  输入: s = “LEETCODEISHIRING”, numRows = 4<br>  输出: “LDREOEIIECIHNTSG”<br>  解释:</p><pre><code>  L     D     R  E   O E   I I  E C   I H   N  T     S     G</code></pre><blockquote><p>思路:<br>用一个 List[string], 第n个元素存储第n行的字符.</p></blockquote></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numRows &lt; <span class="number">2</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历字符串</span></span><br><span class="line">        <span class="comment"># res[0]: Z的第一行</span></span><br><span class="line">        <span class="comment"># res[1]: Z的第二行</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            res[i] += c</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: order_flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i == numRows - <span class="number">1</span>: order_flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> order_flag:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        res_str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">            res_str += r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_str</span><br></pre></td></tr></table></figure></h2><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><ul><li>示例 1:<br>  输入: 123<br>  输出: 321</li><li>示例 2:<br>  输入: -123<br>  输出: -321</li><li>示例 3:<br>  输入: 120<br>  输出: 21<br>  注意:</li></ul><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        x_orig = x</span><br><span class="line">        x = abs(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            temp = x % <span class="number">10</span></span><br><span class="line">            x = (x - temp)/<span class="number">10</span></span><br><span class="line">            res = res*<span class="number">10</span> + temp</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x_orig &lt; <span class="number">0</span>: res = -res</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> res &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><hr><h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><ul><li>示例 1:<br>  输入: “42”<br>  输出: 42</li><li>示例 2:<br>  输入: “   -42”<br>  输出: -42<br>  解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</li><li>示例 3:<br>  输入: “4193 with words”<br>  输出: 4193<br>  解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</li><li>示例 4:<br>  输入: “words and 987”<br>  输出: 0<br>  解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。</li><li>示例 5:<br>  输入: “-91283472332”<br>  输出: -2147483648<br>  解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        flag_find_first = <span class="literal">True</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            asc = ord(c)</span><br><span class="line">            <span class="comment"># 找第一个符号, </span></span><br><span class="line">            <span class="keyword">if</span> flag_find_first:</span><br><span class="line">                <span class="comment"># 空字符, 跳过</span></span><br><span class="line">                <span class="keyword">if</span> asc == <span class="number">32</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 负号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">45</span>:</span><br><span class="line">                    sign = <span class="number">-1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 正号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">43</span>:</span><br><span class="line">                    sign = <span class="number">1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 数字字符</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    res = asc<span class="number">-48</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 非上述字符</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 已有第一个符号(正号或符号或数字)的前提下, 接下来只能是数字符号, 如果不是则break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    res = int(res*<span class="number">10</span> + (asc<span class="number">-48</span>))</span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> res &gt; (<span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>):</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">-1</span> <span class="keyword">and</span> res &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * res</span><br></pre></td></tr></table></figure></h2><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>示例 1:<br>  输入: 121<br>  输出: true</li><li>示例 2:<br>  输入: -121<br>  输出: false<br>  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li><li>示例 3:<br>  输入: 10<br>  输出: false<br>  解释: 从右向左读, 为 01 。因此它不是一个回文数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = str(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[-i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符</li><li><p><code>*</code> 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖<strong>整个</strong>字符串<code>s</code>的，而不是部分字符串。</p></li><li><p>说明:<br><code>s</code> 可能为空，且只包含从 a-z 的小写字母。<br><code>p</code> 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></li></ul><ul><li><p>示例 1:<br>  输入: s = “aa”, p = “a”<br>  输出: false<br>  解释: “a” 无法匹配 “aa” 整个字符串。</p></li><li><p>示例 2:<br>  输入: s = “aa”, p = “a<em>“<br>  输出: true<br>  解释: 因为 `</em>` 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p></li><li><p>示例 3:<br>  输入: s = “ab”, p = “.<em>“<br>  输出: true<br>  解释: `.</em><code>表示可匹配零个或多个（</code>*<code>）任意字符（</code>.`）。</p></li><li><p>示例 4:<br>  输入: s = “aab”, p = “c*a*b”<br>  输出: true<br>  解释: 因为 <code>*</code> 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p></li><li><p>示例 5:<br>  输入: s = “mississippi”, p = “mis*is*p*.”<br>  输出: false</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># 递归基: 都为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字符相互匹配</span></span><br><span class="line">        first_match = bool(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 若之后存在*  212 1* </span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;1~10&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;  给定 nums = [2, 7, 11, 15], target = 9&lt;/p&gt;
&lt;p&gt;  因为 nums[0] + nums[1] = 2 + 7 = 9&lt;br&gt;  所以返回 [0, 1]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/Coding/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python-可迭代对象、迭代器、生成器</title>
    <link href="http://monteyang.cn/Python-Iterable%E5%92%8CIterator%E7%9A%84%E5%8C%BA%E5%88%86.html"/>
    <id>http://monteyang.cn/Python-Iterable%E5%92%8CIterator%E7%9A%84%E5%8C%BA%E5%88%86.html</id>
    <published>2019-12-16T13:43:51.000Z</published>
    <updated>2020-02-16T07:12:40.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可迭代-Iterable"><a href="#可迭代-Iterable" class="headerlink" title="可迭代 Iterable"></a>可迭代 Iterable</h1><p><strong>可以用 for 循环遍历的</strong>，或者说该类中有<code>__iter__()</code>方法的实现，都是可迭代的对象。包括：</p><ul><li><strong>集合数据类型</strong>，如 <code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等</li><li>生成器 generator，包括“<code>( i for i in range(10) )</code>”这种的生成器和带<code>yield</code>的 generator function</li></ul><hr><h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h1><p><strong>可以被 <code>next()</code> 函数调用并不断返回下一个值的对象</strong>称为迭代器，该类中有<code>__next__()</code>方法的实现，包括：</p><ul><li>减少内存空间</li><li>生成器 generator</li><li>但list、dict、str虽然是Iterable，却不是Iterator</li><li>可以使用<code>iter()</code>函数，把list、dict、str等Iterable变成Iterator</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h1><p>是迭代器的一种，函数中有 <code>yield</code>，可以让函数暂停执行。</p><p>生成器对象中的 <code>send()</code> 方法，可将参数传递给生成器中yield的返回值，继续进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; num:</span><br><span class="line">        ret = <span class="keyword">yield</span> a</span><br><span class="line">        current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj = fib(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ret = obj.send(<span class="string">"ok"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;可迭代-Iterable&quot;&gt;&lt;a href=&quot;#可迭代-Iterable&quot; class=&quot;headerlink&quot; title=&quot;可迭代 Iterable&quot;&gt;&lt;/a&gt;可迭代 Iterable&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;可以用 for 循环遍历的&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-Matplotlib总结</title>
    <link href="http://monteyang.cn/Python-Matplotlib%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/Python-Matplotlib%E6%80%BB%E7%BB%93.html</id>
    <published>2019-12-16T09:28:00.000Z</published>
    <updated>2020-02-16T16:02:41.864Z</updated>
    
    <content type="html"><![CDATA[<p>matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。<br><a id="more"></a></p><hr><h2 id="1-绘制图片"><a href="#1-绘制图片" class="headerlink" title="1. 绘制图片"></a>1. 绘制图片</h2><h3 id="1-1-设置图片大小、分辨率"><a href="#1-1-设置图片大小、分辨率" class="headerlink" title="1.1 设置图片大小、分辨率"></a>1.1 设置图片大小、分辨率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用的导入方式</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置图片大小, dpi是图片分辨率默认是100</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">2</span>, <span class="number">26</span>, <span class="number">2</span>)</span><br><span class="line">y = np.random.randn(<span class="number">12</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xticks(x)</span><br><span class="line"><span class="comment"># 调整x轴上的刻度，当刻度太密集时使用列表的步长（列表间隔）来解决，matplotlib会自动帮我们对应</span></span><br><span class="line"><span class="comment"># plt.xticks(x[::2])</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="1-2-调整轴上的刻度"><a href="#1-2-调整轴上的刻度" class="headerlink" title="1.2 调整轴上的刻度"></a>1.2 调整轴上的刻度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_ticks = [<span class="string">"第&#123;&#125;个"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.xticks(x, x_ticks, rotation=<span class="number">90</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>plt.xticks() 中的两组数据长度务必相同</p><h3 id="1-3-设置中文显示"><a href="#1-3-设置中文显示" class="headerlink" title="1.3 设置中文显示"></a>1.3 设置中文显示</h3><p>matplotlib默认不支持中文，通过matplotlib.rc可以修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line">front = &#123;<span class="string">"family"</span>: <span class="string">"Microsoft Yahei"</span>,</span><br><span class="line"><span class="string">"size"</span>: <span class="string">"10"</span>&#125;</span><br><span class="line">matplotlib.rc(<span class="string">"front"</span>, **font)</span><br></pre></td></tr></table></figure></p><h3 id="1-4-添加描述信息"><a href="#1-4-添加描述信息" class="headerlink" title="1.4 添加描述信息"></a>1.4 添加描述信息</h3><p>可添加坐标轴含义，图像标题等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">"x轴含义"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y轴含义"</span>)</span><br><span class="line">plt.title(<span class="string">"标题"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="1-5-保存图片"><a href="#1-5-保存图片" class="headerlink" title="1.5 保存图片"></a>1.5 保存图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">"./fig.png"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="2-常用统计图"><a href="#2-常用统计图" class="headerlink" title="2. 常用统计图"></a>2. 常用统计图</h2><h3 id="2-1-折线图"><a href="#2-1-折线图" class="headerlink" title="2.1 折线图"></a>2.1 <strong>折线图</strong></h3><blockquote><p>以折线表示统计量的增减变化。<br>特点：反映事物的变化情况。<br><img data-src="https://img-blog.csdnimg.cn/2019010513092169.png" alt="折线图"></p></blockquote><h3 id="2-2-直方图"><a href="#2-2-直方图" class="headerlink" title="2.2 直方图"></a>2.2 <strong>直方图</strong></h3><blockquote><p>由一系列高度不等的纵向条纹或线段表示<strong>数据分布的情况</strong>。  一般用横轴表示数据范围，纵轴表示分布情况。<br>特点：绘制 <strong>连续</strong> 的数据，展示一组或者多组数据的分布状况。<br><img data-src="https://img-blog.csdnimg.cn/20190105131003368.png" alt="在这里插入图片描述"></p></blockquote><h3 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 <strong>条形图</strong></h3><blockquote><p>排列<strong>在工作表的列或行中的数据可以绘制到条形图中</strong>。<br>特点：绘制 <strong>离散</strong> 的数据，能够看出各个标签对应的数据大小，比较数据之间的差别。<br><img data-src="https://img-blog.csdnimg.cn/20190105131158885.png" alt="在这里插入图片描述"></p></blockquote><h3 id="2-4-散点图"><a href="#2-4-散点图" class="headerlink" title="2.4 散点图"></a>2.4 <strong>散点图</strong></h3><blockquote><p>用两组数据构成多个坐标点，考察坐标点的分布,判断两变量 之间是否存在某种关联或总结坐标点的分布模式。<br>特点：判断变量之间是否存在数量关联趋势，显示数据的分布规律。<br><img data-src="https://img-blog.csdnimg.cn/20190105131546443.png" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制折线图，x为横坐标，y为纵坐标。</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 绘制直方图，x为需要被分组的量，bins为组数。</span></span><br><span class="line">plt.hist(x, bins)</span><br><span class="line"><span class="comment"># 绘制条形图，x为序列，height为序列的“高度”。</span></span><br><span class="line">plt.bar(x, height)</span><br><span class="line"><span class="comment"># 绘制散点图，(x,y)为点的坐标。</span></span><br><span class="line">plt.scatter(x, y)</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;matplotlib 是最流行的Python绘图库之一，能将数据进行可视化，直观地呈现数据。&lt;br&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Reinforcement Learning-基本概念</title>
    <link href="http://monteyang.cn/Reinforcement-Learning-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://monteyang.cn/Reinforcement-Learning-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</id>
    <published>2019-12-16T02:08:42.000Z</published>
    <updated>2020-02-18T03:27:16.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>强化学习是智能体（Agent）与环境（Environment）不断交互, 不断提高自己的决策能力的过程.</p><ul><li>面向智能体的学习——通过与环境进行交互<ul><li>所学习的<strong>样本</strong>来自于<strong>与环境的交互</strong>。而非像传统机器学习的样本是现有的。</li></ul></li><li>通过<strong>试错和优化</strong>进行学习——用试错后的<strong>奖励（或惩罚）</strong>来学习</li></ul><blockquote><p><strong>总体过程</strong>：环境（Environment）会给智能体（Agent）一个观测值（Observation）（<em>全观测时,状态state和observation等价）</em>, 智能体接收到环境给的观测值之后会做出一个动作（Action）, 这个动作给予一个奖励（Reward）, 以及给出一个新的观测值. 智能体根据环境给予的奖励值去更新自己的策略（Policy）.</p></blockquote><p>强化学习的<strong>目的</strong> <em>就是为了得到最优的策略</em>。</p><a id="more"></a><hr><h1 id="2-强化学习的组成"><a href="#2-强化学习的组成" class="headerlink" title="2. 强化学习的组成"></a>2. 强化学习的组成</h1><h2 id="整体结构：环境和智能体"><a href="#整体结构：环境和智能体" class="headerlink" title="整体结构：环境和智能体"></a>整体结构：环境和智能体</h2><p><img data-src="/images/RL-整体示意图.png" alt="环境和智能体"></p><p>每个时刻 $t$:</p><ul><li>智能体（Agent）<ul><li>智能体执行动作$A_t$，并在环境中得到观测 $O_t$和奖励 $R_t$</li></ul></li><li>环境（Environment）<ul><li>环境会对智能体的动作 $A_t$的做出反应，然后发送新的观测 $O_t+1$ 和奖励 $R_t+1$</li></ul></li></ul><blockquote><p>智能体是我们能控制的部分，环境是我们无法空指的部分。<br>在不同的问题中，智能体和环境所指代的对象不同。</p></blockquote><hr><h2 id="2-1-奖励-Reward"><a href="#2-1-奖励-Reward" class="headerlink" title="2.1 奖励 Reward"></a>2.1 奖励 Reward</h2><p>奖励$R_t$是强化学习的<strong>核心</strong>，强化学习的目标就是<strong>最大化期望累积奖励</strong></p><ul><li><strong>特点</strong><ul><li>是<strong>标量</strong>，能够比较大小</li><li>表明这个智能体在时刻 $t$ 做得有多好</li><li>奖励不一定需要正负都有，全正或全负都可以，只要满足<strong>相对大小</strong>即可</li></ul></li></ul><blockquote><p>如果一个问题不满足奖励假设，就不能用强化学习解决！</p></blockquote><ul><li><p><strong>奖励值</strong>和<strong>回报值（Return）</strong>的比较</p><p>  回报值 $G_t$ 又称<strong>累积折扣奖励</strong>（cumulative discounted reward）。step $t$ 时的 return 为</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + ...</script><p>  其中$\gamma$表示折扣因子，公式中重视每一步reward的程度随着时间衰减，是一个可调的超参数。</p><ul><li>$\gamma$ 越大，表示我们越关注长期奖励</li><li><p>$\gamma$ 越小，表示我们越关注短期奖励</p><p>智能体的任务就是去最大化累积奖励，即最大化整个过程的奖励.</p><p>因此，智能体的任务可以转化成<strong>最大化累积奖励的期望</strong>。</p></li></ul></li></ul><hr><h2 id="2-2-状态-State"><a href="#2-2-状态-State" class="headerlink" title="2.2 状态 State"></a>2.2 状态 State</h2><h3 id="历史（history）"><a href="#历史（history）" class="headerlink" title="历史（history）"></a>历史（history）</h3><ul><li><strong>历史</strong> 是一个观测、动作和奖励的序列。是智能体在时间 $t$ 以前的所有的交互变量。</li></ul><script type="math/tex; mode=display">H_t = (O_1, A_1, R_2, ..., O_{T-1}, A_{T-1}, R_T, O_T)</script><p>根据历史：</p><ul><li>智能体选择动作 $A_t$</li><li>环境产生新的观测 $O_{t+1}$ 和奖励 $R_{t+1}$</li></ul><p>本质上，状态是历史的一个函数：</p><script type="math/tex; mode=display">S_t = f(H_t)</script><blockquote><p>状态可以是<strong>全部历史</strong>或者<strong>部分历史</strong></p><ul><li>下棋时，棋盘当前的布局可以看做状态 $S_t = O_t$</li><li>打砖块游戏中，前几帧的观测可以看做状态 $S_{t} = O_{t-3}, O_{t-2}, O_{t-1}, O_t$</li></ul></blockquote><h3 id="环境状态-S-e-t"><a href="#环境状态-S-e-t" class="headerlink" title="环境状态 $S^e_t$"></a>环境状态 $S^e_t$</h3><p><img data-src="/images/RL-环境状态.png" alt="环境状态"></p><ul><li>所有能够影响环境产生观测/奖励的数据都被认为是环境状态的一部分</li><li>环境状态一般是智能体观察不到的</li><li>即使环境状态 $S^e_t$ 可见的，一般也包含了不相关的信息</li></ul><h3 id="智能体状态-S-a-t"><a href="#智能体状态-S-a-t" class="headerlink" title="智能体状态 $S^a_t$"></a><strong>智能体状态</strong> $S^a_t$</h3><p><img data-src="/images/RL-智能体状态.png" alt="智能体状态"></p><ul><li>所有能够影响智能体做出下一个动作的数据都被认为是智能体状态的一部分</li><li><strong>强化学习中使用的状态</strong></li><li>可能是历史的任何函数 $S_t = f(H_t)$</li></ul><blockquote><p>对于智能体来说，<strong>环境状态是未知的，智能体状态是已知的</strong><br>智能体通过智能体的状态来做出相应的动作<br>没有特殊说明的情况下，我们所说的状态均指智能体状态 $S_t = S^a_t$</p></blockquote><h3 id="全观测和部分观测"><a href="#全观测和部分观测" class="headerlink" title="全观测和部分观测"></a>全观测和部分观测</h3><ul><li>全观测：<ul><li>智能体能够<strong>观测到整个环境</strong>，即<strong>智能体状态等价于环境状态</strong></li><li>强化学习主要研究问题——马尔科夫决策过程</li></ul></li><li>部分观测：<ul><li>智能体<strong>不能完全观测</strong>到整个环境</li><li>建模为部分观测下的马尔科夫决策过程</li></ul></li></ul><hr><h2 id="2-3-动作-Action"><a href="#2-3-动作-Action" class="headerlink" title="2.3 动作 Action"></a>2.3 动作 Action</h2><ul><li>动作是智能体与环境交互的媒介</li><li>动作必须对环境起到<strong>一定的控制作用</strong></li><li>动作必须和奖励匹配</li></ul><hr><h1 id="3-智能体的组成"><a href="#3-智能体的组成" class="headerlink" title="3. 智能体的组成"></a>3. 智能体的组成</h1><p>智能体的组成主要包括：</p><ul><li>策略</li><li>值函数</li><li>模型</li></ul><h2 id="3-1-策略-Policy-pi"><a href="#3-1-策略-Policy-pi" class="headerlink" title="3.1 策略 Policy($\pi$)"></a>3.1 策略 Policy($\pi$)</h2><p>Policy是从状态到动作的映射, 用$\pi$表示, 它告诉智能体如何挑选下一步的action.</p><p>强化学习中有两类policy:</p><ol><li>Deterministic policy(确定性策略)</li></ol><p>在确定性策略中，输入一个状态，输出的是某一个<strong>确定的action</strong>.</p><ol><li>Stochastic policy(随机性策略)</li></ol><p>在随机性策略中，输入一个状态，输出的是<strong>每个action的概率分布</strong>.</p><hr><h2 id="3-2-值函数"><a href="#3-2-值函数" class="headerlink" title="3.2 值函数"></a>3.2 值函数</h2><ul><li>值函数是回报值的期望</li><li>值函数主要用于评价不同状态的好坏，指导动作的选择</li></ul><hr><h2 id="3-3-模型"><a href="#3-3-模型" class="headerlink" title="3.3 模型"></a>3.3 模型</h2><p>指智能体对环境的预测模型，分为两部分</p><ul><li>$\mathcal{P}$ 预测下一个状态是什么</li><li>$\mathcal{R}$ 预测下一个奖励是什么</li></ul><hr><h1 id="4-强化学习的分类"><a href="#4-强化学习的分类" class="headerlink" title="4. 强化学习的分类"></a>4. 强化学习的分类</h1><ul><li>按环境：<ul><li>全观测环境下的</li><li>部分观测环境下的</li></ul></li></ul><ul><li>按智能体成分：<ul><li>基于值函数：学习值函数</li><li>基于策略：学习策略</li><li>Actor Critic：同时学习值函数和策略</li></ul></li></ul><ul><li>按有无模型：<ul><li>无模型强化学习</li><li>基于模型的强化学习</li></ul></li></ul><ul><li>按使用的手段：<ul><li>传统强化学习</li><li>深度强化学习</li></ul></li></ul><hr><h1 id="5-学习（learning）和规划（planning）"><a href="#5-学习（learning）和规划（planning）" class="headerlink" title="5. 学习（learning）和规划（planning）"></a>5. 学习（learning）和规划（planning）</h1><p>解决<strong>序列决策问题</strong>有两个基本方法：</p><ul><li>强化学习<ul><li><strong>环境未知</strong></li><li>智能体与环境进行交互，不断改善策略</li></ul></li></ul><ul><li>规划<ul><li><strong>环境已知</strong></li><li>可以根据模型直接计算，不用交互</li></ul></li></ul><blockquote><p>环境模型不精确时，既利用环境进行规划，又与环境交互进行强化学习 —&gt; <strong>基于模型的强化学习</strong><br>当环境模型很精确时，可以直接用规划的方式求解</p></blockquote><hr><h1 id="6-探索（Exploration）和利用（Exploitation）"><a href="#6-探索（Exploration）和利用（Exploitation）" class="headerlink" title="6. 探索（Exploration）和利用（Exploitation）"></a>6. 探索（Exploration）和利用（Exploitation）</h1><ul><li>探索：<strong>发现环境中更多的信息</strong>；</li><li>利用：<strong>充分挖掘当前已知信息</strong>，来最大化回报值；</li></ul><p>两者trade-off，同等重要。</p><hr><h1 id="7-评价和优化"><a href="#7-评价和优化" class="headerlink" title="7. 评价和优化"></a>7. 评价和优化</h1><ul><li>评价：给定一个策略，评价该策略的好坏 —&gt; 求值函数</li><li>优化：改善策略 —&gt; 找到最优策略</li></ul><!-- ### 2.2. Episode一个Episode由一系列的observation, reward, action组成.$$(O_1, A_1, R_2, ..., O_{T-1}, A_{T-1}, R_T, O_T)$$从 initial observation 到 terminal observation.  --><!--### 2.5. 值函数Value Function1. 状态值函数(V函数)一个状态 state s 对应的状态值函数只关于状态:$$V_\pi(s)=E_\pi(G_t|S_t=s)$$对给定的s, V(s)是一个确定的值. 它表示, 从state s开始, 遵循策略$\pi$时的return的期望值.2. 状态动作值函数(Q函数)状态动作值函数关于状态和动作:$$Q_\pi(s,a)=E_\pi(G_t|S_t=s,A_t=a)$$它表示, 从state s开始, 遵循策略$\pi$采取动作a时的return的期望值.## 3. 强化学习与其他机器学习- 监督学习：**有即时标签**的学习（分类、回归问题）- 非监督学习：**无标签**的学习（聚类问题）- 强化学习：没有标签，只有奖励信号，**有延迟奖励**的学习问题。介于监督和非监督之间。  - 强化学习的数据是**有时间相关性**的，**不满足独立同分布（iid）**。而传统机器学习的数据是iid的。因此传统机器学习的分布式系统对于强化学习不可用。  - 智能体的动作可以影响之后的数据。 -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;强化学习是智能体（Agent）与环境（Environment）不断交互, 不断提高自己的决策能力的过程.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向智能体的学习——通过与环境进行交互&lt;ul&gt;
&lt;li&gt;所学习的&lt;strong&gt;样本&lt;/strong&gt;来自于&lt;strong&gt;与环境的交互&lt;/strong&gt;。而非像传统机器学习的样本是现有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;试错和优化&lt;/strong&gt;进行学习——用试错后的&lt;strong&gt;奖励（或惩罚）&lt;/strong&gt;来学习&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总体过程&lt;/strong&gt;：环境（Environment）会给智能体（Agent）一个观测值（Observation）（&lt;em&gt;全观测时,状态state和observation等价）&lt;/em&gt;, 智能体接收到环境给的观测值之后会做出一个动作（Action）, 这个动作给予一个奖励（Reward）, 以及给出一个新的观测值. 智能体根据环境给予的奖励值去更新自己的策略（Policy）.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;强化学习的&lt;strong&gt;目的&lt;/strong&gt; &lt;em&gt;就是为了得到最优的策略&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reinforcement Learning" scheme="http://monteyang.cn/categories/Reinforcement-Learning/"/>
    
    
      <category term="Reinforcement Learning" scheme="http://monteyang.cn/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Python-axis的理解</title>
    <link href="http://monteyang.cn/Python-axis%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>http://monteyang.cn/Python-axis%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2019-01-15T03:40:13.000Z</published>
    <updated>2020-02-16T07:11:06.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axis的本质是数组层级"><a href="#axis的本质是数组层级" class="headerlink" title="axis的本质是数组层级"></a>axis的本质是数组层级</h3><p>numpy中的ndarray本质上是一个多维数组，axis表示数组层级<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(arr)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(arr.shape) <span class="comment"># (3, 4)</span></span><br></pre></td></tr></table></figure></p><ul><li>axis=0，表示最外层的<code>[]</code>，相应的<code>arr.shape[0]</code>为 3，最外层数组有3个元素；</li><li>axis=1，表示次外层的<code>[]</code>，相应的<code>arr.shape[1]</code>为 4，这就表示，在最外层的3个数组元素中，每个数组元素中又有4个元素。<a id="more"></a></li></ul><h3 id="若函数中axis-i，则沿着第i个下标变化、其余下标都不变的方向进行操作"><a href="#若函数中axis-i，则沿着第i个下标变化、其余下标都不变的方向进行操作" class="headerlink" title="若函数中axis=i，则沿着第i个下标变化、其余下标都不变的方向进行操作"></a>若函数中axis=i，则沿着第i个下标变化、其余下标都不变的方向进行操作</h3><p>以元素下标的形式表示数组arr为：</p><script type="math/tex; mode=display">arr[0][0]\  arr[0][1]\  arr[0][2]\ arr[0][3]\\arr[1][0]\  arr[1][1]\  arr[1][2]\ arr[1][3]\\arr[2][0]\  arr[2][1]\  arr[2][2]\ arr[2][3]\\</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">print(arr)</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">       [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">       [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">In [<span class="number">16</span>]: arr.sum(axis=<span class="number">0</span>)  <span class="comment"># 表示沿着第0个索引变化，其它索引都不变的方向进行求和操作</span></span><br><span class="line"></span><br><span class="line">Out[<span class="number">16</span>]: array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相应的，在多维数组（dim=3,4,...)的情况中，也是如此</span></span><br></pre></td></tr></table></figure><p>由以上结论，我们可以得到二维数组中axis含义的巧记方法：</p><ul><li>二维数组中的巧记方法（<em>沿方向操作</em>）<ul><li>axis=0，第一个索引变变化，第二个索引不变，即<strong>沿纵向操作</strong>；</li><li>axis=1，第二个索引变变化，第一个索引不变，即<strong>沿横向操作</strong>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;axis的本质是数组层级&quot;&gt;&lt;a href=&quot;#axis的本质是数组层级&quot; class=&quot;headerlink&quot; title=&quot;axis的本质是数组层级&quot;&gt;&lt;/a&gt;axis的本质是数组层级&lt;/h3&gt;&lt;p&gt;numpy中的ndarray本质上是一个多维数组，axis表示数组层级&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr = np.array(np.arange(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;).reshape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(arr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;array([[ 0,  1,  2,  3],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       [ 4,  5,  6,  7],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       [ 8,  9, 10, 11]])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(arr.shape) &lt;span class=&quot;comment&quot;&gt;# (3, 4)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;axis=0，表示最外层的&lt;code&gt;[]&lt;/code&gt;，相应的&lt;code&gt;arr.shape[0]&lt;/code&gt;为 3，最外层数组有3个元素；&lt;/li&gt;
&lt;li&gt;axis=1，表示次外层的&lt;code&gt;[]&lt;/code&gt;，相应的&lt;code&gt;arr.shape[1]&lt;/code&gt;为 4，这就表示，在最外层的3个数组元素中，每个数组元素中又有4个元素。
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-numpy和list中的浅拷贝和深拷贝</title>
    <link href="http://monteyang.cn/Python-numpy%E5%92%8Clist%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.html"/>
    <id>http://monteyang.cn/Python-numpy%E5%92%8Clist%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</id>
    <published>2019-01-13T16:58:37.000Z</published>
    <updated>2020-02-16T07:11:44.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="numpy-中"><a href="#numpy-中" class="headerlink" title="numpy 中"></a>numpy 中</h2><ul><li><code>np.copy()</code> 方法是 <strong>深拷贝</strong>；</li><li>切片操作 是 <strong>浅拷贝</strong>；</li><li>直接赋值给另一个变量是 <strong>浅拷贝</strong>。<a id="more"></a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy深拷贝示例</span></span><br><span class="line">In [<span class="number">12</span>]: arr = np.zeros((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: arr</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">     [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"> [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: b = arr.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 更改b的值</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: arr <span class="comment"># arr不变，说明copy()方法是深拷贝</span></span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: b</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy浅拷贝示例</span></span><br><span class="line">In [<span class="number">33</span>]: b = arr <span class="comment"># 直接赋值给变量b</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: b</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: arr[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b = arr[:] <span class="comment"># 切片操作</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: b</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: arr[<span class="number">0</span>,<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: b</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><h2 id="对比：Python的list中"><a href="#对比：Python的list中" class="headerlink" title="对比：Python的list中"></a>对比：Python的<code>list</code>中</h2><ul><li>切片操作 是 <strong>深拷贝</strong></li><li>直接复制给另一个变量是 <strong>浅拷贝</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list 深拷贝示例</span></span><br><span class="line">In [<span class="number">7</span>]: a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: b = a[:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: b[<span class="number">0</span>] = <span class="number">0</span> <span class="comment"># 更改b的值</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: a <span class="comment"># a不变，说明列表中的切片操作是深拷贝</span></span><br><span class="line">Out[<span class="number">10</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># list 浅拷贝示例</span></span><br><span class="line">In [<span class="number">29</span>]: a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: b</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;numpy-中&quot;&gt;&lt;a href=&quot;#numpy-中&quot; class=&quot;headerlink&quot; title=&quot;numpy 中&quot;&gt;&lt;/a&gt;numpy 中&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;np.copy()&lt;/code&gt; 方法是 &lt;strong&gt;深拷贝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;切片操作 是 &lt;strong&gt;浅拷贝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;直接赋值给另一个变量是 &lt;strong&gt;浅拷贝&lt;/strong&gt;。
    
    </summary>
    
    
      <category term="Coding" scheme="http://monteyang.cn/categories/Coding/"/>
    
      <category term="Python" scheme="http://monteyang.cn/categories/Coding/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
</feed>
