<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monte&#39;s Blog</title>
  
  <subtitle>朝着咸鱼的反方向努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://monteyang.cn/"/>
  <updated>2020-04-24T16:44:42.416Z</updated>
  <id>http://monteyang.cn/</id>
  
  <author>
    <name>Monte Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>强化学习-8.深度强化学习-DQN</title>
    <link href="http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-8.%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-DQN.html"/>
    <id>http://monteyang.cn/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-8.%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-DQN.html</id>
    <published>2020-04-24T16:33:05.000Z</published>
    <updated>2020-04-24T16:44:42.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度强化学习简介"><a href="#深度强化学习简介" class="headerlink" title="深度强化学习简介"></a>深度强化学习简介</h1><p>简单说来，<code>深度学习 + 强化学习 = 深度强化学习</code>。即，使用深度神经网络作为强化学习中的函数近似器，近似强化学习中的值函数模型、策略函数模型。</p><a id="more"></a><hr><h1 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h1><p>DQN（Deep Q Network）算法源自论文《Human-level control through deep reinforcement learning》(Nature2015)，这篇论文的算法框架基于传统强化学习中的 Q-learning（强化学习时间差分方法中已讲述）。在这里回顾一下 Q-learning：</p><p>Q-learning 方法是 off-policy 的时间差分方法。伪代码如图所示</p><p><img data-src="../images/Q-learning.jpg" alt></p><p>Q-learning 中有两个重要的概念：</p><ul><li>off-policy</li><li>时间差分</li></ul><p><strong>off-policy</strong> 是指<strong>行为策略（产生数据的策略）和目标策略不是一个策略</strong>。在 Q-learning 伪代码中，行为策略是$\epsilon -$贪婪策略，而要目标策略是贪婪策略（每个状态取值函数最大的那个动作）。</p><p><strong>时间差分方法</strong>，是指用时间差分目标值来更新当前行为值函数。在 Q-learning伪代码中，时间差分目标值为 $r_t + \gamma \max_a Q(s_{t+1}, a)$。</p><p>Q-learning 是1989年 Watkins 提出来的，2015年nature论文所提出的 DQN 是在Q-learning的基础上修改得到的。</p><p>DQN 对 Q-learning 的修改主要体现在以下3点：</p><ul><li>用深度卷积神经网络近似值函数</li><li>用<strong>经验回放机制</strong>对强化学习的学习过程进行训练</li><li>设置<strong>目标值函数网络</strong>来稳定时间差分算法中的 TD 误差</li></ul><p>下面对以上3点详细展开：</p><h2 id="1-深度卷积神经网络近似值函数"><a href="#1-深度卷积神经网络近似值函数" class="headerlink" title="1. 深度卷积神经网络近似值函数"></a>1. 深度卷积神经网络近似值函数</h2><p>神经网络拟合函数的好处，在之前（强化学习-值函数近似中）已经讲述过，此处不再赘述。</p><h2 id="2-经验回放机制"><a href="#2-经验回放机制" class="headerlink" title="2. 经验回放机制"></a>2. 经验回放机制</h2><p>对神经网络进行训练时，存在的假设是独立同分布。而通过强化学习采集到的数据之间存在着关联性，利用这些时间相关性强的数据进行训练，神经网络当然不稳定。经验回放机制可以<strong>打破数据间的关联</strong>。</p><p>在强化学习过程中，智能体将数据存储到一个数据库中，然后利用均匀随机采样的方法从数据库中抽取数据，然后利用抽取的数据对神经网络进行训练。</p><p><img data-src="../images/DQN-经验回放.png" alt></p><h2 id="3-目标值函数网络"><a href="#3-目标值函数网络" class="headerlink" title="3. 目标值函数网络"></a>3. 目标值函数网络</h2><p>与表格型的Q-learning算法，如图1.1所不同的是，利用神经网络对值函数进行逼近时，值函数的更新步更新的是参数[公式]，更新方法是梯度下降法。因此图1.1中第6行值函数更新实际上变成了监督学习的一次更新过程，其梯度下降法为：</p><p><img data-src="https://www.zhihu.com/equation?tex=%5C%5B%0A%5Ctheta_%7Bt%2B1%7D%3D%5Ctheta_t%2B%5Calpha%5Cleft%5Br%2B%5Cgamma%5Cmax_%7Ba%27%7DQ%5Cleft%28s%27%2Ca%27%3B%5Ctheta%5Cright%29-Q%5Cleft%28s%2Ca%3B%5Ctheta%5Cright%29%5Cright%5D%5Cnabla+Q%5Cleft%28s%2Ca%3B%5Ctheta%5Cright%29%0A%5C%5D" alt></p><p>我们称计算TD目标时所用的网络为目标值函数网络。以往的神经网络逼近值函数时，计算TD目标的值函数所用的网络参数$\theta$，与梯度计算中要逼近的值函数用的网络参数相同，这样就容易使得数据间存在关联性，训练不稳定。为了解决这个问题，DeepMind提出：</p><ul><li>计算TD目标的网络表示为$\theta^-$</li><li>计算值函数逼近的网络表示为$\theta$</li><li>用于动作值函数逼近的网络每一步都更新，而用于计算TD目标的网络每个固定的步数更新一次</li></ul><h2 id="DQN-伪代码"><a href="#DQN-伪代码" class="headerlink" title="DQN 伪代码"></a>DQN 伪代码</h2><p><img data-src="../images/DQN伪代码.jpg" alt></p><p>算法流程：</p><ul><li>初始化<strong>经验回放池 D</strong>，可容纳 N 条数据</li><li>随机初始化值函数网络，权重$\theta$</li><li>初始化目标值函数网络 $\theta^- = \theta$（用来计算TD目标值）</li><li><code>for</code> 每个片段（episode）：<ul><li>初始化第一个状态 $s_1={x_1}$，预处理得到状态对应的特征输入 $\phi_1=\phi(s_1)$</li><li><code>for</code>  episode 中的每一步：<ul><li>通过 <strong>$\epsilon-$贪婪策略</strong> 选择动作 $a_t$</li><li>执行动作 $a_t$，获得奖励 $r_t$，新的图像 $x_{t+1}$</li><li>设置 $s_{t+1} = s_t, a_t, x_{t+1}$，预处理$\phi_{t+1}=\phi(s_{t+1})$</li><li>将转移作为样本$(\phi_t, a_t, r_t, \phi_{t+1})$ <strong>储存在经验池D</strong>中</li><li>从回放记忆D中随机批量采样转换样本数据（<strong>mini batch</strong>）。</li><li>利用<strong>目标值函数网络</strong>求 <strong>TD 目标值</strong>（target）</li><li>TD目标值和当前值函数作差为损失函数，进行梯度下降法，更新网络权重 $\theta$</li><li><strong>每隔 C 步，更新目标值函数网络</strong>的权重（用值函数网络的权重）</li></ul></li><li><code>end for</code></li></ul></li><li><code>end for</code></li></ul><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/26052182" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/26052182</a><br>《Human-level control through deep reinforcement learning》(Nature2015)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深度强化学习简介&quot;&gt;&lt;a href=&quot;#深度强化学习简介&quot; class=&quot;headerlink&quot; title=&quot;深度强化学习简介&quot;&gt;&lt;/a&gt;深度强化学习简介&lt;/h1&gt;&lt;p&gt;简单说来，&lt;code&gt;深度学习 + 强化学习 = 深度强化学习&lt;/code&gt;。即，使用深度神经网络作为强化学习中的函数近似器，近似强化学习中的值函数模型、策略函数模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（四）库</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%93.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%93.html</id>
    <published>2020-04-20T06:05:31.000Z</published>
    <updated>2020-04-24T16:34:02.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。</p><!-- > 首发于公众号【Python与算法之路】 --></blockquote><a id="more"></a><h2 id="按需选择-sort-或者-sorted"><a href="#按需选择-sort-或者-sorted" class="headerlink" title="按需选择 sort() 或者 sorted()"></a>按需选择 <code>sort()</code> 或者 <code>sorted()</code></h2><p>Python 中常用的排序函数有 <code>sort()</code> 和 <code>sorted()</code> </p><p>两者的函数形式分别如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable[, cmp[, key[, reverse]]])</span><br><span class="line">s.sort([cmp[, key[, reverse]]])</span><br></pre></td></tr></table></figure><p><code>sort()</code> 和 <code>sorted()</code> 有3个共同的参数：</p><ul><li><code>cmp</code> ：<strong>用户定义的任何比较函数</strong>，函数的参数为两个可比较的元素（来自 iterable 或者 list ），函数根据第一个参数与第二个参数的关系依次返回 -1、0 或者 +1（第一个参数小于第二个参数则返回负数）。该参数默认值为 <code>None</code>。</li><li><code>key</code> 是一个带参数的函数，<strong>用来为每个元素提取比较值</strong>，默认为 <code>None</code>（即直接比较每个元素）</li><li><code>reverse</code> 表示排序<strong>结果是否反转</strong></li></ul><p>两者对比：</p><ul><li><p><code>sorted()</code> 作用于<strong>任何可迭代的对象</strong>；而 <code>sort()</code> 一般作用于<strong>列表</strong>。</p></li><li><p><code>sorted()</code> 函数会<strong>返回一个排序后的列表，原有列表保持不变</strong>；而 <code>sort()</code> 函数会<strong>直接修改原有列表</strong>，函数返回为 <code>None</code>。实际应用过程中需要保留原有列表，使用 <code>sorted()</code> 函数较为合适，否则可以选择 <code>sort()</code> 函数，因为 <code>sort()</code> 函数不需要复制原有列表，消耗的内存较少，效率也较高。</p></li><li>无论是 <code>sort()</code> 还是 <code>sorted()</code> 函数，传入参数 <code>key</code> 比传入参数 <code>cmp</code> 效率要高。<code>cmp</code> 传入的函数在整个排序过程中会调用多次，函数开销较大；而 <code>key</code> 针对每个元素仅做一次处理，因此使用 key 比使用 <code>cmp</code> 效率要高。</li><li><code>sorted()</code> 功能非常强大，它可以<strong>对不同的数据结构进行排序</strong>，从而满足不同需求。</li></ul><p>例：</p><p><strong>对字典进行排序</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phone_book = &#123;<span class="string">"Linda"</span>: <span class="string">"7750"</span>, <span class="string">"Bob"</span>: <span class="string">"9345"</span>, <span class="string">"Carol"</span>: <span class="string">"5834"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_pb = sorted(phone_book.items(), key=itemgetter(<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sorted_pb)</span><br><span class="line">[(<span class="string">'Carol'</span>, <span class="string">'5834'</span>), (<span class="string">'Linda'</span>, <span class="string">'7750'</span>), (<span class="string">'Bob'</span>, <span class="string">'9345'</span>)]</span><br></pre></td></tr></table></figure><p><strong>多维 List 排序</strong>：实际情况下也会碰到需要对多个字段进行排序的情况，这在 DB 里面用 SQL 语句很容易做到，但使用多维列表联合 <code>sorted()</code> 函数也可以轻易达到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [[<span class="string">"Bob"</span>,<span class="number">95</span>,<span class="string">"A"</span>],[<span class="string">"Alan"</span>,<span class="number">86</span>,<span class="string">"C"</span>],[<span class="string">"Mandy"</span>,<span class="number">82.5</span>,<span class="string">"A"</span>],[<span class="string">"Rob"</span>,<span class="number">86</span>,<span class="string">"E"</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(game_result, key=operator.itemgetter(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">[[<span class="string">'Mandy'</span>, <span class="number">82.5</span>, <span class="string">'A'</span>], [<span class="string">'Bob'</span>, <span class="number">95</span>, <span class="string">'A'</span>], [<span class="string">'Alan'</span>, <span class="number">86</span>, <span class="string">'C'</span>], [<span class="string">'Rob'</span>, <span class="number">86</span>, <span class="string">'E'</span>]]</span><br></pre></td></tr></table></figure><p><strong>字典中混合 List 排序</strong>：字典中的 key 或者值为列表，对列表中的某一个位置的元素排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_dict = &#123;<span class="string">"Li"</span>:[<span class="string">"M"</span>,<span class="number">7</span>],<span class="string">"Zhang"</span>:[<span class="string">"E"</span>,<span class="number">2</span>],<span class="string">"Wang"</span>:[<span class="string">"P"</span>,<span class="number">3</span>],<span class="string">"Du"</span>:[<span class="string">"C"</span>,<span class="number">2</span>],<span class="string">"Ma"</span>:[<span class="string">"C"</span>,<span class="number">9</span>],<span class="string">"Zhe"</span>:[<span class="string">"H"</span>,<span class="number">7</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(my_dict.items(), key=<span class="keyword">lambda</span> item:operator.itemgetter(<span class="number">1</span>)(item[<span class="number">1</span>]))</span><br><span class="line">[(<span class="string">'Du'</span>, [<span class="string">'C'</span>, <span class="number">2</span>]), (<span class="string">'Zhang'</span>, [<span class="string">'E'</span>, <span class="number">2</span>]), (<span class="string">'Wang'</span>, [<span class="string">'P'</span>, <span class="number">3</span>]), (<span class="string">'Zhe'</span>, [<span class="string">'H'</span>, <span class="number">7</span>]), (<span class="string">'Li'</span>, [<span class="string">'M'</span>, <span class="number">7</span>]), (<span class="string">'Ma'</span>, [<span class="string">'C'</span>, <span class="number">9</span>])]</span><br></pre></td></tr></table></figure><p><strong>List 中混合字典排序</strong>：列表中的每一个元素为字典形式，针对字典的多个 key 值进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [&#123;<span class="string">"name"</span>:<span class="string">"Bob"</span>,<span class="string">"wins"</span>:<span class="number">10</span>,<span class="string">"losses"</span>:<span class="number">3</span>,<span class="string">"rating"</span>:<span class="number">75</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"David"</span>,<span class="string">"wins"</span>:<span class="number">3</span>,<span class="string">"losses"</span>:<span class="number">5</span>,<span class="string">"rating"</span>:<span class="number">57</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"Carol"</span>,<span class="string">"wins"</span>:<span class="number">4</span>,<span class="string">"losses"</span>:<span class="number">5</span>,<span class="string">"rating"</span>:<span class="number">57</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"Patty"</span>,<span class="string">"wins"</span>:<span class="number">9</span>,<span class="string">"losses"</span>:<span class="number">3</span>,<span class="string">"rating"</span>:<span class="number">71.48</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(game_result, key=operator.itemgetter(<span class="string">"rating"</span>,<span class="string">"name"</span>))</span><br><span class="line">[&#123;<span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'Carol'</span>, <span class="string">'rating'</span>: <span class="number">57</span>, <span class="string">'wins'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'David'</span>, <span class="string">'rating'</span>: <span class="number">57</span>, <span class="string">'wins'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Patty'</span>, <span class="string">'rating'</span>: <span class="number">71.48</span>, <span class="string">'wins'</span>: <span class="number">9</span>&#125;, &#123;<span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>, <span class="string">'rating'</span>: <span class="number">75</span>, <span class="string">'wins'</span>: <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="使用-copy-模块深拷贝对象"><a href="#使用-copy-模块深拷贝对象" class="headerlink" title="使用 copy 模块深拷贝对象"></a>使用 copy 模块深拷贝对象</h2><ul><li><strong>浅拷贝（shallow copy）</strong>：构造一个新的复合对象，并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式有多种，如工厂函数、切片操作、copy 模块中的 <code>copy</code> 操作等。</li><li><strong>深拷贝（deep copy）</strong>：也构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。深拷贝的实现需要依赖 copy 模块的 <code>deepcopy()</code> 操作。</li></ul><p><strong>浅拷贝并不能进行彻底的拷贝，当存在列表、字典等不可变对象的时候，它仅仅拷贝其引用地址</strong>。要解决上述问题需要用到深拷贝，深拷贝不仅拷贝引用也拷贝引用所指向的对象，因此<strong>深拷贝得到的对象和原对象是相互独立的。</strong></p><h2 id="使用-Counter-进行计数统计"><a href="#使用-Counter-进行计数统计" class="headerlink" title="使用 Counter 进行计数统计"></a>使用 Counter 进行计数统计</h2><p>计数统计就是统计某一项出现的次数。可以使用不同数据结构来进行实现：</p><ul><li>例如，使用 <code>defaultdict</code>实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">some_data = [<span class="string">"a"</span>, <span class="string">"2"</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"2"</span>, <span class="string">"b"</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">"a"</span>, <span class="number">5</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>]</span><br><span class="line">count_frq = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> some_data:</span><br><span class="line">    count_frq[item] += <span class="number">1</span></span><br><span class="line">print(count_frq)</span><br><span class="line"><span class="comment"># defaultdict(&lt;class 'int'&gt;, &#123;'a': 3, '2': 2, 2: 1, 4: 2, 5: 2, 'b': 1, 7: 1, 'd': 1, 'z': 1&#125;)</span></span><br></pre></td></tr></table></figure><p>但<strong>更优雅，更 Pythonic 的解决方法是使用 <code>collections.Counter</code></strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">some_data = [<span class="string">"a"</span>, <span class="string">"2"</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"2"</span>, <span class="string">"b"</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">"a"</span>, <span class="number">5</span>, <span class="string">"d"</span>, <span class="string">"z"</span>, <span class="string">"a"</span>]</span><br><span class="line">print(Counter(some_data))</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 3, '2': 2, 4: 2, 5: 2, 2: 1, 'b': 1, 7: 1, 'd': 1, 'z': 1&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="深入掌握-ConfigParser"><a href="#深入掌握-ConfigParser" class="headerlink" title="深入掌握 ConfigParser"></a>深入掌握 ConfigParser</h2><p>常见的配置文件格式有 XML 和 ini 等，其中在 MS Windows 系统上，ini 文件格式用得尤其多，甚至操作系统的 API 也都提供了相关的接口函数来支持它。类似 ini 的文件格式，在 Linux 等操作系统中也是极常用的，比如 pylint 的配置文件就是这个格式。Python 有个标准库来支持它，也就是 ConfigParser。</p><p>ConfigParser 的基本用法通过<a href="http://doc.codingdict.com/python_352/library/configparser.html" target="_blank" rel="external nofollow noopener noreferrer">手册</a>可以掌握，但仍然有几个知识点值得注意。首先就是 <code>getboolean()</code> 这个函数。<code>getboolean()</code> 根据一定的规则将配置项的值转换为布尔值，如以下的配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[section1]</span></span><br><span class="line"><span class="attr">option1</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>当调用 <code>getboolean(&quot;section1&quot;, &quot;option1&quot;)</code> 时，将返回 False。</p><p><strong><code>getboolean()</code> 的真值规则</strong>： 除了 0 以外，no、false 和 off 都会被转义为 False，而对应的 1、yes、true 和 on 则都被转义为 True，其他值都会导致抛出 <code>ValueError</code> 异常。</p><p>还需要注意的是配置项的查找规则。首先，在 ConfigParser 支持的配置文件格式里，有一个 <code>[DEFAULT]</code> 节，当读取的配置项不在指定的节里时，ConfigParser 将会到 <code>[DEFAULT]</code> 节中查找。<br>除此之外，还有一些机制导致项目对配置项的查找更复杂，这就是 class ConfigParser 构造函数中的 defaults 形参以及其 <code>get(section, option[, raw[, vars]])</code> 中的全名参数 <code>vars</code>。如果把这些机制全部用上，那么<strong>配置项值的查找规则</strong>：</p><ul><li>如果找不到节名，就抛出 NoSectionError</li><li>如果给定的配置项出现在 <code>get()</code> 方法的 <code>var</code> 参数中，则返回 <code>var</code> 参数中的值</li><li>如果在指定的节中含有给定的配置项，则返回其值</li><li>如果在 【DEFAULT】中有指定的配置项，则返回其值</li><li>如果在构造函数的 defaults 参数中有指定的配置项，则返回其值</li><li>抛出 NoOptionError</li></ul><h2 id="使用-argparse-处理命令行参数"><a href="#使用-argparse-处理命令行参数" class="headerlink" title="使用 argparse 处理命令行参数"></a>使用 argparse 处理命令行参数</h2><p>尽管应用程序通常能够通过配置文件在不修改代码的情况下改变行为，但提供灵活易用的命令行参数仍然非常有意义，比如：减轻用户的学习成本，通常命令行参数的用法只需要在应用程序名后面加 —help 参数就能获得，而配置文件的配置方法通常需要通读手册才能掌握。</p><p>关于命令行处理，现阶段<strong>最好用的</strong>参数处理标准库是 argparse。</p><ul><li><code>add_argument()</code> 方法用以增加一个参数声明。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><ul><li>除了支持常规的 int/float 等基本数值类型外，argparse 还<strong>支持文件类型</strong>，只要参数合法，程序就能够使用相应的文件描述符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"bar"</span>, type=argparse.FileType(<span class="string">"w"</span>))</span><br><span class="line">parser.parse_args([<span class="string">"out.txt"</span>])</span><br></pre></td></tr></table></figure><ul><li><strong>扩展类型</strong>也变得更加容易，任何可调用对象，比如函数，都可以作为 type 的实参。另外 choices 参数也支持更多的类型，比如：   <code>parser.add_argument(&quot;door&quot;, type=int, choices=range(1, 4))</code>。</li><li>此外，add_argument() 提供了对<strong>必填参数</strong>的支持，只要把 required 参数设置为 True 传递进去，当缺失这一参数时，argparse 就会自动退出程序，并提示用户。</li><li>还支持<strong>参数分组</strong>。add_argument_group() 可以在输出帮助信息时更加清晰，这在用法复杂的 CLI 应用程序中非常有帮助：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">"PROG"</span>, add_help=<span class="literal">False</span>)</span><br><span class="line">group1 = parser.add_argument_group(<span class="string">"group1"</span>, <span class="string">"group1 description"</span>)</span><br><span class="line">group1.add_argument(<span class="string">"foo"</span>, help=<span class="string">"foo help"</span>)</span><br><span class="line">group2 = parser.add_argument_group(<span class="string">"group2"</span>, <span class="string">"group2 description"</span>)</span><br><span class="line">group2.add_argument(<span class="string">"--bar"</span>, help=<span class="string">"bar help"</span>)</span><br><span class="line">parser.print_help()</span><br></pre></td></tr></table></figure><ul><li>另外还有 <code>add_mutually_exclusive_group(required=False)</code> 非常实用：它确保组中的<strong>参数至少有一个或者只有一个</strong>（required=True）。</li><li>argparse 也支持<strong>子命令</strong>，比如 <code>pip</code> 就有 <code>install/uninstall/freeze/list/show</code> 等子命令，这些子命令又接受不同的参数，使用 ArgumentParser.add_subparsers() 就可以实现类似的功能。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">"PROG"</span>)</span><br><span class="line">subparsers = parser.add_subparsers(help=<span class="string">"sub-command help"</span>)</span><br><span class="line">parser_a = subparsers.add_parser(<span class="string">"a"</span>, help=<span class="string">"a help"</span>)</span><br><span class="line">parser_a.add_argument(<span class="string">"--bar"</span>, type=int, help=<span class="string">"bar help"</span>)</span><br><span class="line">parser.parse_args([<span class="string">"a"</span>, <span class="string">"--bar"</span>, <span class="string">"1"</span>])</span><br></pre></td></tr></table></figure><ul><li>除了参数处理之外，当出现<strong>非法参数</strong>时，用户还需要做一些处理，处理完成后，一般是输出提示信息并退出应用程序。ArgumentParser 提供了两个方法函数，分别是 <code>exit(status=0, message=None)</code> 和 <code>error(message)</code>，可以省了 <code>import sys</code> 再调用 <code>sys.exit()</code> 的步骤。</li></ul><h2 id="理解模块-pickle-优劣"><a href="#理解模块-pickle-优劣" class="headerlink" title="理解模块 pickle 优劣"></a>理解模块 pickle 优劣</h2><p>序列化，简单地说就是把内存中的数据结构在不丢失其身份和类型信息的情况下转换成对象的文本或二进制表示的过程。对象序列化后的形式经过反序列化过程应该能恢复原有对象。</p><p>Python 中有很多支持序列化的模块，如 pickle、json、marshal 和 shelve 等。</p><p><strong>pickle 是最通用的序列化模块</strong>，它还有个 C 语言的实现 cPickle，相比 pickle 来说具有较好的性能，其速度大概是 pickle 的 1000 倍，因此在大多数应用程序中应该优先使用 cPickle（注：cPickle 除了不能被继承之外，它们两者的使用基本上区别不大）。pickle 中最主要的两个函数对为 <code>dump()</code> 和 <code>load()</code>，分别用来进行对象的序列化和反序列化。</p><p>pickle 良好的特性总结为以下几点：</p><ul><li><strong>接口简单，容易使用</strong>。使用 <code>dump()</code> 和 <code>load()</code> 便可轻易实现序列化和反序列化。</li><li><strong>pickle 的存储格式具有通用性，能够被不同平台的 Python 解析器共享</strong>。比如 Linux 下序列化的格式文件可以在 Windows 平台的 Python 解析器上进行反序列化，兼容性较好。</li><li><strong>支持的数据类型广泛</strong>。如数字、布尔值、字符串，只包含可序列化对象的元组、字典、列表等，非嵌套的函数、类以及通过类的 <code>__dict__</code> 或者 <code>__getstate__()</code> 可以返回序列化对象的实例等。</li><li><p>pickle 模块是<strong>可以扩展</strong>的。对于实例对象，pickle 在还原对象的时候一般是不调用 <code>__init__()</code> 函数的，如果要调用 <code>__init__()</code> 进行初始化，对于古典类可以在类定义中提供 <code>__getinitargs__()</code> 函数，并返回一个元组，当进行 unpickle 的时候，Python 就会自动调用 <code>__init__()</code>，并把 <code>__getinitargs__()</code> 中返回的元组作为参数传递给 <code>__init__()</code>，而对于新式类，可以提供 <code>__getnewargs__()</code> 来提供对象生成时候的参数，在 unpickle 的时候以 <code>Class.__new__(Class, *arg)</code> 的方式创建对象。对于不可序列化的对象，如 sockets、文件句柄、数据库连接等，也可以通过实现 pickle 协议来解决这些巨献，主要是通过特殊方法 <code>__getstate__()</code> 和 <code>__setstate__()</code> 来返回实例在被 pickle 时的状态。</p><p>  示例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextReader</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = filename    <span class="comment"># 文件名称</span></span><br><span class="line">        self.file = open(filename)    <span class="comment"># 打开文件的句柄</span></span><br><span class="line">        self.postion = self.file.tell()    <span class="comment"># 文件的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        line = self.file.readline()</span><br><span class="line">        self.postion = self.file.tell()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> line.endswith(<span class="string">"\n"</span>):</span><br><span class="line">            line = line[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;: &#123;&#125;"</span>.format(self.postion, line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span>    <span class="comment"># 记录文件被 pickle 时候的状态</span></span><br><span class="line">        state = self.__dict__.copy()    <span class="comment"># 获取被 pickle 时的字典信息</span></span><br><span class="line">        <span class="keyword">del</span> state[<span class="string">"file"</span>]</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span>    <span class="comment"># 设置反序列化后的状态</span></span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line">        file = open(self.filename)</span><br><span class="line">        self.file = file</span><br><span class="line"></span><br><span class="line">reader = TextReader(<span class="string">"zen.text"</span>)</span><br><span class="line">print(reader.readline())</span><br><span class="line">print(reader.readline())</span><br><span class="line">s = pickle.dumps(reader)    <span class="comment"># 在 dumps 的时候会默认调用 __getstate__</span></span><br><span class="line">new_reader = pickle.loads(s)    <span class="comment"># 在 loads 的时候会默认调用 __setstate__</span></span><br><span class="line">print(new_reader.readline())</span><br></pre></td></tr></table></figure></li><li><p>能够自动维护对象间的引用，如果一个对象上存在多个引用，pickle 后不会改变对象间的引用，并且能够自动处理循环和递归引用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a    <span class="comment"># b 引用对象 a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="string">"c"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pickle.dumps((a, b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, b1 = pickle.loads(p)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.append(<span class="string">"d"</span>)    <span class="comment"># 反序列化对 a1 对象的修改仍然会影响到 b1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br></pre></td></tr></table></figure><p>但 pickle 使用也存在以下一些限制：</p></li><li><strong>pickle 不能保证操作的原子性</strong>。pickle 并不是原子操作，也就是说在一个 pickle 调用中如果发生异常，可能部分数据已经被保存，另外如果对象处于深递归状态，那么可能超出 Python 的最大递归深度。递归深度可以通过 <code>sys.setrecursionlimit()</code> 进行扩展。</li><li><strong>pickle 存在安全性问题</strong>。Python 的文档清晰地表明它不提供安全性保证，因此对于一个从不可信的数据源接收到的数据不要轻易进行反序列化。由于 loads() 可以接收字符串作为参数，精心设计的字符串给入侵提供了一种可能。在 Python 解释器中输入代码 <code>pickle.loads(&quot;cos\nsystem\n(S&#39;dir\ntR.&quot;)</code>便可以查看当前目录下所有文件。可以将 dir 替换为其他更具破坏性的命令。如果要进一步提高安全性，用户可以通过继承类 pickle.Unpickler 并重写 <code>find_class()</code> 方法来实现。</li><li><strong>pickle 协议是 Python 特定的，不同语言之间的兼容性难以保障</strong>。用 Python 创建的 pickle 文件可能其他语言不能使用。</li></ul><h2 id="序列化的另一个不错的选择——JSON"><a href="#序列化的另一个不错的选择——JSON" class="headerlink" title="序列化的另一个不错的选择——JSON"></a>序列化的另一个不错的选择——JSON</h2><p>Python 的标准库 JSON 提供的最常用的方法与 pickle 类似，dump/dumps 用来序列化，load/loads 用来反序列化。需要注意 json 默认不支持非 ASCII-based 的编码，如 load 方法可能在处理中文字符时不能正常显示，则需要通过 encoding 参数指定对应的字符编码。在序列化方面，相比 pickle，JSON 具有以下优势：</p><ul><li>使用简单，<strong>支持多种数据类型</strong>。JSON 文档的构成非常简单，仅存在以下两大数据结构：<ul><li><strong>名称/值对的集合</strong>。在各种语言中，它被实现为一个对象、记录、结构、字典、散列表、键列表或关联数组。</li><li><strong>值的有序列表</strong>。在大多数语言中，它被实现为数组、向量、列表或序列。在 Python 中对应支持的数据类型包括字典、列表、字符串、整数、浮点数、True、False、None 等。JSON 中数据结构和 Python 中的转换并不是完全一一对应，存在一定的差异。</li></ul></li><li><strong>存储格式可读性更为友好，容易修改</strong>。相比于 pickle 来说，json 格式更加接近程序员的思维，阅读和修改上要容易得多。dumps() 函数提供了一个参数 indent 使生成的 json 文件可读性更好，0 意味着“每个值单独一行”；大于 0 的数字意味着“每个值单独一行并且使用这个数字的空格来缩进嵌套的数据结构”。但需要注意的是，这个参数是以文件大小变大为代价的。</li><li><strong>json 支持跨平台跨语言操作</strong>。如 Python 中生成的 json 文件可以轻易使用 JavaScript 解析，互操作性更强，而 pickle 格式的文件只能在 Python 语言中支持。此外 json 原生的 JavaScript 支持，客户端浏览器不需要为此使用额外的解释器，特别适用于 Web 应用提供快速、紧凑、方便地序列化操作。此外，相比于 pickle，json 的存储格式更为紧凑，所占空间更小。</li><li><strong>具有较强的扩展性</strong>。json 模块还提供了编码（JSONEncoder）和解码类（JSONDecoder）以便用户对其默认不支持的序列化类型进行扩展。</li></ul><p>Python 中标准模块 json 的性能比 pickle 与 cPickle 稍逊。如果对序列化性能要求非常高的场景，可以使用 cPickle 模块。</p><h2 id="使用-threading-模块编写多线程程序"><a href="#使用-threading-模块编写多线程程序" class="headerlink" title="使用 threading 模块编写多线程程序"></a>使用 threading 模块编写多线程程序</h2><p>GIL 的存在使得 Python 多线程编程暂时无法充分利用多处理器的优势，并不能提高运行速率，但在以下几种情况，如<strong>等待外部资源返回</strong>，或者<strong>为了提高用户体验而建立反应灵活的用户界面</strong>，或者<strong>多用户应用程序</strong>中，多线程仍然是一个比较好的解决方案。</p><p>Python 为多线程编程提供了两个非常简单明了的模块：thread 和 threading。</p><p>thread 模块提供了多线程底层支持模块，以低级原始的方式来处理和控制线程，使用起来较为复杂；而 threading 模块基于 thread 进行包装，将线程的操作对象化，在语言层面提供了丰富的特性。实际应用中，<strong>推荐优先使用 threading 模块而不是 thread 模块。</strong></p><ul><li><p>就线程的<strong>同步和互斥</strong>来说，threading 模块中不仅有 Lock 指令锁，RLock 可重入指令锁，还支持条件变量 Condition、信号量 Semaphore、BoundedSemaphore 以及 Event 事件等。</p></li><li><p><strong>threading 模块主线程和子线程交互友好</strong>，<code>join()</code> 方法能够阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的 timeout（可选参数）。利用该方法可以方便地控制主线程和子线程以及子线程之间的执行。</p></li></ul><p>实际上很多情况下我们可能希望主线程能够等待所有子线程都完成时才退出，这时使用 threading 模块守护线程，可以通过 setDaemon() 函数来设定线程的 daemon 属性。当 daemon 属性设置为 True 的时候表明主线程的退出可以不用等待子线程完成。默认情况下，daemon 标志为 False，所有的非守护线程结束后主线程才会结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(a, delay)</span>:</span></span><br><span class="line">    print(<span class="string">"I will calculate square of &#123;&#125; after delay for &#123;&#125;"</span>.format(a, delay))</span><br><span class="line">    time.sleep(delay)</span><br><span class="line">    print(<span class="string">"calculate begins..."</span>)</span><br><span class="line">    result = a * a</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=myfunc, args=(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">t2 = threading.Thread(target=myfunc, args=(<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">print(t1.isDaemon())</span><br><span class="line">print(t2.isDaemon())</span><br><span class="line">t2.setDaemon(<span class="literal">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><h2 id="使用-Queue-使多线程编程更安全"><a href="#使用-Queue-使多线程编程更安全" class="headerlink" title="使用 Queue 使多线程编程更安全"></a>使用 Queue 使多线程编程更安全</h2><p>多线程编程不是件容易的事情。线程间的同步和互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。</p><p>Python 中的 Queue 模块提供了 3 种队列：</p><ul><li><p><code>Queue.Queue(maxsize)</code>：<strong>先进先出</strong>，maxsize 为队列大小，其值为非正数的时候为无限循环队列</p></li><li><p><code>Queue.LifoQueue(maxsize)</code>：<strong>后进先出，相当于栈</strong></p></li><li><p><code>Queue.PriorityQueue(maxsize)</code>：<strong>优先级队列</strong></p></li></ul><p>这 3 种队列支持以下方法：</p><ul><li><code>Queue.qsize()</code>：返回队列大小。</li><li><code>Queue.empty()</code>：队列为空的时候返回 True，否则返回 False</li><li><code>Queue.full()</code>：当设定了队列大小的情况下，如果队列满则返回 True，否则返回 False。</li><li><code>Queue.put(item[, block[, timeout]])</code>：往队列中添加元素 item，block 设置为 False 的时候，如果队列满则抛出 Full 异常。如果 block 设置为 True，timeout 为 None 的时候则会一直等待直到有空位置，否则会根据 timeout 的设定超时后抛出 Full 异常。</li><li><code>Queue.put_nowait(item)</code>：等于 <code>put(item, False).block</code> 设置为 False 的时候，如果队列空则抛出 Empty 异常。如果 block 设置为 True、timeout 为 None 的时候则会一直等到有元素可用，否则会根据 timeout 的设定超时后抛出 Empty 异常。</li><li><code>Queue.get([block[, timeout]])</code>：从队列中删除元素并返回该元素的值</li><li><code>Queue.get_nowait()</code>：等价于 <code>get(False)</code></li><li><code>Queue.task_done()</code>：发送信号表明入列任务已经完成，经常在消费者线程中用到</li><li><code>Queue.join()</code>：阻塞直至队列中所有的元素处理完毕</li></ul><p>Queue 模块是<strong>线程安全</strong>的。需要注意的是， Queue 模块中的队列和 collections.deque 所表示的队列并不一样，前者主要用于不同线程之间的通信，它内部实现了线程的锁机制；而后者主要是数据结构上的概念。</p><p>多线程下载的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            url = self.queue.get()    <span class="comment"># 从队列中取出一个 url 元素</span></span><br><span class="line">            print(self.name + <span class="string">"begin download"</span> + url + <span class="string">"..."</span>)</span><br><span class="line">            self.download_file(url)    <span class="comment"># 进行文件下载</span></span><br><span class="line">            self.queue.task_done()    <span class="comment"># 下载完毕发送信号</span></span><br><span class="line">            print(self.name + <span class="string">" download completed!!!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(self, url)</span>:</span>    <span class="comment"># 下载文件</span></span><br><span class="line">        urlhandler = urllib2.urlopen(url)</span><br><span class="line">        fname = os.path.basename(url) + <span class="string">".html"</span>    <span class="comment"># 文件名称</span></span><br><span class="line">        <span class="keyword">with</span> open(fname, <span class="string">"wb"</span>) <span class="keyword">as</span> f:    <span class="comment"># 打开文件</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                chunk = urlhandler.read(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                f.write(chunk)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [<span class="string">"https://www.createspace.com/3611970"</span>,<span class="string">"http://wiki.python.org/moni.WebProgramming"</span>]</span><br><span class="line">    queue = Queue.Queue()</span><br><span class="line">    <span class="comment"># create a thread pool and give them a queue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = DownloadThread(queue)    <span class="comment"># 启动 5 个线程同时进行下载</span></span><br><span class="line">        t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        t.start()</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># give the queue some data</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        queue.put(url)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># wait for the queue to finish</span></span><br><span class="line">    queue.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;/p&gt;
&lt;!-- &gt; 首发于公众号【Python与算法之路】 --&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（三）基础语法</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2020-04-14T06:14:55.000Z</published>
    <updated>2020-04-19T00:09:41.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。<br><!-- > 首发于公众号【Python与算法之路】 --></p></blockquote><a id="more"></a><h2 id="关于导入模块"><a href="#关于导入模块" class="headerlink" title="关于导入模块"></a>关于导入模块</h2><p>Python的3种引入外部模块的方式：<code>import</code>语句、<code>from ... import ...</code> 和 <code>__import__</code>函数。其中前两种比较常见。</p><p>在使用 <code>import</code> 时，应注意：</p><ul><li><strong>优先使用 <code>import A</code> 或 <code>import A as a</code></strong></li><li><strong>有节制的使用 <code>from A import B</code></strong></li><li><strong>尽量避免使用 <code>from A import *</code></strong></li></ul><p>对于 <code>from a import ...</code>，如果无节制的使用，会带来的问题：</p><ul><li>命名空间的冲突</li><li>循环嵌套导入的问题（两个文件相互导入对方的变量或函数或类）</li></ul><h2 id="i-1-不等于-i"><a href="#i-1-不等于-i" class="headerlink" title="i += 1 不等于 ++i"></a><code>i += 1</code> 不等于 <code>++i</code></h2><p>Python 解释器会将 <code>++i</code> 解释为 <code>+(+i)</code>，其中 <code>+</code> 表示正数符号。对于 <code>--i</code> 也是类似。</p><p>因此，要明白 <code>++i</code> 在 Python 的语法层面上是合法的，但并不是通常意义上的自增操作。</p><h2 id="使用-with-自动关闭资源"><a href="#使用-with-自动关闭资源" class="headerlink" title="使用 with 自动关闭资源"></a>使用 <code>with</code> 自动关闭资源</h2><p>对文件操作完成后，应该立即关闭它们，因为打开的文件不仅会占用系统资源，而且可能影响其他程序或者进程的操作，甚至会导致用户期望与实际操作结果不一致。</p><p>Python 提供了 with 语句，语法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 表达式 [<span class="keyword">as</span> 目标]:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>with 语句支持嵌套，支持多个 with 子句，它们两者可以相互转换。<code>with expr1 as e1, expr2 as e2</code>与下面的嵌套形式等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expr1 <span class="keyword">as</span> e1:</span><br><span class="line">    <span class="keyword">with</span> expr2 <span class="keyword">as</span> e2:</span><br></pre></td></tr></table></figure><h2 id="使用-else-子句简化循环（异常处理）"><a href="#使用-else-子句简化循环（异常处理）" class="headerlink" title="使用 else 子句简化循环（异常处理）"></a>使用 <code>else</code> 子句简化循环（异常处理）</h2><p>在循环中， <code>else</code> 子句提供了隐含的对循环是否由 <code>break</code> 语句引发循环结束的判断。例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两段代码等价</span></span><br><span class="line"><span class="comment"># 借助了一个标志量 found 来判断循环结束是不是由 break 语句引起的。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            print(<span class="string">"&#123;&#125; is a prime number"</span>.format(i))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"&#123;&#125; is a prime number"</span>.format(i))</span><br></pre></td></tr></table></figure><p>当循环“自然”终结（循环条件为假）时 <code>else</code> 从句会被执行一次，而当循环是由 <code>break</code> 语句中断时，<code>else</code> 子句就不被执行。</p><p>与 <code>for</code> 语句相似，<code>while</code> 语句中的 <code>else</code> 子句的语意是一样的： <code>else</code> 块在循环正常结束和循环条件不成立时被执行。</p><h2 id="遵循异常处理的几点基本原则"><a href="#遵循异常处理的几点基本原则" class="headerlink" title="遵循异常处理的几点基本原则"></a>遵循异常处理的几点基本原则</h2><p>Python中常用的异常处理语法是<code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code>，它们可以有多种组合。语法形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this main action first</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name1 的异常时，进行处理</span></span><br><span class="line"><span class="keyword">except</span> &lt;name1&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name2 或 name3 中的某一个异常时</span></span><br><span class="line"><span class="keyword">except</span> (name2, name3):</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 try 中发生 name4 的异常时处理，并获取对应实例</span></span><br><span class="line"><span class="keyword">except</span> &lt;name4&gt; <span class="keyword">as</span> &lt;data&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他异常时，进行处理</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常时，执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无论有没有异常，都执行</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure><p>异常处理，通常需要遵循以下几点基本原则：</p><ul><li><strong>不推荐在 <code>try</code> 中放入过多的代码</strong>。在 try 中放入过多的代码带来的问题是如果程序中抛出异常，将会较难定位，给 debug 和修复带来不便，因此应尽量只在可能抛出异常的语句块前面放入 try 语句。</li><li>谨慎使用单独的 <code>except</code> 语句处理所有异常，<strong>最好能定位具体的异常</strong>。同样也不推荐使用 <code>except Exception</code> 或者 <code>except StandardError</code> 来捕获异常。如果必须使用，最好能够使用 <code>raise</code> 语句将异常抛出向上层传递。</li><li>注意异常捕获的顺序，在合适的层次处理异常。<ul><li>用户也可以继承自内建异常构建自己的异常类，从而在内建类的继承结构上进一步延伸。在这种情况下捕获异常的顺序显得非常重要。为了更精确地定位错误发生的原因，推荐的方法是将继承结构中子类异常在前面的 <code>except</code> 语句中抛出，而父类异常在后面的 <code>except</code> 语句抛出。这样做的原因是当 <code>try</code> 块中有异常发生的时候，解释器根据 <code>except</code> 声明的顺序进行匹配，在第一个匹配的地方便立即处理该异常。</li><li>异常捕获的顺序非常重要，同时异常应该在适当的位置被处理，一个原则就是<strong>如果异常能够在被捕获的位置被处理，那么应该及时处理，不能处理也应该以合适的方式向上层抛出。</strong>向上层传递的时候需要警惕异常被丢失的情况，可以使用不带参数的 raise 来传递。</li></ul></li><li>使用更为友好的异常信息，遵守异常参数的规范。通常来说有两类异常阅读者：使用软件的人和开发软件的人。</li></ul><h2 id="避免-finally-中可能发生的陷阱"><a href="#避免-finally-中可能发生的陷阱" class="headerlink" title="避免 finally 中可能发生的陷阱"></a>避免 finally 中可能发生的陷阱</h2><p>无论 <code>try</code> 语句中是否有异常抛出，<code>finally</code> 语句总会被执行。由于这个特性，<code>finally</code> 语句经常被用来做一些清理工作。<br>但使用 <code>finally</code> 时，也要特别小心一些陷阱。</p><ul><li>当 <code>try</code> 块中发生异常的时候，如果在 <code>except</code> 语句中找不到对应的异常处理，异常将会被临时保存起来，当 <code>finally</code> 执行完毕的时候，临时保存的异常将会再次被抛出，但如果 <code>finally</code> 语句中产生了新的异常或者执行了 <code>return</code> 或者 <code>break</code> 语句，那么临时保存的异常将会被丢失，从而导致异常屏蔽。</li><li>在实际应用程序开发过程中，并不推荐在 <code>finally</code> 中使用 <code>return</code> 语句进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。</li></ul><h2 id="深入理解-None，正确判断对象是否为空"><a href="#深入理解-None，正确判断对象是否为空" class="headerlink" title="深入理解 None，正确判断对象是否为空"></a>深入理解 None，正确判断对象是否为空</h2><p>Python 中以下数据会当作空来处理：</p><ul><li>常量 <code>None</code></li><li>常量 <code>False</code></li><li>任何形式的数值类型零，如 <code>0</code>、<code>0L</code>、<code>0.0</code>、<code>0j</code></li><li>空的序列，如 <code>&#39;&#39;</code>、<code>()</code>、<code>[]</code></li><li>空的字典，如 <code>{}</code></li><li>当用户定义的类中定义了 <code>__nonzero__()</code> 和 <code>__len__()</code> 方法，并且该方法返回整数 <code>0</code> 或 <code>False</code> 的时候。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list1 <span class="comment"># value is not empty</span></span><br><span class="line">    Do something</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># value is empty</span></span><br><span class="line">    Do some other thing</span><br></pre></td></tr></table></figure><ul><li>执行过程中会调用内部方法 <code>__nonzero__()</code> 来判断变量 <code>list1</code> 是否为空并返回其结果。</li></ul><blockquote><p>注： <code>__nonzero__()</code> 方法 —— 该内部方法用于对自身对象进行空值测试，返回 0/1 或 True/False。</p></blockquote><ul><li>如果一个对象没有定义该方法，Python 将获取 <code>__len__()</code> 方法调用的结果来进行判断。<code>__len__()</code> 返回值为 0 则表示为空。如果一个类中既没有定义 <code>__len__()</code> 方法也没有定义 <code>__nonzero__()</code> 方法，该类的实例用 if 判断的结果都为 True。</li></ul><h2 id="格式化字符串时尽量使用-format-方式而不是"><a href="#格式化字符串时尽量使用-format-方式而不是" class="headerlink" title="格式化字符串时尽量使用 .format 方式而不是 %"></a>格式化字符串时尽量使用 <code>.format</code> 方式而不是 <code>%</code></h2><p>推荐尽量使用 <code>format</code> 方式而不是 <code>%</code> 操作符来格式化字符串，理由：</p><ul><li><code>format</code> 方式在使用上较 <code>%</code> 操作符更为灵活。使用 <code>format</code> 方式时，参数的顺序与格式化的顺序不必完全相同</li><li><p><code>format</code> 方式可以方便的作为参数传递</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weather = [(<span class="string">"Monday"</span>, <span class="string">"rain"</span>), (<span class="string">"Tuesday"</span>, <span class="string">"sunny"</span>), (<span class="string">"Wednesday"</span>, <span class="string">"sunny"</span>), (<span class="string">"Thursday"</span>, <span class="string">"rain"</span>), (<span class="string">"Friday"</span>, <span class="string">"cloudy"</span>)]</span><br><span class="line">formatter = <span class="string">"Weather of '&#123;0[0]&#125;' is '&#123;0[1]&#125;'"</span>.format</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> map(formatter, weather):</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure></li><li><p><code>%</code> 最终会被 .format 方式所代替。根据 Python 的官方文档，之所以仍然保留 <code>%</code> 操作符是为了保持向后兼容</p></li><li><code>%</code> 方法在某些特殊情况下使用时需要特别小心，对于 <code>%</code> 直接格式化字符的这种形式，如果字符本身为元组，则需要使用在 <code>%</code> 使用 <code>(itemname,)</code> 这种形式才能避免错误，注意逗号。</li></ul><h2 id="区别对待可变对象和不可变对象"><a href="#区别对待可变对象和不可变对象" class="headerlink" title="区别对待可变对象和不可变对象"></a>区别对待可变对象和不可变对象</h2><p>Python 中一切皆对象，对象根据其值能否修改分为<strong>可变对象</strong>和<strong>不可变对象</strong>。</p><ul><li><p>不可变对象</p><ul><li>数字</li><li>字符串</li><li>元组</li></ul></li><li><p>可变对象</p><ul><li>字典</li><li>列表</li><li>字节数组</li></ul></li></ul><p>在将可变对象<strong>作为函数默认参数</strong>的时候要特别紧惕，<strong>对可变对象的更改会直接影响原对象。</strong></p><p>最好的方法是传入 <code>None</code> 作为默认参数，在创建对象的时候动态生成可变对象。</p><ul><li><p>对于一个可变对象，<strong>切片操作相当于浅拷贝。</strong></p></li><li><p>对于不可变对象，当我们对其进行相关操作的时候，Python 实际上<strong>仍然保持原来的值而且重新创建一个新的对象</strong>，所以字符串对象不允许以索引的方式进行赋值，当有两个对象同时指向一个字符串对象的时候，对其中一个对象的操作并不会影响另一个对象。</p></li></ul><h2 id="函数传参既不是传值也不是传引用"><a href="#函数传参既不是传值也不是传引用" class="headerlink" title="函数传参既不是传值也不是传引用"></a>函数传参既不是传值也不是传引用</h2><p>对于Python中函数的传参方法，<strong>既不是传值，也不是传引用</strong>。</p><p>正确的叫法应该是<strong>传对象</strong>（call by object）或者说<strong>传对象的引用</strong>（call-by-object-reference）。</p><p>函数参数在传递的过程中将整个对象传入，</p><ul><li>对于<strong>可变对象</strong>：它的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象</li><li>对于<strong>不可变对象</strong>：由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的</li></ul><h2 id="慎用变长参数"><a href="#慎用变长参数" class="headerlink" title="慎用变长参数"></a>慎用变长参数</h2><p>慎用可变长度参数<code>*args, **kwargs</code>，原因如下：</p><ul><li>使用过于灵活。变长参数意味着这个函数的签名不够清晰，存在多种调用方式。另外变长参数可能会破坏程序的健壮性。</li><li>如果一个函数的参数列表很长，虽然可以通过使用 <code>*args</code> 和 <code>**kwargs</code> 来简化函数的定义，但通常这个函数可以有更好的实现方式，应该被重构。例如可以直接传入元组和字典。</li></ul><p>可变长参数适合在下列情况下使用：</p><ul><li>为函数添加一个<strong>装饰器</strong></li><li>如果参数的数目不确定，可以考虑使用变长参数</li><li>用来实现函数的多态，或者在继承情况下子类需要调用父类的某些方法的时候</li></ul><h2 id="深入理解-str-和-repr-的区别"><a href="#深入理解-str-和-repr-的区别" class="headerlink" title="深入理解 str() 和 repr() 的区别"></a>深入理解 <code>str()</code> 和 <code>repr()</code> 的区别</h2><p>函数 <code>str()</code> 和 <code>repr()</code> 都可以将 Python 中的对象转换为字符串，两者的使用以及输出都非常相似。有以下几点区别：</p><ul><li><p>两者的目标不同：</p><ul><li><code>str()</code> 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型</li><li>而 <code>repr()</code> 面向开发人员，其目的是准确性，其返回值表示 Python 解释器内部的含义，常用作 debug</li></ul></li><li><p>在解释器中直接输入时默认调用 <code>repr()</code> 函数，而 <code>print</code> 则调用 <code>str()</code> 函数</p></li><li><code>repr()</code> 的返回值一般可以用 <code>eval()</code> 函数来还原对象。通常有如下等式：<code>obj == eval(repr(obj))</code></li><li>一般，类中都应该定义 <code>__repr__()</code> 方法，而 <code>__str__()</code> 方法则为可选，当可读性比准确性更为重要的时候应该考虑定义 <code>__str__()</code> 方法。如果类中没有定义 <code>__str__()</code> 方法，则默认会使用 <code>__repr__()</code> 方法的结果来返回对象的字符串表示形式。用户实现 <code>__repr__()</code> 方法的时，最好保证其返回值可以用 <code>eval()</code> 方法使对象重新还原。</li></ul><h2 id="分清静态方法和类方法的适用场景"><a href="#分清静态方法和类方法的适用场景" class="headerlink" title="分清静态方法和类方法的适用场景"></a>分清静态方法和类方法的适用场景</h2><p>静态方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg1, arg2, ...)</span>:</span></span><br></pre></td></tr></table></figure></p><p>类方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls, arg1, arg2, ...)</span>:</span></span><br></pre></td></tr></table></figure></p><p>都可以通过<code>类名.方法名</code>或者<code>实例.方法名</code>的形式来访问。</p><p>其中，静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数。</p><p><strong>类方法</strong></p><ul><li>在调用的时候没有显式声明 cls，但实际上类本身是作为隐藏参数传入的</li><li>类方法可以判断出自己是通过基类被调用，还是通过某个子类被调用</li><li>类方法通过子类调用时，可以返回子类的属性而非基类的属性</li><li>类方法通过子类调用时，可以调用子类的其他类方法</li></ul><p><strong>静态方法</strong></p><ul><li>既不跟特定的实例相关也不跟特定的类相关</li><li>静态方法定义在类中的原因是，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的可维护性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;br&gt;&lt;!-- &gt; 首发于公众号【Python与算法之路】 --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（二）编程惯用法</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E7%A8%8B%E6%83%AF%E7%94%A8%E6%B3%95.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E7%A8%8B%E6%83%AF%E7%94%A8%E6%B3%95.html</id>
    <published>2020-04-10T02:37:25.000Z</published>
    <updated>2020-04-11T13:05:39.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精炼汇总。</p></blockquote><a id="more"></a><h2 id="利用assert语句发现问题"><a href="#利用assert语句发现问题" class="headerlink" title="利用assert语句发现问题"></a>利用assert语句发现问题</h2><p>assert语句的基本语法如下：</p><p><code>assert expression1 [&quot;,&quot; expression2]</code></p><p>其中，<code>expression1</code>是判断语句，会返回True或False，当返回False时会引发AssertionError。<code>[]</code>中的内容表示是可选的，用来传递具体的异常信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> a == b, <span class="string">"a equals b"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: a equals b</span><br></pre></td></tr></table></figure><p>利用assert语句来发现程序中的问题。断言（assert）在很多语言中都存在，主要为调试程序服务，能够快速方便检查程序的异常或不恰当的输入。</p><p>要注意的是<strong>使用assert是有代价的，它会对性能产生一定的影响</strong>，可以不用尽量不用。</p><h2 id="两个变量进行数据交换"><a href="#两个变量进行数据交换" class="headerlink" title="两个变量进行数据交换"></a>两个变量进行数据交换</h2><p>变量进行数据交换值时，<strong>不推荐使用中间变量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交换x,y</span></span><br><span class="line"><span class="comment"># 使用中间变量</span></span><br><span class="line">temp = x</span><br><span class="line">x = y</span><br><span class="line">y = temp</span><br><span class="line"><span class="comment"># 不使用中间变量</span></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><p>第二种方法在内存中执行的顺序如下：</p><ul><li>先计算右边的表达式 y, x，在内存中创建元组（y, x），其标示符合值分别为 y、x 及其对应的值，其中 y 和 x 是在初始化时已经存在于内存中的对象。</li><li>通过解包操作（unpacking），元组第一标识符（为 y）分配给左边第一个元素（此时为 x），元组第二个标识符（为 x）分配给左边第二个元素（为 y），从而达到实现 x、y 值交换的目的。</li></ul><h2 id="充分利用Lazy-evaluation的特性"><a href="#充分利用Lazy-evaluation的特性" class="headerlink" title="充分利用Lazy evaluation的特性"></a>充分利用Lazy evaluation的特性</h2><p>Lazy evaluation 常被译为“延迟计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。</p><ul><li><strong>避免不必要的计算，带来性能上的提升</strong>。对于 Python 中的条件表达式 if x and y，在 x 为 false 的情况下 y 表达式的值将不再计算。而对于 if x or y，当 x 的值为 true 的时候将直接返回，不再计算 y 的值。</li><li>节省空间，使得无限循环的数据结构成为可能。Python 中最典型的使用延迟计算的例子就是<strong>生成器表达式</strong>了。比如斐波那契：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">print(list(islice(fib(), <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><h2 id="不推荐使用type来进行类型检查"><a href="#不推荐使用type来进行类型检查" class="headerlink" title="不推荐使用type来进行类型检查"></a>不推荐使用type来进行类型检查</h2><p>内建函数 type(object) 用于返回当前对象的类型。可以通过与 Python 自带模块 types 中所定义的名称进行比较，根据其返回值确定变量类型是否符合要求。</p><p>所有<strong>基本类型</strong>对应的名称都可以在 types 模块中找到，然而<strong>使用 type() 函数并不适合用来进行变量类型检查</strong>。这是因为：</p><ul><li>基于内建类型扩展的用户自定义类型，type 函数并不能准确返回结果</li><li>在古典类中，所有类的实例的 type 值都相等</li></ul><p>解决方法是，如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，否则<strong>可以使用 isinstance() 函数来检测</strong>。</p><p><code>isinstance(object, classinfo)</code></p><p>其中，classinfo 可以为直接或间接类名、基本类型名称或者由它们组成的元组，该函数在 classinfo 参数错误的情况下会抛出 TypeError 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># isinstance 基本用法举例如下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">2</span>, float)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"a"</span>, (str, unicode))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">2</span>, <span class="number">3</span>), (str, list, tuple)) <span class="comment"># 支持多种类型列表</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="警惕eval-的安全漏洞"><a href="#警惕eval-的安全漏洞" class="headerlink" title="警惕eval()的安全漏洞"></a>警惕eval()的安全漏洞</h2><p>Python中<code>eval()</code>函数将字符串当成有效的表达式来求值并返回计算结果。其函数声明如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><br>其中，参数 globals 为字典形式，locals 为任何映射对象，它们分别表示全局和局部命名空间。如果传入 globals 参数的字典中缺少 <strong>builtins</strong> 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。locals 参数默认与 globals 相同，如果两者都省略的话，表达式将在 eval() 调用的环境中执行。</p><p>eval 存在安全漏洞，一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExpCalcBot</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Your answer is"</span>, eval(user_func) <span class="comment"># 计算输入的值</span></span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The expression you enter is not valid"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hi, I am ExpCalcBot. please input your expression or enter e to end'</span></span><br><span class="line">inputstr = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Please enter a number or operation. Enter c to complete. :'</span></span><br><span class="line">    inputstr = raw_input()</span><br><span class="line">    <span class="keyword">if</span> inputstr == str(<span class="string">'e'</span>): <span class="comment"># 遇到输入为 e 的时候退出</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">elif</span> repr(inputstr) != repr(<span class="string">''</span>):</span><br><span class="line">        ExpCalcBot(inputstr)</span><br><span class="line">        inputstr = <span class="string">''</span></span><br></pre></td></tr></table></figure><p>由于网络环境下运行它的用户并非都是可信任的，比如输入 <code>__import__(&quot;os&quot;).system(&quot;dir&quot;)</code>，会显示当前目录下的所有文件列表；<strong>如果恶意输入<code>__import__(&quot;os&quot;).system(&quot;del * /Q&quot;)</code>，会导致当前目录下的所有文件都被删除了，而这一切没有任何提示。</strong></p><p>在 globals 参数中禁止全局命名空间的访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExpCalcBot</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        math_fun_list = [<span class="string">"acos"</span>, <span class="string">"asin"</span>, <span class="string">"atan"</span>, <span class="string">"cos"</span>, <span class="string">"e"</span>, <span class="string">"log"</span>, <span class="string">"log10"</span>, <span class="string">"pi"</span>, <span class="string">"pow"</span>, <span class="string">"sin"</span>, <span class="string">"sqrt"</span>, <span class="string">"tan"</span>]</span><br><span class="line">        math_fun_dict = dict([(k, globals().get(k)) <span class="keyword">for</span> k <span class="keyword">in</span> math_fun_list]) <span class="comment"># 形成可以访问的函数的字典</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Your name is"</span>, eval(string, &#123;<span class="string">"__builtins__"</span>: <span class="literal">None</span>&#125;, math_fun_dict)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The expression you enter is not valid"</span></span><br></pre></td></tr></table></figure></p><p>再次进行恶意输入：<code>[c for c in ().__class__.__bases__[0].__subclasses__() if c.__name__ == &quot;Quitter&quot;][0](0)()</code>，</p><p><code># ().__class__.__bases__[0].__subclasses__()</code> 用来显示 object 类的所有子类。类 Quitter 与 “quit” 功能绑定，因此上面的输入会导致程序退出。</p><p><strong>对于有经验的侵入者来说，他可能会有一系列强大的手段，使得 eval 可以解释和调用这些方法，带来更大的破坏</strong>。此外，eval() 函数也给程序的调试带来一定困难，要查看 eval() 里面表达式具体的执行过程很难。因此在实际应用过程中如果使用对象不是信任源，<strong>应该避免使用 eval，在需要使用 eval 的地方可用安全性更好的<code>ast.literal_eval</code>替代。</strong></p><h2 id="使用enumerate-获取序列迭代的索引和值"><a href="#使用enumerate-获取序列迭代的索引和值" class="headerlink" title="使用enumerate()获取序列迭代的索引和值"></a>使用enumerate()获取序列迭代的索引和值</h2><p>使用函数 enumerate()，主要是为了解决在循环中获取索引以及对应值的问题。它具有一定的惰性（lazy），每次只在需要的时候才会产生一个（index, item）对。函数签名如下：</p><p><code>enumerate(sequence, start=0)</code></p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 enumerate() 获取序列迭代的索引和值</span></span><br><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(li):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, e)</span><br></pre></td></tr></table></figure></p><h2 id="区分-与is的适用场景"><a href="#区分-与is的适用场景" class="headerlink" title="区分==与is的适用场景"></a>区分==与is的适用场景</h2><ul><li><p><code>==</code>：用来检验两个对象的<strong>值</strong>是否相等的。它实际调用内部 <code>__eq__()</code> 方法，因此 <code>a == b</code> 相当于 <code>a.__eq__(b)</code>。</p></li><li><p><code>is</code>：用来<strong>比较两个对象在内存中是否拥有同一块内存空间</strong>。仅当 x 和 y 是同一个对象的时候才返回 True，<code>x is b</code> 基本相当于 <code>id(x) == id(y)</code>。</p></li></ul><p><code>==</code> 操作符也是可以被重载的，而 <code>is</code> 不能被重载。一般情况下，如果 <code>x is y</code> 为 True ， <code>x == y</code> 的值一般也为 True（特殊情况除外，如 <code>NaN</code>，<code>a = float(&#39;NaN&#39;)</code>，<code>a is a</code> 为 True，<code>a == a</code> 为 false）。</p><h2 id="构建合理的包层次来管理模块"><a href="#构建合理的包层次来管理模块" class="headerlink" title="构建合理的包层次来管理模块"></a>构建合理的包层次来管理模块</h2><p>每一个 Python 文件都可以看成一个模块（module），使用模块可以增强代码的可维护性和可重用性。</p><p><strong>包即是目录</strong>，但与普通目录不同，它除了包含常规的 Python 文件（也就是模块）以外，还<strong>包含一个 <code>__init__.py</code> 文件，同时它允许嵌套</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Package/<span class="module-access"><span class="module"><span class="identifier">__init__</span>.</span></span>py</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Module1</span>.</span></span>py</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Module2</span>.</span></span>py</span><br><span class="line">    Subpackage/<span class="module-access"><span class="module"><span class="identifier">__init__</span>.</span></span>py</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Module1</span>.</span></span>py</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Module2</span>.</span></span>py</span><br></pre></td></tr></table></figure><p>包中的模块可以通过”.”访问符进行访问，即”包名.模块名”。有以下几种导入方法：</p><ul><li><p>直接导入一个包：</p><p><code>import Package</code></p></li><li><p>导入子模块或子包，包嵌套的情况下可以进行嵌套导入：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Package <span class="keyword">import</span> Module1</span><br><span class="line"><span class="keyword">import</span> Package.Module1</span><br><span class="line"><span class="keyword">from</span> Package <span class="keyword">import</span> Subpackage</span><br><span class="line"><span class="keyword">import</span> Package.Subpackage</span><br><span class="line"><span class="keyword">from</span> Package.Subpackage <span class="keyword">import</span> Module1</span><br><span class="line"><span class="keyword">import</span> Package.Subpackage.Module1</span><br></pre></td></tr></table></figure></li></ul><p><code>__init__.py</code> 的作用：</p><ul><li>使包和普通目录区分</li><li>可以在该文件中申明模块级别的 import 语句，从而使其变成包级别可见</li></ul><p>如果 <code>__init__.py</code> 文件为空，当意图使用 <code>from Package import *</code> 将包 Package 中所有的模块导入当前名字空间时，并不能使得导入的模块生效，这是因为不同平台间的文件的命名规则不同，Python 解释器并不能正确判定模块在对应的平台该如何导入，因此仅仅执行 <code>__init__.py</code> 文件，<strong>如果要控制模块的导入，则需要对 <code>__init__.py</code> 文件做修改。</strong></p><p><code>__init__.py</code> 文件还有一个作用就是通过在该文件中定义 <code>__all__</code> 变量，控制需要导入的子包或者模块。之后再运行 <code>from ... import *</code>，可以看到 <code>__all__</code> 变量中定义的模块和包被导入当前名字空间。</p><p>包的使用能够带来以下便利：</p><ul><li>合理组织代码，便于维护和使用</li><li>能够有效地避免名称空间冲突</li></ul><p>如果模块包含的属性和方法存在同名冲突，使用 <code>import module</code> <strong>可以有效地避免名称冲突</strong>。在嵌套的包结构中，每一个模块都以其所在的完整路径作为其前缀，因此，即使名称一样，但由于模块所对应的其前缀不同，就不会产生冲突。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精炼汇总。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编写高质量Python程序（一）引论</title>
    <link href="http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%AE%BA.html"/>
    <id>http://monteyang.cn/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%AE%BA.html</id>
    <published>2020-04-09T17:45:35.000Z</published>
    <updated>2020-04-22T14:10:54.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。</p></blockquote><a id="more"></a><h1 id="理解Pythonic概念"><a href="#理解Pythonic概念" class="headerlink" title="理解Pythonic概念"></a>理解Pythonic概念</h1><ul><li><p>什么是 Pythonic？</p><p>Pythonic的代码就是具有Python独特风格的代码。通俗说来，就是在保证代码可读性的前提下，尽可能地简洁、优雅，看起来像伪代码一样。</p></li><li><p>具有 Python 代码风格的例子</p><ul><li><strong>交换两个变量</strong>。其他语言交换两个变量时，一般需要一个临时的中间变量，而Python中可以用一行代码直接交换。</li><li><strong>for循环直接遍历容器</strong>。其他语言中，需要根据索引下标i对容器进行遍历，而Python可以用for循环直接遍历容器。</li><li><strong>使用 <code>str.format()</code> 格式化字符串</strong>，是最Pythonic的字符串格式化方法。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交换两个变量</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环遍历容器</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> alist:</span><br><span class="line">    do_sth_with(elem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># format格式化字符串</span></span><br><span class="line">print(<span class="string">"&#123;greet&#125; from &#123;language&#125;!"</span>.format(greet=<span class="string">"hello, world!"</span>, language=<span class="string">"Python"</span>))</span><br></pre></td></tr></table></figure><ul><li>Python的库和框架：现有的框架就好比现有的“轮子”，学会利用这些框架，不重复造轮子。</li></ul><h1 id="编写Pythonic代码"><a href="#编写Pythonic代码" class="headerlink" title="编写Pythonic代码"></a>编写Pythonic代码</h1><p>注意要避免的事：</p><ul><li>避免只用大小写来区分不同的对象。</li><li>避免使用容易混淆的名称。</li><li>不要害怕过长的变量名。能表达清楚变量代表的含义即可。</li></ul><p>深入理解Pythonic的几个途径：</p><ul><li>学习语言特性和库特性时，<strong>从官方文档入手，</strong> 仿照他们的书写规范。</li><li>Python的版本更新快，跟进前言，掌握新特性。</li><li>学习业界公认的Pythonic代码，如Flask、gevent和requests等。</li></ul><h1 id="理解Python和C语言的不同之处"><a href="#理解Python和C语言的不同之处" class="headerlink" title="理解Python和C语言的不同之处"></a>理解Python和C语言的不同之处</h1><ul><li><strong>“缩进”和“{}”：</strong> C语言用花括号<code>{}</code>分隔代码块，Python中用缩进分隔，避免混用空格和Tab键。</li><li><strong><code>&#39;</code>与<code>&quot;</code>：</strong> 在C语言中，单引号<code>&#39;</code>表示单个的字符型数据(char)，双引号<code>&quot;</code>表示字符串，默认以<code>\0</code>结尾；在Python中，<code>&#39;</code>和<code>&quot;</code>无明显区别。</li><li><strong>三元操作符<code>?:</code>：</strong> C语言中的三元操作符 <code>C?X:Y</code>，表示当条件C为True的时候，取值X，否则取值Y。在Python中的等价形式为 <code>X if C else Y</code>。</li><li><strong>switch…case：</strong> C语言中的<code>switch...case</code>分支语句，Python中可以使用<code>if...elif...else...</code>代替。</li></ul><h1 id="在代码中添加注释"><a href="#在代码中添加注释" class="headerlink" title="在代码中添加注释"></a>在代码中添加注释</h1><p>Python中有3种形式注释：</p><ul><li>块注释</li><li>行注释</li><li>文档注释(dostring)</li></ul><p>需要注意：</p><ol><li>使用块或行注释时，仅仅注释那些复杂操作、算法，还有那些难以理解的、不够一目了然的代码。</li><li>注释和代码隔开一定距离。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">1</span>  <span class="comment"># 这样的注释略近</span></span><br><span class="line">x = x + <span class="number">1</span>       <span class="comment"># 更好的注释位置</span></span><br></pre></td></tr></table></figure><ol><li>给外部可访问的函数或方法添加文档注释。描述其功能、参数、返回值及可能的异常等信息。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span><span class="params">(name, lines)</span>:</span></span><br><span class="line">    <span class="string">"""Return lines that begin with name.</span></span><br><span class="line"><span class="string">    Lines are expected to look like:</span></span><br><span class="line"><span class="string">        name: space separated values</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name: string, parameter name.</span></span><br><span class="line"><span class="string">        lines: iterable of string, lines in the file.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List of values in the lines that match.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    retval = []</span><br><span class="line">    matches = itertools.ifilter(<span class="keyword">lambda</span> x: x.startswith(name + <span class="string">":"</span>), lines)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> matches:</span><br><span class="line">        retval.extend(line[len(name) + <span class="number">1</span> :].split())</span><br><span class="line">    <span class="keyword">return</span> retval</span><br></pre></td></tr></table></figure><ol><li>建议在文件头包含copyright声明、模块描述，有必要的话还可以加入作者信息。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright 2014 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"># you may not ...</span></span><br></pre></td></tr></table></figure><ol><li>更新代码之后，注释要和代码同步更新。在实际工作中，很容易发生代码不断迭代，而忘了更新注释的情况，需要加以小心。</li></ol><h1 id="适当添加空行，使代码布局更优雅、合理"><a href="#适当添加空行，使代码布局更优雅、合理" class="headerlink" title="适当添加空行，使代码布局更优雅、合理"></a>适当添加空行，使代码布局更优雅、合理</h1><ol><li>在一组代码表达完一个完整思路之后，应用空行进行分隔。</li><li><strong>保持上下文语义的易理解性。</strong> 当一个函数调用另一个函数时，尽量将它们放在一起，一般<strong>调用者在上，被调用者在下。</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    B()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ol><li><strong>空格的使用</strong><ul><li>二元运算符（赋值<code>=</code>，比较（<code>==, &lt;, &gt;, !=, &lt;=, &gt;=, in, not in, is, is not</code>），布尔运算（<code>and, or, not</code>））的左右两边。如<code>x == 1</code></li><li>逗号和分号前不要使用空格。</li><li>函数名和左括号之间、序列索引操作时序列名和<code>[]</code>之间不需要空格，函数的参数<code>=</code>两侧不需要空格。</li></ul></li></ol><h1 id="编写函数的4个原则"><a href="#编写函数的4个原则" class="headerlink" title="编写函数的4个原则"></a>编写函数的4个原则</h1><ol><li>函数设计尽量短小，嵌套层次不宜过深。</li><li>函数声明需合理、简单、易于使用。</li><li>函数参数设计时，应考虑向下兼容（<strong>兼容之前的版本</strong>）。</li><li>一个函数只做一件事（<strong>解耦合</strong>）。</li></ol><hr><ul><li>参考：《编写高质量代码——改善Python程序的91个建议》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章为《编写高质量代码——改善Python程序的91个建议》的精华汇总。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Blender学习资料</title>
    <link href="http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html"/>
    <id>http://monteyang.cn/Blender%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.html</id>
    <published>2020-03-10T03:51:23.000Z</published>
    <updated>2020-03-10T13:15:45.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender是什么？"><a href="#Blender是什么？" class="headerlink" title="Blender是什么？"></a>Blender是什么？</h1><blockquote><p>摘自官方手册：<br>Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括<strong>建模、渲染、动画&amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟</strong>。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且<strong>可通过Python脚本来自定义界面</strong>)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。</p></blockquote><a id="more"></a><p>可以看出，Blender的功能很强大，从3D图形到视频，它都能搞。</p><p>博主之前对3D建模软件完全不了解，仅仅是听说过3DMax、Maya这些名字而已。在查阅了一些资料后，发现这种3D建模软件还是适合设计类专业的同学进行系统学习。</p><p>在查资料的过程中，发现这个软件有很多优秀的特点，包括：</p><ul><li><strong>跨平台</strong>： 对Linux用户很友好</li><li><strong>开源</strong>： 基于社区的开源项目，很吊，更新迭代快，完善速度快</li><li><strong>插件</strong>： 可以想象很多大牛会在这搞一些“骚操作”插件</li><li><strong>有Python API</strong>： 这就更骚了，会写代码的话，建模效率岂不是飞起？</li></ul><p>其实博主个人对3D建模、设计什么的不是很感兴趣，所以就学习下基本的操作和Python的调用，也是因为之前师兄说Blender中可以用Python对3D模型处理，之后可能会用得上吧。</p><h1 id="学习资料和社区"><a href="#学习资料和社区" class="headerlink" title="学习资料和社区"></a>学习资料和社区</h1><ul><li><a href="https://www.blendercn.org/" target="_blank" rel="external nofollow noopener noreferrer">Blender中国社区</a>: 国内Blender资料最全的社区。包括视频教程、中文文档、论坛等。</li><li><a href="https://docs.blender.org/manual/zh-hans/dev/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.83 参考手册</a></li><li><a href="https://docs.blender.org/api/current/index.html" target="_blank" rel="external nofollow noopener noreferrer">Blender 2.82 Python API Documentation</a></li><li><a href="https://www.bilibili.com/video/av17804799/" target="_blank" rel="external nofollow noopener noreferrer">Blender官方入门教程（中文）B站</a>: 每个视频极短，适合小白入门，</li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>众所周知，无论是玩什么软件，掌握快捷键都能<strong>极大程度地提高工作效率</strong>。</p><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><ul><li>停止当前操作：【ESC】</li><li>快捷搜索：【SPACE】</li><li>撤销：【Ctrl】+【z】</li><li>重做：【Ctrl】+【shift】+【z】</li><li>渲染：【F12】</li><li>单选：【鼠标右键】（RMB）</li><li>全选：【A】</li><li>框选：【B】</li><li>刷选：【C】</li><li>套选：【Ctrl】+【鼠标左键】（LMB）</li><li>删除：【X】/【Delete】</li><li>复制：【Shift】+【D】</li><li>添加：【Shift】+【A】</li><li>取消：【Esc】/【RMB】</li><li>确认：【Return】/【LMB】</li></ul><h2 id="界面操作"><a href="#界面操作" class="headerlink" title="界面操作"></a>界面操作</h2><ul><li>工具栏位置对称切换：【F5】</li><li>固定/解固定工具栏：【SHIFT】+【LMB】</li><li>放大/缩小：【SHIFT】+【SPACE】</li><li>放大/缩小：【Ctrl】+【UP】/【Ctrl】+【DOWN】</li><li>移动视窗：【SHIFT】+【鼠标滚轮】</li><li>旋转视窗：【鼠标滚轮】</li><li>3DView：【SHIFT】+【F5】</li><li>UVEditorView：【SHIFT】+【F10】</li></ul><h2 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h2><ul><li>透视开启/关闭：【5】</li><li>前视图（+Ctrl后视图）：【1】</li><li>右视图（+Ctrl左视图）：【2】</li><li>顶视图（+Ctrl底视图）：【7】</li><li>摄像机视角（如果有摄像机）：【0】</li><li>将当前视图设为摄像机视角：【Ctrl】+【alt】+【0】</li><li>全屏显示当前视图：【Ctrl】+【up】</li><li>显示选中目标：小键盘【del】</li><li>显示所有目标：【Home】</li><li>场景平移：【Shift】+【鼠标中键】</li><li>场景缩放：【Ctrl】+【鼠标中键】（或者【滚轮】）</li></ul><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><ul><li>编辑模式：【Tab】</li><li>点线面三模式切换（编辑模式下）：【Tab】+【Ctrl】</li><li>加选/减选：【Ctrl】+【小键盘+/-】（可定义为【PageUP】，【PageDown】）</li><li>选择循环点/边/面：【Alt】+【LMB】</li><li>线框模式：【Z】</li><li>隐藏选中目标：【H】</li><li>显示所有隐藏目标：【Alt】+【H】</li></ul><h2 id="选中目标状态下"><a href="#选中目标状态下" class="headerlink" title="选中目标状态下"></a>选中目标状态下</h2><ul><li>挤出：【E】+【LMB】（挤出到鼠标位置）</li><li>移动：【G】</li><li>旋转：【R】</li><li>缩放：【S】(以上操作再按下X、Y、Z以固定轴向、轴心活动）</li><li>内插面：【i】</li><li>顶点/边滑移：【GG】</li><li>环切：【Ctrl】+【R】</li><li>边线折痕：【Shift】+【E】</li><li>快捷拓展命令栏：【W】</li><li>切割：【K】</li><li>分割：【Y】</li><li>分离（单独个体）：【P】</li><li>合并：【Ctrl】+【J】</li><li>倒角：【Ctrl】+【B】</li><li>球形化：【Shift】+【Alt】+【S】</li><li>关联选取：【L】</li><li>相似选取：【Shift】+【G】</li><li>创建父级：【Ctrl】+【P】</li><li>清除父级：【Alt】+【P】</li><li>吸附：【Shift】+【S】</li></ul><h2 id="节点编辑器"><a href="#节点编辑器" class="headerlink" title="节点编辑器"></a>节点编辑器</h2><ul><li>连接节点：【F】（选取两个目标）</li><li>断开节点：【Ctrl】+【LMB】（划掉连接线）</li><li>添加转接点：【Shift】+【LMB】（划掉连接线）</li><li>合并节点：【Ctrl】+【J】</li><li>断开选中节点：【Alt】+【D】</li><li>移动背景视图：【Alt】+【鼠标滚轮】</li><li>显示激活节点：小键盘【del】</li><li>显示所有节点：【Home】</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li>删除动画关键帧在信息清单视图：（DopeSheet）中按【B】框选按【X】删除选中的keyframes</li><li>插入一个关键帧（keyframe）：【I】</li><li>清除该关键帧：【Alt】-【I】</li><li>清空所有关键帧（删除所有的F-Curves）：【Alt】-【Shift】-【I】</li><li>assignadriver：【D】</li><li>clearthedriver：【Alt】-【D】</li><li>addaKeyingSet：【K】</li><li>cleartheKeyingSet：【Alt】-【K】</li><li>清除posemode下的旋转：【Alt】+【R】</li><li>清除posemode下的缩放：【Alt】+【S】</li><li>清楚posemode下的位移：【Alt】+【G】</li></ul><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><ul><li>到文本开始处：【Home】</li><li>到文本结束处：【End】</li><li>拷贝文本：【Ctrl】-【C】</li><li>粘贴文本：【Ctrl】-【V】</li><li>选择所有文本：【Ctrl】-【A】</li></ul><h2 id="数字调整"><a href="#数字调整" class="headerlink" title="数字调整"></a>数字调整</h2><ul><li>拖动时捕捉离散步骤：【Ctrl】</li><li>更高的调整精度：【Shift】</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>编辑模式下，弹出边编辑菜单，其中有UV映射常用的seem（缝边）功能：【Ctrl】+【E】</li><li>合并物体：【Ctrl】+【J】</li><li>分离物体：【P】</li><li>把选中的两个相邻三角形合并成四边形（quads）：【ALT】+【J】</li><li>吸附游标到选择点：【SHIFT】+【S】</li><li>撕开所选边：【V】</li><li>撕开所选边并填充：【ALT】+【V】</li><li>编辑模式下，合并选中的2个节点：【ALT】+【M】</li><li>打开吸附模式：【SHIFT】+【TAB】</li><li>打开点线面选择模式选取菜单：【Ctrl】+【TAB】</li><li>在EditMode下，将选中的表面变成三角面：【Ctrl】+【T】</li><li>环切loopcut：【Ctrl】+【R】</li><li>多个环切：【再按住鼠标滚轮上下滚动】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Blender是什么？&quot;&gt;&lt;a href=&quot;#Blender是什么？&quot; class=&quot;headerlink&quot; title=&quot;Blender是什么？&quot;&gt;&lt;/a&gt;Blender是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;摘自官方手册：&lt;br&gt;Blender是一个完整集成的3D创作套件，提供了大量的基础工具，包括&lt;strong&gt;建模、渲染、动画&amp;amp;绑定、视频编辑、视觉效果、合成、贴图，以及多种类型的模拟&lt;/strong&gt;。跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果(并且&lt;strong&gt;可通过Python脚本来自定义界面&lt;/strong&gt;)。高质量的3D架构，带来了快速且高效的工作流。活跃的社区支持， blender.org/community 收录了大量的站点列表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://monteyang.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Blender" scheme="http://monteyang.cn/tags/Blender/"/>
    
  </entry>
  
  <entry>
    <title>Python-for循环的内部机制</title>
    <link href="http://monteyang.cn/Python-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.html"/>
    <id>http://monteyang.cn/Python-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.html</id>
    <published>2020-03-02T06:36:24.000Z</published>
    <updated>2020-03-31T08:23:05.631Z</updated>
    
    <content type="html"><![CDATA[<p>Python中，使用for循环可以迭代容器对象中的元素，这里容器对象包括是列表（list）、元组（tuple）、字典（dict）、集合（set）等。但是，为什么这些对象可以使用for循环进行操作呢？</p><a id="more"></a><p>首先，定义一个简单的类尝试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> TestRange(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'TestRange'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br></pre></td></tr></table></figure></p><p>错误信息提示，’TestRange’ object 不是可迭代的对象。那么，什么才是可迭代的对象呢？</p><p>在可迭代的对象中，需要实现一个<code>__iter__</code>魔法方法，而且这个方法的返回值需要是一个迭代器。那么，什么是迭代器呢？</p><p>迭代器只需要实现<code>__next__</code>魔法方法。</p><p>以列表（list）为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">13</span>,<span class="number">12</span>,<span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret = nums.__iter__() <span class="comment"># x有此方法，说明list是可迭代的，而且该方法返回一个迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret</span><br><span class="line">&lt;list_iterator object at <span class="number">0x100f32198</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_ret.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>如上所示，列表nums中实现了<code>__iter__</code>方法，而且返回一个迭代器（iterator），迭代器中实现了<code>__next__</code>方法。在不断调用<code>__next__</code>的过程中，就是在不断返回nums中的元素，直到出现<code>StopIteration</code>的错误。</p></blockquote><p>其实，for语句的作用与此类似。<strong>for语句的内部机制为</strong>：</p><ul><li>先判断对象是否为可迭代对象，即是否存在<code>__iter__</code>方法，如果存在则调用<code>__iter__</code>方法，返回一个迭代器；否则，直接抛出TypeError异常；</li><li>不断地调用迭代器的<code>__next__</code>方法，每次调用按顺序迭代获取当前的值；</li><li>迭代完所有元素，就抛出异常 StopIteration，这个异常 python 解释器自己会处理；</li></ul><p>前面的 TestRange 报错是因为它没有实现迭代器协议里面的这两个方法，现在继续改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _max)</span>:</span></span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line">        self._max = _max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.i &lt; self._max:</span><br><span class="line">            i = self.i</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 达到停止条件时，抛出此异常</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行测试</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> TestRange(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>分析：</strong></p><p>因为这个类中，已经实现了<code>__next__</code>方法，所以基于这个类所创建的对象，本身就是一个迭代器。又因为可迭代对象需要有<code>__iter__</code>方法，而且返回一个迭代器，所以<code>__iter__</code>返回对象本身<code>self</code>即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中，使用for循环可以迭代容器对象中的元素，这里容器对象包括是列表（list）、元组（tuple）、字典（dict）、集合（set）等。但是，为什么这些对象可以使用for循环进行操作呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-决策树</title>
    <link href="http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html"/>
    <id>http://monteyang.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91.html</id>
    <published>2020-02-22T06:49:11.000Z</published>
    <updated>2020-03-05T12:20:34.682Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="../images/机器学习-决策树.png" alt></p><hr><a id="more"></a><h1 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h1><p>从根节点开始，在每一个节点进行决策，最终走到叶子节点。既可以做<strong>分类</strong>，也可以做<strong>回归</strong>。</p><p>优点：可读性强，分类速度快。</p><p>通常，决策树学习分为三步： <strong>特征选择</strong>、<strong>决策树生成（构建）</strong>和<strong>决策树的剪枝</strong>。</p><blockquote><p><strong>难点在于决策树的构建</strong>。当构建好决策树后，利用其进行测试，对数据进行分类或回归都是十分简单的。</p></blockquote><h1 id="树的组成"><a href="#树的组成" class="headerlink" title="树的组成"></a>树的组成</h1><ul><li>根节点： 第一个判断条件的节点</li><li>非叶子结点： 中间的过程</li><li>叶子节点： 得到最终的决策结果</li></ul><p>决策树中的每个节点（特征）相当于在数据中切一刀，如果候选的特征越多，切的次数越多。</p><h1 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h1><p>决策树的训练过程就是<strong>决策树的生成</strong>，从给定数据集，构造出一课树。</p><p>从根节点开始选择特征，考虑如何进行特征切分。</p><blockquote><p>从根节点到下面的节点，如何进行选择和切分？</p></blockquote><p>思路： 从根节点到下面的节点所对应的特征，应该依次是从分类效果最好到不好。</p><p>因此，目标： 通过一种衡量标准，计算不同特征进行分支选择后的分类情况，衡量特征的分类效果，找出最好的特征当作根节点，以此类推。</p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>熵：<strong>表示随机变量不确定性的度量。不确定性越强，熵值越高</strong>。</p><p>假设 $X$ 是一个具有有限个值的离散型随机变量，服从如下的概率分布：</p><script type="math/tex; mode=display">P(X=x_i)=p_i,\qquad i=1,2,\cdots,n</script><p>则，随机变量$X$的熵定义为：</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np_i log p_i \quad (2)</script><p>假设 X 服从如下分布：</p><script type="math/tex; mode=display">P(X=1)=p，P(X=0)=1-p，0 \le p \le 1</script><p>于是根据 <strong>公式（2）</strong> 得到它的熵为：</p><script type="math/tex; mode=display">H(p)=-p\log_2p-(1-p)\log_2(1-p)</script><p><img data-src="../images/机器学习-决策树-熵.png" alt></p><p>概率和熵值大小的关系：</p><ul><li>当 p=0或1 时，H(p)=0，随机变量没有不确定性</li><li>当 p=0.5 时，H(p)=1，随机变量的不确定性最大</li></ul><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>设随机变量 $(X,Y)$ 的<strong>联合概率分布</strong>为：</p><script type="math/tex; mode=display">P(X=x_i,Y=y_j)=p_{ij},\quad i=1,2,\cdots,n;\quad j=1,2,\cdots ,m</script><p><strong>条件熵 $H(Y|X)$</strong> 表示在已知随机变量 $X$ 的取值条件下，随机变量 $Y$ 的不确定性。</p><p>其数学定义为：$X$ 给定的条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望，</p><script type="math/tex; mode=display">H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)</script><p>其中，$p_i=P(X=x_i),\quad i=1,2,\cdots,n$</p><p>在此基础上，引出<strong>信息增益</strong>（Information Gain），它<strong>表示在特征 $X$ 给定的条件下，而使得类 $Y$ 的信息不确定性减少的程度</strong>。数学精确表述如下：特征 $A$ 对训练数据集 $D$ 的<strong>信息增益 $G(D,A)$</strong> 定义为集合 $D$ 的熵 $H(D)$ 与特征 $A$ 给定的条件下 $D$ 的条件熵 $H(D | A)$ 之差，即：</p><script type="math/tex; mode=display">G(D,A)=H(D)-H(D|A)</script><p>决策树学习应用信息增益准则选择特征。给定训练数据集 $D$ 和特征 $A$。熵 $H(D)$ 表示对数据集 $D$ 进行分类的不确定性，而条件熵 $H(D|A)$ 表示在特征 $A$ 给定的条件下对数据集 $D$ 进行分类的不确定性。而他们的差，即信息增益就表示由于特征 $A$ 给定的情况下而使得对数据集 $D$ 进行分类的不确定性减少的程度。显然，对于数据集 $D$ 而言，信息增益依赖于特征。一般情况下，不同的特征具有不同的信息增益。<strong>信息增益大的特征具有更强的分类能力。</strong></p><p>由以上的表述，我们应该清楚地知道，决策树构建过程中，我们应该选择信息增益最大的特征进行分裂构建。</p><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>ID3算法的核心是递归的构建决策树，递归的过程中，在每个节点上，计算信息增益选择特征，直至满足递归停止条件（所有特征的信息增益都很小或者没有特征可以选择）。</p><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><p>C4.5 算法和 ID3 算法基本上完全一致，只是特征选择时的选择方法将信息增益换成<strong>信息增益比</strong>。</p><blockquote><p><strong>信息增益比</strong>：<br>特征 $A$ 对训练数据集 $D$ 的信息增益比 $G_R(D,A)$ 表示特征 $A$ 的信息增益 $G(D,A)$ 与训练数据集 $D$ 关于特征 $A$ 的熵 $H_A(D)$ 的比值，即：</p><script type="math/tex; mode=display">G_R(D,A)=\frac{G(D,A)}{H_A(D)}</script></blockquote><hr><h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><p>决策树过拟合风险很大，理论上可以完全分开（极限情况：每个数据对应一个叶子结点）</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>在构建决策树的过程中，进行剪枝，预剪枝的方法包括：</p><ul><li>限制树的<strong>深度</strong></li><li>限制<strong>叶子结点的个数</strong></li><li>限制<strong>叶子结点的样本数</strong></li><li>限制<strong>信息增益</strong></li></ul><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是，建立树之后，再进行剪枝。<br>通过一定的衡量标准，衡量是否分裂该结点。</p><p>总体思路为：</p><p>由完全树 T0 开始，剪枝部分结点得到 T1，再次剪枝部分结点得到 T2……直到剩下树根的树 Tk；在验证数据集上对这 k 个树分别评价，选择损失函数最小的树 Ta。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;../images/机器学习-决策树.png&quot; alt&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://monteyang.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-41-50题</title>
    <link href="http://monteyang.cn/LeetCode-41-50%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-41-50%E9%A2%98.html</id>
    <published>2020-02-11T05:24:11.000Z</published>
    <updated>2020-02-22T04:54:20.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode 41~50 题</p></blockquote><a id="more"></a><h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h1><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><pre><code>输入: [1,2,0]输出: 3</code></pre><p>示例 2:</p><pre><code>输入: [3,4,-1,1]输出: 2</code></pre><p>示例 3:</p><pre><code>输入: [7,8,9,11,12]输出: 1</code></pre><p>说明:</p><ul><li>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        _nums = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n &gt; len(nums):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _nums[n<span class="number">-1</span>] = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(_nums):</span><br><span class="line">            <span class="keyword">if</span> num != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        water_sum = <span class="number">0</span></span><br><span class="line">        left_max_height = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历从 idx=1 到 idx=leng(height)-2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(height) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 求左边最高的墙高</span></span><br><span class="line">            left_max_height = height[i - <span class="number">1</span>] \</span><br><span class="line">                 <span class="keyword">if</span> height[i - <span class="number">1</span>] &gt; left_max_height <span class="keyword">else</span> left_max_height</span><br><span class="line">            <span class="comment"># 求右边最高的墙高</span></span><br><span class="line">            right_max_height = <span class="number">0</span></span><br><span class="line">            right_max_height = max(height[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 当前列可容纳的水量</span></span><br><span class="line">            water = max(min(left_max_height, right_max_height) - height[i], <span class="number">0</span>)</span><br><span class="line">            water_sum += water</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water_sum</span><br></pre></td></tr></table></figure><hr><h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><ul><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            self._dict.update(&#123;str(i): i&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 使num1为长度较小的</span></span><br><span class="line">        <span class="keyword">if</span> len(num1) &gt; len(num2):</span><br><span class="line">            num1, num2 = num2, num1</span><br><span class="line">        num2 = self.str2int(num2)</span><br><span class="line">        <span class="comment"># 将num1的每一位与num2相乘</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num1)+<span class="number">1</span>):</span><br><span class="line">            res += self._dict[num1[-i]] * num2 * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""将str类型转化为int类型"""</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(num)+<span class="number">1</span>):</span><br><span class="line">            ret += self._dict[num[-i]] * (<span class="number">10</span>**(i<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h1 id="44-TODO"><a href="#44-TODO" class="headerlink" title="44. TODO"></a>44. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><pre><code>输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。    从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p>说明:</p><pre><code>假设你总是可以到达数组的最后一个位置。</code></pre><blockquote><p>思路：考虑贪心算法，如何确定下一步的位置？考虑下下一步能够到的最远距离。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(idx)</span>:</span></span><br><span class="line">            <span class="string">"""输入当前idx, 返回当前应走到的索引"""</span></span><br><span class="line">            max_distance = <span class="number">0</span></span><br><span class="line">            go2idx = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历当前可以走的所有索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nums[idx]+<span class="number">1</span>):</span><br><span class="line">                next_idx = idx + i  <span class="comment"># 下一位置的索引</span></span><br><span class="line">                <span class="keyword">if</span> next_idx &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> len(nums) - <span class="number">1</span></span><br><span class="line">                distance = next_idx + nums[next_idx]  <span class="comment"># 可以走的距离</span></span><br><span class="line">                <span class="keyword">if</span> distance &gt; max_distance:</span><br><span class="line">                    max_distance = distance</span><br><span class="line">                    go2idx = next_idx</span><br><span class="line">            <span class="keyword">return</span> go2idx</span><br><span class="line"></span><br><span class="line">        next_idx = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> next_idx &lt; len(nums)<span class="number">-1</span>:</span><br><span class="line">            next_idx = util(next_idx)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><blockquote><p>思路：用树结构思考，考虑深度优先遍历</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(mem, residual)</span>:</span></span><br><span class="line">            <span class="comment"># 如果没有剩余元素，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> residual:</span><br><span class="line">                res.append(mem)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(residual)):</span><br><span class="line">                residual_tmp = copy.deepcopy(residual)</span><br><span class="line">                residual_tmp.pop(i)</span><br><span class="line">                dfs(mem+[residual[i]], residual_tmp)</span><br><span class="line"></span><br><span class="line">        dfs([], nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="47-TODO"><a href="#47-TODO" class="headerlink" title="47. TODO"></a>47. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="48-TODO"><a href="#48-TODO" class="headerlink" title="48. TODO"></a>48. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="49-TODO"><a href="#49-TODO" class="headerlink" title="49. TODO"></a>49. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="50-TODO"><a href="#50-TODO" class="headerlink" title="50. TODO"></a>50. TODO</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode 41~50 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-PointNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-PointNet.html</id>
    <published>2020-01-09T06:56:01.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation"><a href="#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation" class="headerlink" title="PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation"></a>PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</h2><ul><li>关键词: point cloud, deep learning</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>直接对点云进行学习 =&gt; 实现分类/分割</li></ul><ul><li>针对点云的深度学习算法需满足的特性:<ul><li><strong>无序性</strong>: 所有点无次序</li><li><strong>点与点之间的关系</strong>: 点与neighbor之间存在局部的结构关系</li><li><strong>变换下的不变性</strong>: 旋转/平移等不改变点云模型的整体类别和局部分割类别</li></ul></li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>提取点云的全局/局部特征<ul><li>全局特征: 表示形状类别的特征</li><li>局部特征: 每个点的特征</li></ul></li></ul><ul><li>T-Net: 将所有点对齐到一个规范空间中</li><li>用<strong>对称函数</strong> MaxPooling: 解决点云的无序性</li><li>对于Segmentation: 局部特征 + 全局特征 (Aggregation)</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/PointNet-Network.png" alt="Network" title="PointNet"></p><ul><li>输入的点数为 n</li><li>global feature 维度1024不是对应点数,而是模型整体的特征</li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>3D分类: ModelNet40</li><li>3D部件分割: ShapeNet的子集(16类)</li><li>3D场景分割: I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,M. Fischer, and S. Savarese. 3d semantic parsing of large-scale indoor spaces.</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>数据预处理<ul><li>在Mesh的表面均匀采样1024个点</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>3D 分类:<ul><li>accuracy</li></ul></li><li>3D 分割:<ul><li>mIoU</li></ul></li></ul><h3 id="4-Disadvantages"><a href="#4-Disadvantages" class="headerlink" title="4. Disadvantages"></a>4. Disadvantages</h3><p>未充分挖掘局部结构特征</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot;&gt;&lt;a href=&quot;#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&quot;&gt;&lt;/a&gt;PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: point cloud, deep learning&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-VoxNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-VoxNet.html</id>
    <published>2020-01-09T06:38:39.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition"><a href="#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition" class="headerlink" title="VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition"></a>VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition</h2><ul><li>关键词: voxel, 3D deep learning</li><li>会议: IROS</li><li>源码: official √<ul><li><a href="https://github.com/MonteYang/VoxNet.pytorch" target="_blank" rel="external nofollow noopener noreferrer">我的复现: by PyTorch</a></li></ul></li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><p>针对Voxel的3d物体识别/分类</p><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><p>将在视频领域取得一定效果的3D CNN用于Voxel的特征提取</p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/3-VoxNet-Network.png" alt title="VoxNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>3种数据集:</p><ul><li>LiDAR data - Sydney Urban Objects</li><li>CAD data - ModelNet</li><li>RGBD data - NYUv2</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO:</p><h3 id="4-Advantages"><a href="#4-Advantages" class="headerlink" title="4. Advantages"></a>4. Advantages</h3><ul><li>表现性能超过了之前的 ShapeNet</li><li>参数比 ShapeNet 少一些  <blockquote><p>ShapeNet is a relatively large architecture, with over 12.4 million parameters, while VoxNet has less than 1 million.</p></blockquote></li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>计算性能受Voxel的分辨率限制: 当Voxel分辨率过高时,内存占用过高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot;&gt;&lt;a href=&quot;#VoxNet-A-3D-Convolutional-Neural-Network-for-Real-Time-Object-Recognition&quot; class=&quot;headerlink&quot; title=&quot;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&quot;&gt;&lt;/a&gt;VoxNet: A 3D Convolutional Neural Network for Real-Time Object Recognition&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: voxel, 3D deep learning&lt;/li&gt;
&lt;li&gt;会议: IROS&lt;/li&gt;
&lt;li&gt;源码: official √&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/MonteYang/VoxNet.pytorch&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;我的复现: by PyTorch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Voxel" scheme="http://monteyang.cn/tags/Voxel/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Ciss-Net</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Ciss-Net.html</id>
    <published>2020-01-09T06:28:22.000Z</published>
    <updated>2020-03-11T13:18:23.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context-Reinforced-Semantic-Segmentation"><a href="#Context-Reinforced-Semantic-Segmentation" class="headerlink" title="Context-Reinforced Semantic Segmentation"></a><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf" target="_blank" rel="external nofollow noopener noreferrer">Context-Reinforced Semantic Segmentation</a></h2><ul><li>关键词: 强化学习, image segmentation, context</li><li>会议: CVPR 2019</li><li>源码: √</li></ul><a id="more"></a><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Plroblem"><a href="#1-Plroblem" class="headerlink" title="1. Plroblem"></a>1. Plroblem</h3><ul><li>Context(上下文信息)在语义分割中至关重要, 挖掘图像中上下文信息</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>使用分割后的图片 p-maps 作为上下文信息的来源</li><li>该项工作提出Context-Net -&gt; 更好的挖掘上下文信息</li><li>将上下文信息的学习过程定义为马尔科夫决策问题(MDP), 使用强化学习方法进行优化</li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/CissNet-Network.png" alt="Ciss_Net"></p><ul><li>Environment: <code>p-map</code></li><li>Agent: <code>Context Net</code><ul><li>State: $\{Y_I\}$</li><li>Action: $\{B_I\}$</li></ul></li></ul><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><ul><li>ADE20K</li><li>Cityscapes</li><li>Pascal Context</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><p>TODO</p><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><!-- ### 4. Advantages ### 5. Disadvantages -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Context-Reinforced-Semantic-Segmentation&quot;&gt;&lt;a href=&quot;#Context-Reinforced-Semantic-Segmentation&quot; class=&quot;headerlink&quot; title=&quot;Context-Reinforced Semantic Segmentation&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://openaccess.thecvf.com/content_CVPR_2019/papers/Zhou_Context-Reinforced_Semantic_Segmentation_CVPR_2019_paper.pdf&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Context-Reinforced Semantic Segmentation&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: 强化学习, image segmentation, context&lt;/li&gt;
&lt;li&gt;会议: CVPR 2019&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="强化学习" scheme="http://monteyang.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="image segmentation" scheme="http://monteyang.cn/tags/image-segmentation/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-MeshNet</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MeshNet.html</id>
    <published>2020-01-09T03:18:28.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation"><a href="#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation" class="headerlink" title="MeshNet: Mesh Neural Network for 3D Shape Representation"></a>MeshNet: Mesh Neural Network for 3D Shape Representation</h2><ul><li>关键词: Mesh, 3D shape classification/retrieval</li><li>会议: AAAI 2018</li><li>源码: √</li></ul><a id="more"></a><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>PoinNet</li><li>KC-Net</li></ul><blockquote><p>Related Work:</p><ul><li>Mesh Feature Extraction</li><li>Deep Learning Methods for 3D Shape Representation<ul><li>voxel-based</li><li>view-based</li><li>point-based</li><li>fusion method</li></ul></li></ul></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1. Problem"></a>1. Problem</h3><ul><li>直接对 Mesh 进行形状表示的学习</li><li>应用于 3D shape classification/retrieval</li></ul><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><ul><li>将一个face视作一个单元</li><li><p>face的特征分为:</p><ul><li><strong>空间特征</strong></li><li><strong>结构特征</strong></li></ul></li><li><p>针对<strong>空间特征</strong>和<strong>结构特征</strong>分别提出:</p><ul><li>Spatial Descriptor<ul><li>面的中心点作为输入</li><li>采用与point cloud类似的处理方法</li></ul></li><li>Structural Descriptor<ul><li><strong>face rotate convolution</strong></li><li><strong>face kernel correlation</strong></li></ul></li></ul></li><li><p>整合空间特征和结构特征: 提出 Mesh Convolution</p></li></ul><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p><img data-src="/images/MeshNet-Network.png" alt="MeshNet-Network"></p><h3 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h3><h4 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 Dataset</h4><p>ModelNet40</p><ul><li>for 3D classification/retrieval</li><li>40类别</li></ul><h4 id="3-2-Implemention"><a href="#3-2-Implemention" class="headerlink" title="3.2 Implemention"></a>3.2 Implemention</h4><ul><li>Mesh模型需先简化至<strong>不多于1024个面</strong>(以面为单位,类似PointNet中以点为单位)</li><li>由于Mesh的面数不恒定, 随机选取填满1024个面 for batch training</li><li>数据增强: 所有点按高斯分布进行随机平移: N(0, 0.01)</li><li>for Classification:<ul><li>global features 后添加 MLP(512, 256, 40): 40表示40个类别</li><li>MLP的最后两层添加dropout层: drop概率为0.5</li></ul></li><li>for Retrieval:<ul><li>global features 直接计算 L2 距离</li></ul></li><li>训练时的超参数:<ul><li>SGD optimizer</li><li>initial learning rate 0.01</li><li>momentum 0.9</li><li>weight decay 0.0005</li><li>batch size 64.</li></ul></li></ul><h4 id="3-3-Metric"><a href="#3-3-Metric" class="headerlink" title="3.3 Metric"></a>3.3 Metric</h4><ul><li>Classification: Accuracy</li><li>Retrieval: mAP</li></ul><h4 id="3-4-Ablation-Study"><a href="#3-4-Ablation-Study" class="headerlink" title="3.4 Ablation Study"></a>3.4 Ablation Study</h4><p>TODO:</p><h4 id="3-5-Result"><a href="#3-5-Result" class="headerlink" title="3.5 Result"></a>3.5 Result</h4><p><img data-src="/images/MeshNet-exp-results.png" alt="实验结果" title="ModelNet实验结果"><br>&lt;!— ### 4. Advantages</p><ul><li>将point的方法应用于Mesh的特征提取(空间提取, KC)</li></ul><h3 id="5-Disadvantages"><a href="#5-Disadvantages" class="headerlink" title="5. Disadvantages"></a>5. Disadvantages</h3><ul><li>空间特征提取 不仅考虑面的中心点, 可以加入中心点周围的三个点的信息, 可能会有所提升.</li><li>当前面和周围三个面可能会有相似的特征.可否进行替换 —&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot;&gt;&lt;a href=&quot;#MeshNet-Mesh-Neural-Network-for-3D-Shape-Representation&quot; class=&quot;headerlink&quot; title=&quot;MeshNet: Mesh Neural Network for 3D Shape Representation&quot;&gt;&lt;/a&gt;MeshNet: Mesh Neural Network for 3D Shape Representation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关键词: Mesh, 3D shape classification/retrieval&lt;/li&gt;
&lt;li&gt;会议: AAAI 2018&lt;/li&gt;
&lt;li&gt;源码: √&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="笔记" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="Mesh" scheme="http://monteyang.cn/tags/Mesh/"/>
    
  </entry>
  
  <entry>
    <title>Paper Reading Plan</title>
    <link href="http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html"/>
    <id>http://monteyang.cn/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92.html</id>
    <published>2020-01-09T03:02:40.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h2><ul><li>[x] AlexNet</li><li>[x] VGGNet</li><li>[x] ResNet</li><li>[x] InceptionNet</li><li>[ ] DenseNet</li><li>[ ] SENet</li></ul><h2 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h2><ul><li>[x] MeshNet</li><li>[ ] MeshCNN</li></ul><h2 id="Voxel"><a href="#Voxel" class="headerlink" title="Voxel"></a>Voxel</h2><ul><li>[ ] 3D ShapeNet</li><li>[ ] VoxNet</li><li>[ ] OctNet</li><li>[ ] FPNN</li><li>[ ] O-CNN</li></ul><h2 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h2><ul><li>[X] PointNet</li><li>[x] PointNet++</li><li>[x] KC-Net</li><li>[ ] PointSIFT</li><li>[ ] Point-Voxel</li><li>[ ] PointGrid</li></ul><h2 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h2><ul><li>[ ] DeepSDF</li></ul><h2 id="Reinfocement-Learning"><a href="#Reinfocement-Learning" class="headerlink" title="Reinfocement Learning"></a>Reinfocement Learning</h2><ul><li>[ ] DDPG</li><li>[ ] MADDPG</li></ul><h2 id="CNN-basic"><a href="#CNN-basic" class="headerlink" title="CNN-basic"></a>CNN-basic</h2><ul><li>[x] Tricks-of-CNN</li></ul><h2 id="Image-Segmentation"><a href="#Image-Segmentation" class="headerlink" title="Image Segmentation"></a>Image Segmentation</h2><ul><li>[ ] FCN</li><li>[ ] U-Net</li><li>[ ] SegNet</li><li>[ ] DeepLab系列</li><li>[ ] Fully Convolutional DenseNet</li><li>[ ] E-Net</li><li>[ ] Link-Net</li><li>[ ] Mask R-CNN</li><li>[ ] PSPNet</li><li>[ ] RefineNet</li><li>[ ] HR-Net</li><li>[ ] Ciss-Net</li></ul><!-- ---- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation-CVPR2017-论文链接-tensorflow代码-pytorch代码- PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space-NIPS2017-论文链接-tensorflow代码-pytorch代码- Escape from Cells: Deep Kd-Networks for the Recognition of 3D Point Cloud Models-ICCV2017-论文链接-pytorch代码- KCNet: Mining Point Cloud Local Structures by Kernel Correlation and Graph Pooling-CVPR2018-论文链接-caffe代码-pytorch代码- Pointwise Convolutional Neural Networks-CVPR2018-论文链接-tensorflow代码- SO-Net: Self-Organizing Network for Point Cloud Analysis-CVPR2018-论文链接-pytorch代码- Recurrent Slice Networks for 3D Segmentation of Point Clouds-CVPR2018-论文链接-pytorch代码- SPLATNet: Sparse Lattice Networks for Point Cloud Processing-CVPR2018-l论文链接-caffe代码-pytorch代码- Large-scale Point Cloud Semantic Segmentation with Superpoint Graphs-CVPR2018-论文链接-pytorch代码- Dynamic Graph CNN for Learning on Point Cloud-arxiv2018-论文链接-代码链接- Local Spectral Graph Convolution for Point Set Feature Learning-ECCV2018-论文链接-tensorflow代码- SpiderCNN: Deep Learning on Point Sets with Parameterized Convolutional Filters-ECCV2018-论文链接-tensorflow代码- Point Convolutional Neural Networks by Extension Operators-SIGGRAPH 2018-论文链接-tensorflow代码- PointCNN: Convolution On X-Transformed Points-NeurIPS 2018-论文链接-tensorflow代码-mxnet代码-pytorch代码- PointSIFT: A SIFT-like Network Module for 3D Point Cloud Semantic Segmentation-arxiv2018-论文链接-tensorflow代码-pytorch代码- PointConv: Deep Convolutional Networks on 3D Point Clouds-arxiv2018-论文链接- Adversarial Autoencoders for Generating 3D Point Clouds-arxiv2018-论文链接- Modeling Local Geometric Structure of 3D Point Clouds using Geo-CNN-论文链接- Supervised Fitting of Geometric Primitives to 3D Point Clouds-CVPR2019-l论文链接-tensorflow代码- Multi-view Point Cloud Registration with Adaptive Convergence Threshold and its Application on 3D Model Retrieval-论文链接- Iterative Transformer Network for 3D Point Cloud-arxiv2018-论文链接- DeepMapping: Unsupervised Map Estimation From Multiple Point Clouds-arxiv2018-论文链接- CAPNet: Continuous Approximation Projection For 3D Point Cloud Reconstruction Using 2D Supervision-论文链接-AAAI2019-代码链接- Increasing the Capability of Neural Networks for Surface Reconstruction from Noisy Point Clouds-arxiv2018-论文链接- Topology-Aware Surface Reconstruction for Point Clouds-arxiv2018-论文链接- Nesti-Net: Normal Estimation for Unstructured 3D Point Clouds using Convolutional Neural Networks-arxiv2018-论文链接- Inferring Point Clouds from Single Monocular Images by Depth Intermediation-arxiv2018-论文链接- Learning Saliency Maps for Adversarial Point-Cloud Generation-arxiv2019-论文链接- A Graph-CNN for 3D Point Cloud Classification- ICASSP 2018-论文链接-tensorflow代码- GSPN: Generative Shape Proposal Network for 3D Instance Segmentation in Point Cloud-arxiv2018-论文链接- PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud-arxiv2018-论文链接- Deep RBFNet: Point Cloud Feature Learning using Radial Basis Functions-arxiv2018-论文链接- IPOD: Intensive Point-based Object Detector for Point Cloud-arxiv2018-论文链接- PointPillars: Fast Encoders for Object Detection from Point Clouds-arxiv2018-论文链接- 3D Point Cloud Learning for Large-scale Environment Analysis and Place Recognition-arxiv2018-论文链接- 3D Point Cloud Denoising via Bipartite Graph Approximation and Reweighted Graph Laplacian-arxiv2018-论文链接- Casualty Detection from 3D Point Cloud Data for Autonomous Ground Mobile Rescue Robots-SSRR)2018-论文链接- Deflecting 3D Adversarial Point Clouds Through Outlier-Guided Removal-arxiv2018-论文链接- Machine learning enables polymer cloud-point engineering via inverse design-arxiv2018-论文链接- 3D Convolution on RGB-D Point Clouds for Accurate Model-free Object Pose Estimation-arxiv2018-论文链接- Feature Preserving and Uniformity-controllable Point Cloud Simplification on Graph-arxiv2018-论文链接- GeoNet: Deep Geodesic Networks for Point Cloud Analysis-CVPR2019-论文链接- POINTCLEANNET: Learning to Denoise and Remove Outliers from Dense Point Clouds-arxiv2018-论文链接-pytorch代码- Generic Primitive Detection in Point Clouds Using Novel Minimal Quadric Fits-T-PAMI2019-论文链接- Fast 3D Line Segment Detection From Unorganized Point Cloud-arxiv2019-论文链接- Extending Adversarial Attacks and Defenses to Deep 3D Point Cloud Classifiers-arxiv2019-论文链接-tensorflow代码- Skeletonisation Algorithms for Unorganised Point Clouds with Theoretical Guarantees-arxiv2019-论文链接- Automatic normal orientation in point clouds of building interiors-arxiv2019-论文链接- Fitting 3D Shapes from Partial and Noisy Point Clouds with Evolutionary Computing-arxiv2019-论文链接- Context Prediction for Unsupervised Deep Learning on Point Clouds-arxiv2019-论文链接- Dense 3D Point Cloud Reconstruction Using a Deep Pyramid Network-WACV 2019-论文链接- Points2Pix: 3D Point-Cloud to Image Translation using conditional Generative Adversarial Networks-arxiv2019-l论文链接- NeuralSampler: Euclidean Point Cloud Auto-Encoder and Sampler-arxiv2019-l论文链接- Embedded Delaunay triangulations for point clouds of surfaces in-arxiv2019-l论文链接- 3D point cloud registration with shape constraint-ICIP 2017-论文链接- Occupancy-map-based rate distortion optimization for video-based point cloud compression-arxiv2019-论文链接- 3D Graph Embedding Learning with a Structure-aware Loss Function for Point Cloud Semantic Instance Segmentation-arxiv2019-论文链接- PIXOR: Real-time 3D Object Detection from Point Clouds- CVPR2018-论文链接-pytorch代码- Multi-view Incremental Segmentation of 3D Point Clouds for Mobile Robots-arxiv2019-论文链接- Point cloud denoising based on tensor Tucker decomposition-CVPR2019-l论文链接- Associatively Segmenting Instances and Semantics in Point Clouds-CVPR2019-论文链接- Zero-shot Learning of 3D Point Cloud Objects-MVA2019-论文链接- Octree guided CNN with Spherical Kernels for 3D Point Clouds-arxiv2019-论文链接- Real-time Multiple People Hand Localization in 4D Point Clouds-arxiv2019-论文链接- Variational Graph Methods for Efficient Point Cloud Sparsification-arxiv2019-代码链接- HoloCast: Graph Signal Processing for Graceful Point Cloud Delivery-arxiv2019-论文链接- Fast Registration for cross-source point clouds by using weak regional affinity and pixel-wise refinement-ICME 2019-论文链接- PointNetLK: Robust & Efficient Point Cloud Registration using PointNet-arxiv2019-论文链接- Neural Style Transfer for Point Clouds-arxiv2019-论文链接- OREOS: Oriented Recognition of 3D Point Clouds in Outdoor Scenarios-arxiv2019-论文链接- Learning Convolutional Transforms for Lossy Point Cloud Geometry Compression-arxiv2019-论文链接- Monocular 3D Object Detection with Pseudo-LiDAR Point Cloud-论文链接-arxiv2019- FVNet: 3D Front-View Proposal Generation for Real-Time Object Detection from Point Clouds-论文链接-arxiv2019- Unpaired Point Cloud Completion on Real Scans using Adversarial Training-论文链接-arxiv2019- USIP: Unsupervised Stable Interest Point Detection from 3D Point Clouds-论文链接-arxiv2019-代码链接- MortonNet: Self-Supervised Learning of Local Features in 3D Point Clouds-论文链接-arxiv2019- Discrete Rotation Equivariance for Point Cloud Recognition-论文链接-ICRA 2019-代码链接- JSIS3D: Joint Semantic-Instance Segmentation of 3D Point Clouds with Multi-Task Pointwise Networks and Multi-Value Conditional Random Fields-论文链接-CVPR 2019(oral)-代码链接- DeepPoint3D: Learning Discriminative Local Descriptors using Deep Metric Learning on 3D Point Clouds-论文链接-arxiv2019- A Dataset for Semantic Segmentation of Point Cloud Sequences-论文链接-arxiv2019- Point Cloud Oversegmentation with Graph-Structured Deep Metric Learning-论文链接-CVPR2019- Generalizing discrete convolutions for unstructured point clouds-论文链接-arxiv2019- 3D Point Cloud Denoising via Deep Neural Network based Local Surface Estimation-论文链接-arxiv2019- Complexer-YOLO: Real-Time 3D Object Detection and Tracking on Semantic Point Clouds-论文链接-arxiv2019- Total Denoising: Unsupervised Learning of 3D Point Cloud Cleaning-论文链接-arxiv2019- 3D Object Recognition with Ensemble Learning — A Study of Point Cloud-Based Deep Learning Models-论文链接-arxiv2019- Deep Hough Voting for 3D Object Detection in Point Clouds-论文链接-arxiv2019- 2D3D-MatchNet: Learning to Match Keypoints Across 2D Image and 3D Point Cloud-论文链接-arxiv2019- PCAN: 3D Attention Map Learning Using Contextual Information for Point Cloud Based Retrieval-论文链接-CVPR2019- Graph-based Inpainting for 3D Dynamic Point Clouds-论文链接-arxiv2019- 3D Dynamic Point Cloud Denoising via Spatio-temporal Graph Modeling-论文链接-arxiv2019- RL-GAN-Net: A Reinforcement Learning Agent Controlled GAN Network for Real-Time Point Cloud Shape Completion-论文链接-cvpr2019-代码链接- Unsupervised Feature Learning for Point Cloud by Contrasting and Clustering With Graph Convolutional Neural Network-论文链接-arxiv2019- Loop-Closure Detection Based on 3D Point Cloud Learning for Self-Driving Industry Vehicles-论文链接-arxiv2019- Oriented Point Sampling for Plane Detection in Unorganized Point Clouds-论文链接-ICRA2019- Deep Closest Point: Learning Representations for Point Cloud Registration-论文链接-arxiv2019- Deep AutoEncoder-based Lossy Geometry Compression for Point Clouds-论文链接-arxiv2019- DeepICP: An End-to-End Deep Neural Network for 3D Point Cloud Registration-论文链接-arxiv2019- Deep Unsupervised Learning of 3D Point Clouds via Graph Topology Inference and Filtering-论文链接-arxiv2019- Cooper: Cooperative Perception for Connected Autonomous Vehicles based on 3D Point Clouds-论文链接 -ICDCS 2019- 3D Point Cloud Generative Adversarial Network Based on Tree Structured Graph Convolutions-论文链接-arxiv2019- SAWNet: A Spatially Aware Deep Neural Network for 3D Point Cloud Processing-论文链接-arxiv2019- A Two-stage Classification Method for High-dimensional Data and Point Clouds-论文链接-arxiv2019- GAPNet: Graph Attention based Point Neural Network for Exploiting Local Feature of Point Cloud-论文链接-arxiv2019- RIU-Net: Embarrassingly simple semantic segmentation of 3D LiDAR point cloud-论文链接-arxiv2019- Domain Adaptation for Vehicle Detection from Bird’s Eye View LiDAR Point Cloud Data-论文链接-Under review for IEEE SMC 2019- Robust Point Cloud Based Reconstruction of Large-Scale Outdoor Scenes-论文链接-CVPR2019- Efficient Curvature Estimation for Oriented Point Clouds-论文链接-arxiv2019- Leveraging binding-site structure for drug discovery with point-cloud methods-论文链接-arxiv2019- NPTC-net: Narrow-Band Parallel Transport Convolutional Neural Network on Point Clouds-论文链接-arxiv2019- Partial Computing Offloading Assisted Cloud Point Registration in Multi-robot SLAM-论文链接-arxiv2019- Point Clouds Learning with Attention-based Graph Convolution Networks-论文链接-arxiv2019- Learning Object Bounding Boxes for 3D Instance Segmentation on Point Clouds-论文链接-arxiv2019- Direct structural analysis of domains defined by point clouds-论文链接-arxiv2019- Learning Shape Representation on Sparse Point Clouds for Volumetric Image Segmentation-论文链接-MICCAI 2019 --><!--Templete---分界线---## 文章信息- 标题:- 关键词:- 会议:- 源码: √## 相关文章:> Related Work:## Note### 1. Plroblem### 2. Method#### Network Structure### 3. Experiment#### 3.1 Dataset#### 3.2 Implemention#### 3.3 Metric#### 3.4 Ablation Study#### 3.5 Result<!--### 4. Advantages### 5. Disadvantages-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Neural-Network&quot;&gt;&lt;a href=&quot;#Neural-Network&quot; class=&quot;headerlink&quot; title=&quot;Neural Network&quot;&gt;&lt;/a&gt;Neural Network&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[x] AlexNet&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="计划" scheme="http://monteyang.cn/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="论文阅读" scheme="http://monteyang.cn/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="paper reading plan" scheme="http://monteyang.cn/tags/paper-reading-plan/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31-40题</title>
    <link href="http://monteyang.cn/LeetCode-31-40%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-31-40%E9%A2%98.html</id>
    <published>2020-01-08T02:56:02.000Z</published>
    <updated>2020-02-18T15:22:56.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>31~40</code> 题</p></blockquote><a id="more"></a><hr><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><pre><code>1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><blockquote><p>思路:<br>字典序算法</p><ol><li>从右往左, 找出第一个小于右邻的数 <code>list[x]</code>;</li><li>从右往左, 找出第一个比 <code>list[x]</code> 大的数 <code>list[y]</code>;</li><li>交换 <code>list[x]</code> 和 <code>list[y]</code>;</li><li>将 <code>list[x]</code> 后面的序列从小到大排序. </li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        x = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在下一个更大的字典序(即当前序列为最大的字典序), 则将序列转为最小字典序</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">-1</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                y = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 3, 4</span></span><br><span class="line">        nums[x], nums[y] = nums[y], nums[x]</span><br><span class="line">        nums[x+<span class="number">1</span>:] = sorted(nums[x+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><blockquote><p>思路:</p><ol><li>用栈实现括号匹配</li><li>用数组保存一个有效括号的索引值</li><li>对所有索引值进行排序</li><li>找出连续索引长度中的最长长度</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># ()()()(()()()(()))</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        idxs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># 如果栈为空时</span></span><br><span class="line">            <span class="keyword">if</span> stack == []:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 如果栈非空时</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                    idxs.append(i)</span><br><span class="line">                    idxs.append(stack.pop())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line"></span><br><span class="line">        idxs.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> idxs: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(idxs)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> idxs[j+<span class="number">1</span>] - idxs[j] == <span class="number">1</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> max_length &lt; length:</span><br><span class="line">                    max_length = length</span><br><span class="line">                length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(length, max_length)</span><br></pre></td></tr></table></figure><hr><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p><p>示例 1:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums = [4,5,6,7,0,1,2]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 找出最小值的索引</span></span><br><span class="line">        min_idx = self.search_min_idx(nums)</span><br><span class="line">        <span class="keyword">if</span> min_idx != <span class="number">0</span>:</span><br><span class="line">            nums = nums[min_idx:] + nums[:min_idx]</span><br><span class="line">        <span class="comment"># 二分查找</span></span><br><span class="line">        tmp_idx = self.bin_search(nums, target)</span><br><span class="line">        <span class="keyword">if</span> tmp_idx == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> (tmp_idx + min_idx) % len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_min_idx</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> </span></span><br><span class="line">        <span class="keyword">return</span> nums.index(min(nums))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        二分查找法:</span></span><br><span class="line"><span class="string">            - 如果nums中存在目标值, 则返回该值的index;</span></span><br><span class="line"><span class="string">            - 如果nums中不存在目标值, 则返回 -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h1 id="34-TODO"><a href="#34-TODO" class="headerlink" title="34. TODO"></a>34. TODO</h1><hr><h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><pre><code>输入: [1,3,5,6], 5输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [1,3,5,6], 2输出: 1</code></pre><p>示例 3:</p><pre><code>输入: [1,3,5,6], 7输出: 4</code></pre><p>示例 4:</p><pre><code>输入: [1,3,5,6], 0输出: 0</code></pre><blockquote><p><strong>思路</strong></p><ol><li>扫一次, 若当前值小于 <code>target</code>, 则跳过; 若当前值大于等于 <code>target</code>, 则返回当前索引</li><li>若所有元素都小于 <code>target</code>, 则返回<code>(最大索引+1)</code></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><hr><h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1:</p><pre><code>输入:[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true</code></pre><p>示例 2:</p><pre><code>输入:[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。    但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><pre><code>一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。给定数独永远是 9x9 形式的。</code></pre><blockquote><p><strong>思路</strong></p><ol><li>数独板块中共有 <strong>9行 \ 9列 \ 9个小块</strong>, <strong>每行 \ 每列 \ 每个小块</strong> 都建立一个 hash map, 用来记录该<strong>行\列\小块</strong>中数字对应的个数</li><li>遍历所有 9*9 个元素:<ol><li>一旦 hash map 中存在大于1个的元素, 则不满足数独条件, 返回 <code>false</code>;</li><li>如果遍历结束后, 都未出现 <code>false</code>, 则满足数独条件.</li></ol></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        small_box = [[&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]  <span class="comment"># 3*3个 small box</span></span><br><span class="line">        row = [&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 9行</span></span><br><span class="line">        colum = copy.deepcopy(row)  <span class="comment"># 9列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx_row, r <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> idx_colum, num <span class="keyword">in</span> enumerate(r):</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">'.'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前元素为 num, 判断该元素属于哪个small_box</span></span><br><span class="line">                <span class="comment"># 如果对应的small box中没有该数, 设置hash中的key的value为1</span></span><br><span class="line">                <span class="comment"># 如果对应的small box已存在该数, 则返回错误</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>]:</span><br><span class="line">                    small_box[idx_row // <span class="number">3</span>][idx_colum // <span class="number">3</span>][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前row中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> row[idx_row]:</span><br><span class="line">                    row[idx_row][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断该元素在当前列中是否存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> colum[idx_colum]:</span><br><span class="line">                    colum[idx_colum][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="37-TODO"><a href="#37-TODO" class="headerlink" title="37. TODO"></a>37. TODO</h1><hr><h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221</li></ol><p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>示例 1:</p><pre><code>输入: 1输出: &quot;1&quot;解释：这是一个基本样例。</code></pre><p>示例 2:</p><pre><code>输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre><blockquote><p>思路：<br>迭代求解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        s = <span class="string">'1*'</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            s = self.util(s)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">""" 输入s, 返回s的下一个外观数列, 注意s的最后一个字符是'*'.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            s (string): 以 * 结尾的字符串</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 下一个外观数列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (str(cnt) + s[i - <span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        s = res + <span class="string">'*'</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><hr><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><pre><code>所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><pre><code>输入: candidates = [2,3,6,7], target = 7,所求解集为:[⁠ [7],⁠ [2,2,3]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,3,5], target = 8,所求解集为:[[2,2,2,2],[2,3,3],[3,5]]</code></pre><blockquote><p>思路: 回溯法 + 利用树的数据结构判断</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        candidates.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(candidates, cur_sum, tmp_list)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> candidates == []: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表之和等于 target, 加入res</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(tmp_list)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前列表元素之和大于 target，直接返回（剪枝）</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前列表元素之和小于 target，继续添加元素</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    _tmp_list = copy.deepcopy(tmp_list)</span><br><span class="line">                    _tmp_list.append(c)</span><br><span class="line">                    util(candidates[i:], cur_sum+c, _tmp_list)</span><br><span class="line">        </span><br><span class="line">        util(candidates, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="40-组合之和II"><a href="#40-组合之和II" class="headerlink" title="40. 组合之和II"></a>40. 组合之和II</h1><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p>示例 1:</p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><p>示例 2:</p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[[1,2,2],[5]]</code></pre><blockquote><p>思路:<br>与上一题相似, 多增加去重步骤</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()  <span class="comment"># [1,1,2,5,6,]</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(cur_sum, cur_list, candidates)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                res.append(cur_list)</span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(candidates):</span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> c == candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                    _cur_list = cur_list[:]</span><br><span class="line">                    _cur_list.append(c)</span><br><span class="line">                    back_track(cur_sum+c, _cur_list, candidates[i+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        back_track(<span class="number">0</span>, [], candidates)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;31~40&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2019年的总结</title>
    <link href="http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/2019%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93.html</id>
    <published>2020-01-04T15:15:35.000Z</published>
    <updated>2020-03-17T17:54:22.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h1><p>转眼间，在北邮的研究生生涯已经过半，今年对我来说最最要的两件事：修满学分和开题，完成的都还算顺利。</p><p><strong>关于科研</strong>。从今年4月开始，和博士师兄进行科研，做三维网格模型和强化学习的结合，虽然最终实验效果没有预想中那样理想，但这个过程中收获编程经验和师兄的指导，对我来说都是宝贵的，因为从开始就意识到了导师可能放养，分给实验室其他导师，想做算法的话难度就很大，所以师兄算是我的一位导师了。</p><p><strong>关于编程</strong>。在和师兄做项目的这个阶段，一直是使用Python编程，这一年下来进步了很多，从一开始胡乱写代码，到现在能开始考虑代码的效率、整洁和可读性。在这之前看过一点数据结构，感觉很难就看不下去了，今年再看数据结构的时候，虽然还是很难，但有些东西是有些理解了，也算是种进步吧。最近还发现遗忘东西很快，学习也没有考研时的那种毅力了，所以搭建了博客，一方面是把学的东西记录下来，另一方面也希望借着写博客的名义，监督自己完成学习计划。</p><p><strong>关于未来就业</strong>。随着今年的秋招算法岗的火爆，劝退的趋势愈发猛烈，有朋友说工作是一定能找到的，也有朋友劝我做两手准备。其实面对算法和开发，当我问自己兴趣在哪的时候，并没有答案，反思了一下，发觉自己可能只是喜欢写代码，喜欢把代码变得整洁，喜欢debug后跑起来的结果，对于代码能做什么事反倒是没有太关注，而且现在在实验室里只是改别人的框架，套上自己的想法进行实验，还不知道真正与工业界的差别有多大，可能只有真正地工作上才会有答案。</p><!-- **关于校园生活**。对我来说研究生的三年是短暂而宝贵的，考研到北邮对我来说是来之不易的，在来到北邮后，遇见了很多厉害的人。有很多有才华的人、自信的人在这个校园发光发热。每次晚上回宿舍时总有一些实验室的灯还在亮着，咖啡店里无时不刻都有人在讨论着项目方案、代码和Presentation……之前听“比你优秀的人比你还努力”当作是个段子，没想到实际上这种人竟然这么多。总之，这个环境有一种让人催着自己不断努力的魔力，让我觉得这三年的时间是宝贵的、短暂的。 --><h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><ul><li>[√] 杭州</li><li>[√] 秦皇岛</li><li>[√] 大连</li><li>[√] 上海</li><li>[√] 南京</li></ul><h1 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h1><p>从2016年至今，和女朋友在一起有3年多了，心态也逐渐变得成熟，慢慢地学会了帮助对方调节情绪和压力，而且最近忽然觉得，其实所有情侣间所有的吵架都是两个人情绪管理能力不好的体现，如果有一方的情绪管理很强，那么争吵就无法引发，因为情绪管理的能力不仅体现在懂得调解自身的情绪，更体现在能够帮助他人疏解情绪。在知乎上看到，情商高的体现不是意味着会说好话、阿谀奉承，而是具备管理情绪的能力，正是这样，如果一个人具备强大的情绪管理能力，那么这个人的情商一定非常高。之前和女朋友关于毕业去哪个城市这个问题意见不同，现在我也明白了其中缘由，希望两个人都能顺利在沈阳找到一份合适的工作。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p><strong>有关坚持与时间</strong>。关于“坚持的意义”，最初的体会是从考研二战那年开始，然而当今年读到《暗时间》这本书，这种体会更加深刻。回顾过去，其实真正坚持下来的事情没有几件，比如大三时来北京实习做了一个月电气设计，学会了些CAD的快捷键和画图方法，当毕业面临就业时，却没坚持找一份电气设计，现在早就忘得一干二净。每一项坚持都需要时间上的投资，“<em>1万小时定律</em>”说的是想要成为一个领域的专家，需要付出大概1万小时的努力。不断地切换自己想从事的工作，每件事都没坚持下来，虽然美其名曰是不喜欢，但在一定程度上浪费了时间。时间的成本是极高的，就好比现在爆红的那些00后的歌手或者明星，哪一个不是从小就开始坚持自己热爱的事业。从读研开始，才真正意义上接触编程，今后还想靠它作为谋生手段，这就意味着在这件事上，需要比别人更多的时间以及坚持。这个过程一定很难，但更为重要的一句话是，<em>“种一棵树最好的时间是十年前，其次是现在”</em>。</p><p><strong>有关所谓的成功和失败</strong>。曾经对于成功和失败看得很重，一件事没有做好就会懊悔、消极，陷入心态崩了的情形。然而现在越来越觉得，失败是世界上的一种常态，成功才是真正的偶然，但这些偶然中不是超凡的天赋，就是“超凡”的努力。而且一件事的失败，如果不是外界的原因，就是自身的原因。如果是自身的原因，那就没有权利情绪消极，如果是外界的原因，那连情绪消极的意义都没有。</p><p><strong>有关“重复”</strong>。之前看过一个记录片，讲的是“重复”的重要性，里面举了教徒每天都要按时背诵经文的例子。仔细想来，学习的过程就是在不断的重复。上学的时候老师布置作业、学期考试，都是让学生不断的重复、加深印象，这种不停的重复，在我的理解中就是一种“背诵”，在脑海中不停的演练。小时候学理科，总有人说这些理科的东西不需要背，确实一些简单的原理不需要背，但有一些公式是肯定要背的，做题的过程就是在加深对公式适用场合的印象，我觉得也是一种背诵。“一万小时定律”只告诉我们要坚持一万小时，但没说一万小时里都要做什么，目前我能想到的答案就是重复。</p><!-- # 2020今年要做的事情大概有：帮助她顺利毕业、投一篇小论文、找一份在沈阳的工作、看一场演唱会、完成一两段旅行。 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学业&quot;&gt;&lt;a href=&quot;#学业&quot; class=&quot;headerlink&quot; title=&quot;学业&quot;&gt;&lt;/a&gt;学业&lt;/h1&gt;&lt;p&gt;转眼间，在北邮的研究生生涯已经过半，今年对我来说最最要的两件事：修满学分和开题，完成的都还算顺利。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于科研&lt;
      
    
    </summary>
    
    
      <category term="总结与随感" scheme="http://monteyang.cn/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="总结" scheme="http://monteyang.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21-30题</title>
    <link href="http://monteyang.cn/LeetCode-21-30%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-21-30%E9%A2%98.html</id>
    <published>2020-01-04T13:42:00.000Z</published>
    <updated>2020-03-16T06:40:10.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>21~30</code>题</p></blockquote><a id="more"></a><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        head = ListNode(<span class="string">"#"</span>)</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2:</span><br><span class="line">            <span class="keyword">if</span> (p2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p1) <span class="keyword">or</span> (p1 <span class="keyword">and</span> (p1.val &lt;= p2.val)):</span><br><span class="line">                cur.next = ListNode(p1.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> (p1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> p2) <span class="keyword">or</span> (p2 <span class="keyword">and</span> (p2.val &lt; p1.val)):</span><br><span class="line">                cur.next = ListNode(p2.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><hr><h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><pre><code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><blockquote><p>思路:<br>回溯法,利用递归生成括号.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">                           l0 r0</span></span><br><span class="line"><span class="string">                        /          \</span></span><br><span class="line"><span class="string">                       (          </span></span><br><span class="line"><span class="string">                    l1 r0           </span></span><br><span class="line"><span class="string">                    /   \        </span></span><br><span class="line"><span class="string">                  ((     ()         </span></span><br><span class="line"><span class="string">                l2 r0   l1 r1</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(cur_str, n_lb, n_rb)</span>:</span></span><br><span class="line">            <span class="comment"># 超出括号数量则终止</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n <span class="keyword">or</span> n_rb &gt; n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 左右括号数量均达到n,则添加到res</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb == n:</span><br><span class="line">                res.append(cur_str)</span><br><span class="line">            <span class="comment"># 左右括号数量相等时,当前string只能添加'(',剪枝?</span></span><br><span class="line">            <span class="keyword">if</span> n_lb == n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">            <span class="comment"># 左括号大于右括号时,当前string可以添加'('或')'</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &gt; n_rb:</span><br><span class="line">                util(cur_str+<span class="string">'('</span>, n_lb+<span class="number">1</span>, n_rb)</span><br><span class="line">                util(cur_str+<span class="string">')'</span>, n_lb, n_rb+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 左括号小于右括号则返回</span></span><br><span class="line">            <span class="keyword">if</span> n_lb &lt; n_rb:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        util(<span class="string">''</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><pre><code>输入:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><blockquote><p>思路:<br>先对所有链表结点中的value进行排序,然后根据排序后的value生成一个长链表.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 特殊情况: lists为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对所有val进行排序</span></span><br><span class="line">        val_all = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    val_all.append(node.val)</span><br><span class="line">                    node = node.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val_all = sorted(val_all)</span><br><span class="line">        <span class="comment"># 生成整个链表</span></span><br><span class="line">        head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> val_all:</span><br><span class="line">            node.next = ListNode(v)</span><br><span class="line">            node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><hr><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><blockquote><p>思路:<br>两两交换结点:添加1个头和1个尾,以便交换中间的两个结点.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        p_head  -&gt;   1    -&gt;     2    -&gt;    3   -&gt;  4</span></span><br><span class="line"><span class="string">        (p)     -&gt;   q    -&gt;     r    -&gt;    s </span></span><br><span class="line"><span class="string">                          -&gt;    (p)   -&gt;    q   -&gt;  r </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置头结点,方便后续处理</span></span><br><span class="line">        p_head = ListNode(<span class="string">'#'</span>)</span><br><span class="line">        p_head.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如图设置p,q,r,s的指向</span></span><br><span class="line">        p = p_head</span><br><span class="line">        q = p.next</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:  <span class="comment"># 奇数个结点则跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 交换</span></span><br><span class="line">            s = r.next</span><br><span class="line">            r.next = q</span><br><span class="line">            q.next = s</span><br><span class="line">            p.next = r</span><br><span class="line">            <span class="comment"># 移动指针p的指向</span></span><br><span class="line">            p = p.next.next</span><br><span class="line">            q = p.next</span><br><span class="line">        <span class="comment"># 必须返回p_head.next, 不能返回head, 因为head已经在链表中被交换.</span></span><br><span class="line">        <span class="keyword">return</span> p_head.next</span><br></pre></td></tr></table></figure><hr><h1 id="k-个一组翻转链表"><a href="#k-个一组翻转链表" class="headerlink" title="k-个一组翻转链表"></a>k-个一组翻转链表</h1><p>TODO</p><hr><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><pre><code>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:</p><ol><li>利用快慢指针: </li><li>利用排好序的性质: 类似栈,相等则弹出</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        p = - float(<span class="string">"inf"</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 如果下一个数和当前指向的元素相等, 删除下一个数</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] == p:</span><br><span class="line">                    <span class="keyword">del</span> nums[i]</span><br><span class="line">                <span class="comment"># 如果不等, 保留</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p = nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><hr><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p>给定一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地</strong>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><pre><code>给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2:</p><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><blockquote><p>思路:<br>快慢指针</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果第i个元素等于目标值val, 跳过</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果第i个元素不等于目标值val, 从头依次添加到原list中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><hr><h1 id="实现-str-str"><a href="#实现-str-str" class="headerlink" title="实现-str-str"></a>实现-str-str</h1><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2</code></pre><p>示例 2:</p><pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1</code></pre><p><strong>说明:</strong><br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)-len(needle)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>TODO: KMP</p><hr><h1 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>示例 1:</p><pre><code>输入: dividend = 10, divisor = 3输出: 3</code></pre><p>示例 2:</p><pre><code>输入: dividend = 7, divisor = -3输出: -2</code></pre><p>说明:</p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</li></ul><blockquote><p>思路:<br>倍增再相减,类似二分查找</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(dividend, divisor)</span>:</span></span><br><span class="line">            <span class="string">""" 除数倍增(×2), 获取被除数与除数间最大的2次幂倍数 """</span></span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> dividend &gt; divisor*i*<span class="number">2</span>:</span><br><span class="line">                    i *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="comment"># 获取结果的符号</span></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        dividend = abs(dividend)</span><br><span class="line">        divisor = abs(divisor)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            _j = util(dividend, divisor)</span><br><span class="line">            j += _j</span><br><span class="line">            dividend = dividend - _j*divisor</span><br><span class="line">            <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">                <span class="keyword">if</span> sign*j &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> sign*j &lt; <span class="number">-2</span>**<span class="number">31</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">                <span class="keyword">return</span> sign * j</span><br></pre></td></tr></table></figure><hr><h1 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h1><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><pre><code>输入：s = &quot;barfoothefoobarman&quot;,words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;wordgoodgoodgoodbestword&quot;,words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[]</code></pre><blockquote><p>思路:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> res</span><br><span class="line">        len_sub_string = len(words[<span class="number">0</span>])  <span class="comment"># word字符串的长度</span></span><br><span class="line">        <span class="comment"># 用一个hash表对应word和word的个数</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> hash_table:</span><br><span class="line">                hash_table[w] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[w] = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 遍历所有元素的指针</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s) - len_sub_string*len(words) + <span class="number">1</span>:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># copy一个hash表作为临时</span></span><br><span class="line">            _hash_table = copy.deepcopy(hash_table)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 在当前指针i处遍历,如果hash表为空,则添加i</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _hash_table:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                <span class="keyword">if</span> s[j:j+len_sub_string] <span class="keyword">in</span> _hash_table:</span><br><span class="line">                    <span class="keyword">if</span> _hash_table[s[j:j+len_sub_string]] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">del</span> _hash_table[s[j:j+len_sub_string]]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        _hash_table[s[j:j+len_sub_string]] -= <span class="number">1</span></span><br><span class="line">                    j = j + len_sub_string</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>TODO: 时间复杂度</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;21~30&lt;/code&gt;题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11-20题</title>
    <link href="http://monteyang.cn/LeetCode-11-20%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-11-20%E9%A2%98.html</id>
    <published>2019-12-17T13:59:50.000Z</published>
    <updated>2020-03-16T06:40:12.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>11~20</code> 题</p></blockquote><a id="more"></a><h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img data-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><ul><li>示例:<br>  输入: [1,8,6,2,5,4,8,3,7]<br>  输出: 49</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 1. 暴力法</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    def maxArea(self, height):</span></span><br><span class="line"><span class="string">        max_area = 0</span></span><br><span class="line"><span class="string">        for i in range(len(height)):</span></span><br><span class="line"><span class="string">            for j in range(i+1, len(height)):</span></span><br><span class="line"><span class="string">                max_area = max(min(height[i], height[j]) * (j - i), max_area)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return max_area</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 2. 双指针法</span></span><br><span class="line">    <span class="comment"># - 一般来说,距离最远的围成较大面积的可能性较大</span></span><br><span class="line">    <span class="comment"># - 两头各放一个指针</span></span><br><span class="line">    <span class="comment"># - 较短一侧的指针往里移动, 才可能使面积变大(虽然两指针距离变短,但是较短一侧的高度可能变大)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        pt_left = <span class="number">0</span></span><br><span class="line">        pt_right = len(height) - <span class="number">1</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 新算的面积 = min(height[pt_left], height[pt_right])*(pt_right - pt_left)</span></span><br><span class="line">            <span class="comment"># 最大面积 = max(新算的面积, 原来的最大面积)</span></span><br><span class="line">            max_area = max(min(height[pt_left], height[pt_right])*(pt_right - pt_left), max_area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选取较小一侧的指针,往内移动一个单位</span></span><br><span class="line">            <span class="keyword">if</span> height[pt_left] &lt; height[pt_right]:</span><br><span class="line">                pt_left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 指针汇合时, 循环结束</span></span><br><span class="line">            <span class="keyword">if</span> pt_left == pt_right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><hr><h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><ul><li><p>示例 1:<br>  输入: 3<br>  输出: “III”</p></li><li><p>示例 2:<br>  输入: 4<br>  输出: “IV”</p></li><li><p>示例 3:<br>  输入: 9<br>  输出: “IX”</p></li><li><p>示例 4:<br>  输入: 58<br>  输出: “LVIII”<br>  解释: L = 50, V = 5, III = 3.</p></li><li><p>示例 5:<br>  输入: 1994<br>  输出: “MCMXCIV”<br>  解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        lut = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'I'</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">            <span class="number">1000</span>: <span class="string">'M'</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 将输入num除以lut的从大到小的key,进行取模. 模变成被除数继续迭代.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(lut.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            n, mod = divmod(num, i) </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += lut[i] * n</span><br><span class="line">                num = mod</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><p>示例 2:</p><pre><code>输入: &quot;IV&quot;输出: 4</code></pre><p>示例 3:</p><pre><code>输入: &quot;IX&quot;输出: 9</code></pre><p>示例 4:</p><pre><code>输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p>示例 5:</p><pre><code>输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        lut = &#123;<span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">               <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">               <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">               <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">               <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">               <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">               <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">               <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">               <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">               <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">               <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">               <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">               <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先判断当前输入的前两个字符是否是罗马数字,</span></span><br><span class="line">        <span class="comment"># if 是: 加</span></span><br><span class="line">        <span class="comment"># else: 将单个字符转化成数字, 加</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i:i+<span class="number">2</span>] <span class="keyword">in</span> &#123;<span class="string">'IV'</span>, <span class="string">'IX'</span>, <span class="string">'XL'</span>, <span class="string">'XC'</span>, <span class="string">'CD'</span>, <span class="string">'CM'</span>&#125;:</span><br><span class="line">                res += lut[s[i:i+<span class="number">2</span>]]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += lut[s[i]]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: <code>&quot;fl&quot;</code><br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: <code>&quot;&quot;</code><br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""获得 list of string 的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            strs (list): a list of string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: 公共自创</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        commom = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            commom = self.getCommonPrefix(commom, strs[i])</span><br><span class="line">            <span class="keyword">if</span> commom == <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commom</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCommonPrefix</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        <span class="string">"""返回str1和str2的公共子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            str1 (string): 第一个字符串</span></span><br><span class="line"><span class="string">            str2 (string): 第二个字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            string: 公共字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; min(len(str1), len(str2)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] == str2[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str1[:i]</span><br></pre></td></tr></table></figure><hr><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1],[-1, -1, 2]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">""" 返回一组数中之和为0的三个数(list of lists).</span></span><br><span class="line"><span class="string">        解法: 排序 + 使用双指针</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (list): a list of nums</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            list: 每个元素都是3个数且3个数之和为0</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 如果不够3个元素, 则返回空</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        nums = sorted(nums)  <span class="comment"># [-4, -1, -1, 0, 1, 2, ]</span></span><br><span class="line">        <span class="comment"># 确定第一个元素, 第一层遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 如果所有元素都大于等于0, 则返回</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># !!! 去重方法: 排好序后,相等则跳过...</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 确定双指针, 一个最左(i+1), 一个最右[-1]</span></span><br><span class="line">            pt_left = i + <span class="number">1</span></span><br><span class="line">            pt_right = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 三数之和等于0, 添加至res列表, 左右指针都到下一个位置</span></span><br><span class="line">            <span class="comment"># 如果 三数之和大于0, 右指针往左一个单位, 整体变小</span></span><br><span class="line">            <span class="comment"># 如果 三数之和小于0, 左指针往右一个单位, 整体变大</span></span><br><span class="line">            <span class="keyword">while</span> pt_left &lt; pt_right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[pt_left] + nums[pt_right] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[pt_left], nums[pt_right]])</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[pt_left] + nums[pt_right] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_right] == nums[pt_right<span class="number">-1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_right -= <span class="number">1</span></span><br><span class="line">                    pt_right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[pt_left] == nums[pt_left+<span class="number">1</span>] <span class="keyword">and</span> pt_left &lt; pt_right<span class="number">-1</span>:</span><br><span class="line">                        pt_left += <span class="number">1</span></span><br><span class="line">                    pt_left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><pre><code>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums)</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line"></span><br><span class="line">        min_dist = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 重复的则跳过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            L = i + <span class="number">1</span></span><br><span class="line">            R = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                _sum = nums[i] + nums[L] + nums[R]</span><br><span class="line">                delta = _sum - target</span><br><span class="line">                <span class="comment"># 如果两数之差小于最小值,保存该sum为res</span></span><br><span class="line">                <span class="keyword">if</span> abs(delta) &lt; min_dist:</span><br><span class="line">                    res = _sum</span><br><span class="line">                    min_dist = abs(delta)</span><br><span class="line">                <span class="comment"># 三数之和大于target,</span></span><br><span class="line">                <span class="keyword">if</span> delta &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] == nums[R<span class="number">-1</span>]:</span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 三数之和小于target</span></span><br><span class="line">                <span class="keyword">elif</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] == nums[L+<span class="number">1</span>]:</span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> _sum</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例:</p><pre><code>输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].说明:</code></pre><p>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="comment"># digits = "324"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        hashmap = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                   <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                   <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                   <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                   <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                   <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                   <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                   <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        res = [<span class="string">""</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">(res, digit)</span>:</span></span><br><span class="line">            res_tmp = []</span><br><span class="line">            <span class="comment"># 两个for循环进行排列组合</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> hashmap[digit]:</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">                    r += s</span><br><span class="line">                    res_tmp.append(r)</span><br><span class="line">            <span class="keyword">return</span> res_tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            res = util(res, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><pre><code>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[[-1,  0, 0, 1],[-2, -1, 1, 2],[-2,  0, 0, 2]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">""" 在list of nums中,获取能够使得和为target的四元组.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            nums (List[int]): 一组数.</span></span><br><span class="line"><span class="string">            target (int): list of lists, int.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            List[List[int]]: 所有和为target的四元组.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 特殊情况, nums中少于4个数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 1. 排序</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-3</span>):</span><br><span class="line">            <span class="comment"># 避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)<span class="number">-2</span>):</span><br><span class="line">                <span class="comment"># 避免重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 双指针: L-左指针, R-右指针</span></span><br><span class="line">                L = j + <span class="number">1</span></span><br><span class="line">                R = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="comment"># (左指针向右移,右指针向左移)当左指针超过右指针时,break.</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                    <span class="comment"># 如果四数之和等于target,则添加</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[L] + nums[R] == target:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[L], nums[R]])</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和小于target,则左指针向右移动</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[j] + nums[L] + nums[R] &lt; target:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[L] == nums[L+<span class="number">1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            L += <span class="number">1</span></span><br><span class="line">                        L += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果四数之和大于target,则右指针向左移动</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 避免重复</span></span><br><span class="line">                        <span class="keyword">while</span> nums[R] == nums[R<span class="number">-1</span>] <span class="keyword">and</span> L &lt; R<span class="number">-1</span>:</span><br><span class="line">                            R -= <span class="number">1</span></span><br><span class="line">                        R -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h1 id="19-删除链表的倒数第n个节点"><a href="#19-删除链表的倒数第n个节点" class="headerlink" title="19. 删除链表的倒数第n个节点"></a>19. 删除链表的倒数第n个节点</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><blockquote><p>思路:<br>将所有结点放进一个数组中,直接将数组中倒数第n+1个结点的next指针指向倒数第n-1个结点.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="comment"># 链表长度</span></span><br><span class="line">        arr = []</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            arr.append(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n == len(arr):</span><br><span class="line">            head = arr[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node_to_del = arr[-n]</span><br><span class="line">        arr[-n<span class="number">-1</span>].next = node_to_del.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><pre><code>输入: &quot;()&quot;输出: true</code></pre><p>示例 2:</p><pre><code>输入: &quot;()[]{}&quot;输出: true</code></pre><p>示例 3:</p><pre><code>输入: &quot;(]&quot;输出: false</code></pre><p>示例 4:</p><pre><code>输入: &quot;([)]&quot;输出: false</code></pre><p>示例 5:</p><pre><code>输入: &quot;{[]}&quot;输出: true</code></pre><blockquote><p>思路:<br>栈</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        lut = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'['</span>: <span class="string">']'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果输入的是左侧符号,加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> lut:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果输入的是右侧符号:</span></span><br><span class="line">            <span class="comment"># 如果栈中非空, 判断该符号是否与栈中最后一个符号匹配</span></span><br><span class="line">            <span class="keyword">if</span> stack == [] <span class="keyword">and</span> c <span class="keyword">in</span> lut.values():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> c == lut[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;11~20&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1-10题</title>
    <link href="http://monteyang.cn/LeetCode-1-10%E9%A2%98.html"/>
    <id>http://monteyang.cn/LeetCode-1-10%E9%A2%98.html</id>
    <published>2019-12-17T13:47:05.000Z</published>
    <updated>2020-03-17T17:43:17.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode <code>1~10</code> 题</p></blockquote><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><a id="more"></a><blockquote><p>思路:<br>在哈希表中反向存储[元素数值-&gt;元素索引],遍历一次实现O(n).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># 哈希表,反过来存 num -&gt; idx, 有可能同一num对应多个idx, 所以 &#123;12: [idx1, idx2, ...]&#125;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[n] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[n].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num_1, idx_1 <span class="keyword">in</span> hashmap.items():</span><br><span class="line">            <span class="comment"># num_2 = target - num_1 , 在hashmap中</span></span><br><span class="line">            <span class="keyword">if</span> target - num_1 <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># num_1 与 num_2 数值相等时</span></span><br><span class="line">                <span class="keyword">if</span> (target - num_1 == num_1):</span><br><span class="line">                    <span class="comment"># [注意] 如果找到的 num_2 其实是 num_1 自己, 跳过...</span></span><br><span class="line">                    <span class="keyword">if</span> (len(hashmap[num_1]) == <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                    <span class="keyword">if</span> len(hashmap[target-num_1]) &gt;= <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> hashmap[target-num_1][<span class="number">0</span>], hashmap[target-num_1][<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># num_2 与 num_1 不同</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> idx_1[<span class="number">0</span>], hashmap[target-num_1][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>发现测试案例的<code>nums</code>中没有重复元素，因此在创建字典的时候，不用考虑重复元素。但是判断是否满足等式<code>num1 + num2 = target</code>时，需要考虑<code>num1</code>和<code>num2</code>不能是同一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            hashmap[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># 如果是自己, 则跳过</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[target-num] == i:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">return</span> [i, hashmap[target-num]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><hr><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><blockquote><p>思路:<br>每一个位相加时,都要考虑进位.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        HeadNode = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = HeadNode</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历2个链表的同时进行计算,存入result链表</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sum_cur = x + y + carry</span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sum_cur &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                sum_cur %= <span class="number">10</span></span><br><span class="line">            cur.next = ListNode(sum_cur)</span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">and</span> l1.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">and</span> l2.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># l1,l2都遍历完, 但是最后有进位时</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            cur.next = ListNode(carry)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HeadNode.next</span><br></pre></td></tr></table></figure><hr><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。    请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><blockquote><p>思路:<br>滑动窗口法:判断新的元素是否存在于已有的窗口内部.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        window = []</span><br><span class="line">        cur_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> window:</span><br><span class="line">                window = window[window.index(s[i])+<span class="number">1</span>:]</span><br><span class="line">            window.append(s[i])</span><br><span class="line">            cur_length = len(window)</span><br><span class="line">            <span class="keyword">if</span> cur_length &gt; max_length:</span><br><span class="line">                max_length = cur_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure><hr><h1 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p>示例 2:</p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(m+n)</span></span><br><span class="line"><span class="comment"># TODO O(log(m+n))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        length = len(nums1) + len(nums2)</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1 + nums2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        m_idx = int(length/<span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m_idx):</span><br><span class="line">            <span class="keyword">if</span> p2 &gt; len(nums2)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> p1 &gt; len(nums1)<span class="number">-1</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums.append(nums1[p1])</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(nums2[p2])</span><br><span class="line">                p2 = p2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            median = (nums[<span class="number">-1</span>] + nums[<span class="number">-2</span>])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = nums[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median</span><br></pre></td></tr></table></figure><hr><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><ul><li><p>示例 1：<br>  输入: “babad”<br>  输出: “bab”<br>  注意: “aba” 也是一个有效答案。</p></li><li><p>示例 2：<br>  输入: “cbbd”<br>  输出: “bb”</p></li></ul><blockquote><p>思路: “中心扩展法”<br>在每个索引处,从中心展开,获取最长的回文串.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = <span class="string">" "</span>.join(s)</span><br><span class="line">        longest_pali = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cent_idx <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            pali = self.get_longest_pali(s, cent_idx)</span><br><span class="line">            <span class="keyword">if</span> len(pali) &gt; len(longest_pali):</span><br><span class="line">                longest_pali = pali</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_pali</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_longest_pali</span><span class="params">(self, s, cent_idx)</span>:</span></span><br><span class="line">        <span class="string">"""返回字符串s中以索引cent_idx为中心的最长回文子串"""</span></span><br><span class="line">        pali = s[cent_idx]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            left_idx = cent_idx - i</span><br><span class="line">            right_idx = cent_idx + i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 超出范围,跳出</span></span><br><span class="line">            <span class="keyword">if</span> left_idx &lt; <span class="number">0</span> <span class="keyword">or</span> right_idx &gt;= len(s):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[left_idx] == s[right_idx]:</span><br><span class="line">                pali = s[left_idx] + pali + s[right_idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pali = pali.replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pali</span><br></pre></td></tr></table></figure><hr><h1 id="6-z-字形变换"><a href="#6-z-字形变换" class="headerlink" title="6. z-字形变换"></a>6. z-字形变换</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><ul><li><p>示例 1:<br>  输入: s = “LEETCODEISHIRING”, numRows = 3<br>  输出: “LCIRETOESIIGEDHN”</p></li><li><p>示例 2:<br>  输入: s = “LEETCODEISHIRING”, numRows = 4<br>  输出: “LDREOEIIECIHNTSG”<br>  解释:</p><pre><code>  L     D     R  E   O E   I I  E C   I H   N  T     S     G</code></pre><blockquote><p>思路:<br>用一个 List[string], 第n个元素存储第n行的字符.</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numRows &lt; <span class="number">2</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历字符串</span></span><br><span class="line">        <span class="comment"># res[0]: Z的第一行</span></span><br><span class="line">        <span class="comment"># res[1]: Z的第二行</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            res[i] += c</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: order_flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i == numRows - <span class="number">1</span>: order_flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> order_flag:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        res_str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">            res_str += r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_str</span><br></pre></td></tr></table></figure><hr><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><ul><li>示例 1:<br>  输入: 123<br>  输出: 321</li><li>示例 2:<br>  输入: -123<br>  输出: -321</li><li>示例 3:<br>  输入: 120<br>  输出: 21<br>  注意:</li></ul><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        x_orig = x</span><br><span class="line">        x = abs(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            temp = x % <span class="number">10</span></span><br><span class="line">            x = (x - temp)/<span class="number">10</span></span><br><span class="line">            res = res*<span class="number">10</span> + temp</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x_orig &lt; <span class="number">0</span>: res = -res</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> res &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><hr><h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><ul><li>示例 1:<br>  输入: “42”<br>  输出: 42</li><li>示例 2:<br>  输入: “   -42”<br>  输出: -42<br>  解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</li><li>示例 3:<br>  输入: “4193 with words”<br>  输出: 4193<br>  解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</li><li>示例 4:<br>  输入: “words and 987”<br>  输出: 0<br>  解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。</li><li>示例 5:<br>  输入: “-91283472332”<br>  输出: -2147483648<br>  解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        flag_find_first = <span class="literal">True</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            asc = ord(c)</span><br><span class="line">            <span class="comment"># 找第一个符号,</span></span><br><span class="line">            <span class="keyword">if</span> flag_find_first:</span><br><span class="line">                <span class="comment"># 空字符, 跳过</span></span><br><span class="line">                <span class="keyword">if</span> asc == <span class="number">32</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 负号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">45</span>:</span><br><span class="line">                    sign = <span class="number">-1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 正号, 已找到第一个符号</span></span><br><span class="line">                <span class="keyword">elif</span> asc == <span class="number">43</span>:</span><br><span class="line">                    sign = <span class="number">1</span></span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 数字字符</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    flag_find_first = <span class="literal">False</span></span><br><span class="line">                    res = asc<span class="number">-48</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 非上述字符</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 已有第一个符号(正号或符号或数字)的前提下, 接下来只能是数字符号, 如果不是则break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">48</span> &lt;= asc <span class="keyword">and</span> asc &lt;= <span class="number">57</span>:</span><br><span class="line">                    res = int(res*<span class="number">10</span> + (asc<span class="number">-48</span>))</span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> res &gt; (<span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>):</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> sign == <span class="number">-1</span> <span class="keyword">and</span> res &gt; <span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">                        res = <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * res</span><br></pre></td></tr></table></figure><hr><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>示例 1:<br>  输入: 121<br>  输出: true</li><li>示例 2:<br>  输入: -121<br>  输出: false<br>  解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li><li>示例 3:<br>  输入: 10<br>  输出: false<br>  解释: 从右向左读, 为 01 。因此它不是一个回文数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = str(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[-i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符</li><li><p><code>*</code> 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖<strong>整个</strong>字符串<code>s</code>的，而不是部分字符串。</p></li><li><p>说明:<br><code>s</code> 可能为空，且只包含从 a-z 的小写字母。<br><code>p</code> 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></li></ul><ul><li><p>示例 1:<br>  输入: s = “aa”, p = “a”<br>  输出: false<br>  解释: “a” 无法匹配 “aa” 整个字符串。</p></li><li><p>示例 2:<br>  输入: s = “aa”, p = “a<em>“<br>  输出: true<br>  解释: 因为 `</em>` 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p></li><li><p>示例 3:<br>  输入: s = “ab”, p = “.<em>“<br>  输出: true<br>  解释: `.</em><code>表示可匹配零个或多个（</code>*<code>）任意字符（</code>.`）。</p></li><li><p>示例 4:<br>  输入: s = “aab”, p = “c*a*b”<br>  输出: true<br>  解释: 因为 <code>*</code> 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p></li><li><p>示例 5:<br>  输入: s = “mississippi”, p = “mis*is*p*.”<br>  输出: false</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="comment"># 递归基: 都为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字符相互匹配</span></span><br><span class="line">        first_match = bool(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 若之后存在*  212 1*</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode &lt;code&gt;1~10&lt;/code&gt; 题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://monteyang.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python-关于正则表达式的总结</title>
    <link href="http://monteyang.cn/Python-%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"/>
    <id>http://monteyang.cn/Python-%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html</id>
    <published>2019-12-16T14:08:42.000Z</published>
    <updated>2020-03-24T15:01:24.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h1><p>正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），用于字符串的<strong>匹配</strong>和<strong>提取</strong>等操作。正则表达式在所有编程语言中都是通用的。</p><!-- - 最常用的正则表达式| 正则表达式 | 功能                      || ---------- | ------------------------- || `.`        | 匹配任意字符,除换行符`\n` || `*`        | 将上一个字符重复0次或多次 || `+`        | 将上一个字符重复1次或多次 || `?`        | 将上一个字符重复0次或1次  || `\s`       | 匹配空白字符              || `\d`       | 匹配任意数字              | --><hr><h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><p>匹配单个字符</p><ul><li><code>.</code>    ： 匹配任意1个字符（除了\n）</li><li><code>[ ]</code>    ： 匹配[ ]中任意一个字符</li><li><code>\d</code>    ： 匹配数字，即0-9</li><li><code>\D</code>    ： 匹配非数字</li><li><code>\s</code>    ： 匹配空白，即 空格、tab键</li><li><code>\S</code>    ： 匹配非空白</li><li><code>\w</code>    ： 匹配单词字符，即a-z、A-Z、0-9、_</li><li><code>\W</code>    ： 匹配非单词字符</li></ul><p>匹配多个字符</p><ul><li><code>*</code>       ： 匹配前一个字符出现0次或无限次，即可有可无</li><li><code>+</code>       ： 匹配前一个字符出现1次或无限次，即至少有1次</li><li><code>?</code>       ： 匹配前一个字符出现1次或0次，即要么有1次，要么没有</li><li><code>{m}</code>     ： 匹配前一个字符出现m次</li><li><code>{m,n}</code>    ： 匹配前一个字符出现从m到n次</li></ul><p>匹配字符串首尾：</p><p>在正则表达式的首部添加<code>^</code>，意味着待匹配的字符串从首部就要和正则式匹配。类似的，正则式尾部添加<code>$</code>，表示待匹配的字符串从尾部需和正则式匹配。</p><ul><li><code>^</code>：匹配字符串的起始</li><li><code>$</code>：匹配字符串的末尾</li></ul><blockquote><p>常用的正则表达式：<a href="https://c.runoob.com/front-end/854" target="_blank" rel="external nofollow noopener noreferrer">https://c.runoob.com/front-end/854</a></p></blockquote><hr><h1 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h1><p>利用分组, 可以提取字符串中想要的指定内容。用括号<code>()</code>括起来的正则表达式表示一个分组，通过<code>group()</code>函数可获取分组中的字符串。例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配电话号码, 匹配模式中有两个分组：(\d&#123;3&#125;)、(\d&#123;3,8&#125;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)  <span class="comment"># 用group函数可以提取匹配的部分</span></span><br><span class="line"><span class="string">'010-12345'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)  <span class="comment"># group(1)表示第一个分组</span></span><br><span class="line"><span class="string">'010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)  <span class="comment"># group(2)表示第一个分组</span></span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure><p>如果想判断字符串中<strong>是否具有规律相同的多个子串</strong>时, 可以采用分组：</p><p>例如，正则表达式 <code>&lt;(\w*)&gt;.*&lt;(/\1)&gt;</code> 可以匹配 <code>&lt;h1&gt;fadsfas&lt;/h1&gt;</code>，不能匹配 <code>&lt;h1&gt;fadsfas&lt;/h2&gt;</code>。</p><p>当分组个数过多时，可以给分组起别名，在同一个正则表达式中重复引用该分组。</p><ul><li>分组起别名：<code>(?P&lt;name&gt;___)</code> 其中<code>___</code>填写分组内的正则式</li><li>引用别名为name的分组：<code>(?P=name)</code></li></ul><hr><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>在Python中，re模块已为我们实现了正则表达式的相关操作:</p><ul><li><code>re.match()</code>： 从头开始匹配，可以利用分组获得我们想要的子串。用法见上文。</li><li><code>re.search()</code>： 无需从头开始匹配，只返回<strong>匹配的第一个子字符串</strong>。</li><li><code>re.findall()</code>： 找到字符串中<strong>所有匹配的字符串</strong>，与<code>search()</code>不同，<code>findall()</code>直接返回一个list。</li><li><code>re.sub()</code>： 利用正则表达式将匹配到的字符串<strong>批量替换</strong>。</li><li><code>re.split()</code>：利用正则表达式<strong>分割字符串</strong>，返回一个list。</li></ul><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.search()</span></span><br><span class="line">In [<span class="number">7</span>]: ret = re.search(<span class="string">r"hello"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">8</span>]: ret.group()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.findall()</span></span><br><span class="line">In [<span class="number">9</span>]: ret = re.findall(<span class="string">r"hello"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">10</span>]: print(ret)</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'hello'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.sub()</span></span><br><span class="line">In [<span class="number">15</span>]: ret = re.sub(<span class="string">r"hello"</span>,<span class="string">"bye"</span>, <span class="string">"hello world! hello world!"</span>)</span><br><span class="line">In [<span class="number">16</span>]: ret</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'bye world! bye world!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.split()</span></span><br><span class="line">In [<span class="number">12</span>]: ret = re.split(<span class="string">r":| "</span>,<span class="string">"hello:YMN 25 shenyang"</span>)  <span class="comment"># 按:或空格分割字符串</span></span><br><span class="line">In [<span class="number">13</span>]: ret</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="string">'hello'</span>, <span class="string">'YMN'</span>, <span class="string">'25'</span>, <span class="string">'shenyang'</span>]</span><br></pre></td></tr></table></figure></p><hr><!-- TODO: # 贪婪和非贪婪 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是正则表达式？&quot;&gt;&lt;a href=&quot;#什么是正则表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式？&quot;&gt;&lt;/a&gt;什么是正则表达式？&lt;/h1&gt;&lt;p&gt;正则表达式（regular expression）描述了一种字符串匹配的模式（pat
      
    
    </summary>
    
    
      <category term="Python" scheme="http://monteyang.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://monteyang.cn/tags/Python/"/>
    
  </entry>
  
</feed>
